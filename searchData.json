[{"title":"Leetcode 200. Number of Islands","url":"/Leetcode-200-Number-of-Islands/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nGiven a two-dimensional array, `1` as the land and `0` as the sea, connecting the land to form an island. Think of the area outside the array as the sea, and determine how many islands there are.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-130-Surrounded-Regions '130. Surrounded Regions' %}\n* Medium - [695. Max Area of Island](https://leetcode.com/problems/max-area-of-island/)\n\n## Solution\nThe idea is very simple, we only need to traverse the two-dimensional array. When we meet `1`, just mark the current `1` and all the `1`s connected to it as 2. Then record how many `1` we have met, which means there are several islands. See the example below.\n\n```\n[1] 1 0 0 0\n 1  1 0 0 0\n 0 0 1 0 0\n 0 0 0 1 1\nMeet 1, count = 1;\n\nMark 1 and all 1s connected to it as 2\n2 2 0 0 0\n2 2 0 0 0\n0 0 1 0 0\n0 0 0 1 1\n\n2 2  0  0 0\n2 2  0  0 0\n0 0 [1] 0 0\n0 0  0  1 1\nMeet next 1, count = 2;\n\nMark 1 and all 1s connected to it as 2\n2 2 0 0 0\n2 2 0 0 0\n0 0 2 0 0\n0 0 0 1 1   \n\n2 2 0  0  0\n2 2 0  0  0\n0 0 2  0  0\n0 0 0 [1] 1  \nMeet next 1, count = 3;\n\nMark 1 and all 1s connected to it as 2\n2 2 0 0 0\n2 2 0 0 0\n0 0 2 0 0\n0 0 0 2 2  \n\nNo more 1, so the number of islands =  count = 3\n```\n\nAnother problem is how to mark all connected `1`s. It is also very straightforward. We can directly do a DFS using recursion.\n\n``` java\npublic int numIslands(char[][] grid) {\n    int result = 0;\n\n    // total number of rows\n    int rows = grid.length;\n\n    if (rows == 0) {\n        return result;\n    }\n\n    // total number of columns\n    int columns = grid[0].length;\n\n    // loop all points\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            if (grid[i][j] == '1') {\n                result++;\n\n                mark(i, j, rows, columns, grid);\n            }\n        }\n\n    }\n\n    return result;\n}\n\n// mark all '1' connected with grid[curRow][curCol] as '2'\nprivate void mark(int curRow, int curCol, int totalRow, int totalCol, char[][] grid) {\n    // reach boundary or the point is not '1'\n    if (curRow == -1 || curCol == -1 || curRow == totalRow || curCol == totalCol || grid[curRow][curCol] != '1') {\n        return;\n    }\n\n    // mark as '2'\n    grid[curRow][curCol] = 2;\n\n    // expand up, down, left, right\n    mark(curRow - 1, curCol, totalRow, totalCol, grid);\n    mark(curRow + 1, curCol, totalRow, totalCol, grid);\n    mark(curRow, curCol - 1, totalRow, totalCol, grid);\n    mark(curRow, curCol + 1, totalRow, totalCol, grid);\n}\n```","tags":["Leetcode - Depth First Search","Leetcode - Breadth First Search","Leetcode - Union Find"],"categories":["Data Structure and Algorithms"]},{"title":"Java Multithreading 8: Thread priority and daemon threads","url":"/Java-Multithreading-8-Thread-priority-and-daemon-threads/","content":"In this blog, we will introduce daemon threads and thread priorities. The contents include:\n1. Introduction to thread priority\n2. Examples of thread priority\n3. Examples of daemon threads\n\n## Introduction to thread priority\nThe thread priority in java ranges from `1` to `10`, and the default priority is `5`. High-priority threads will take precedence over low-priority threads.\n\nThere are two kinds of threads in java: `user threads` and `daemon threads`. They can be distinguished by the `isDaemon()` method: if `false` is returned, the thread is a `user thread`; otherwise it is a `daemon thread`.\n\n`User threads` generally perform user-level tasks, while `daemon threads` are also known as \"ackground threads and are generally used to perform background tasks. It should be noted that the Java virtual machine will exit after all `user threads` have ended.\n\nDescription from the JDK official document (https://docs.oracle.com/cd/E17802_01/j2se/j2se/1.5.0/jcp/beta1/apidiffs/java/lang/Thread.html):\n> Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.\nWhen a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:\nThe exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.\nAll threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method\n\n## Examples of thread priority\n``` java\npublic class PriorityDemo {\n    public static void main(String[] args) {\n        System.out.println(Thread.currentThread().getName() + \"(\" + Thread.currentThread().getPriority() + \")\");\n\n        Thread t1 = new MyThread(\"t1\");\n        Thread t2 = new MyThread(\"t2\");\n        // set priority\n        t1.setPriority(1);\n        t2.setPriority(10);\n        t1.start();\n        t2.start();\n    }\n}\n\nclass MyThread extends Thread {\n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(Thread.currentThread().getName()\n                    + \"(\" + Thread.currentThread().getPriority() + \")\"\n                    + \", loop \" + i);\n        }\n    }\n}\n```\n\nResults:\n```\nmain(5)\nt1(1), loop 0\nt2(10), loop 0\nt1(1), loop 1\nt2(10), loop 1\nt1(1), loop 2\nt2(10), loop 2\nt1(1), loop 3\nt2(10), loop 3\nt1(1), loop 4\nt2(10), loop 4\n```\n\nThe priority of the `main thread` is `5`.\n\nThe priority of `t1` is set to `1`, and the priority of `t2` is set to `10`. When the CPU executes `t1` and `t2`, it is scheduled according to the time slice, so it can be executed concurrently.\n\n## Examples of daemon threads\n``` java\npublic class DaemonDemo {\n    public static void main(String[] args) {\n        System.out.println(Thread.currentThread().getName() + \"(isDaemon=\" + Thread.currentThread().isDaemon() + \")\");\n\n        Thread t1 = new MyThread2(\"t1\");\n        Thread t2 = new MyDaemon(\"t2\");\n\n        t2.setDaemon(true);\n        t1.start();\n        t2.start();\n    }\n}\n\nclass MyThread2 extends Thread {\n    public MyThread2(String name) {\n        super(name);\n    }\n\n    public void run() {\n        try {\n            for (int i = 0; i < 5; i++) {\n                Thread.sleep(3);\n                System.out.println(this.getName() + \"(isDaemon=\" + this.isDaemon() + \")\" + \", loop \" + i);\n            }\n        } catch (InterruptedException e) {\n        }\n    }\n};\n\nclass MyDaemon extends Thread {\n    public MyDaemon(String name) {\n        super(name);\n    }\n\n    public void run() {\n        try {\n            for (int i = 0; i < 10000; i++) {\n                Thread.sleep(1);\n                System.out.println(this.getName() + \"(isDaemon=\" + this.isDaemon() + \")\" + \", loop \" + i);\n            }\n        } catch (InterruptedException e) {\n        }\n    }\n}\n```\n\nThe `main thread` is a `user thread`, and the sub-thread `t1` it creates is also a `user thread`.\n\n`t2` is a `daemon thread`. When the `main thread` and `t1` (they are both `user threads`) are executed, and only the `daemon thread` `t2` remains, the JVM automatically exits.","tags":["Multithreading"],"categories":["Java"]},{"title":"Leetcode 179: Largest Number","url":"/Leetcode-179-Largest-Number/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nGiven an array, arrange the numbers arbitrarily to form a number with the largest value.\n\n## Solution\nIntuitively, we should choose the number with largest highest number first. For numbers that start with 9, choose 9 first, then choose numbers that start with 8, then choose ones that start with 7 ... and so on.\n\nFor example, for `5`, `914`, `67`, choose `914` first, then `67`, and then `5`, to form `914675`. We try to select the number with largest highest number each time to ensure the final number be the biggest.\n\nThe next question is what if the highest digit is the same?\n1. If two numbers are equal in length, such as `34` and `30`, then obviously, choose the larger one.\n2. If two numbers are not equal in length, such as `3` and `30`, then choose `3` or `30` first?\n\nWe only need to contac them together and then compare. That is, compare `330` and `303`, it is obviously `330` big, so we choose `3` first.\n\nIf we think about it, we can find that all we need to do is sort the array by our rules and contac it afterwards.\n\nFor the comparision rule, all we have to do is compare the combined number and determine which one should comes first. \n\nFor example, for `93`, `234`, we will compare `93234` and `23493`. Then we will choose `93`.\n\n``` java\npublic String largestNumber(int[] nums) {\n    Integer[] temp = new Integer[nums.length];\n \n    // have a copy of nums in Integer\n    for (int i = 0; i < nums.length; i++) {\n        temp[i] = nums[i];\n    }\n\n    // sort the array\n    // the compare n1, n2, we compare lexicographic of n1n2 and n2n1\n    Arrays.sort(temp, (o1, o2) -> {\n        String s1 = o1 + \"\" + o2;\n        String s2 = o2 + \"\" + o1;\n\n        return s2.compareTo(s1);\n    });\n\n    // join the result\n    String result =  Arrays.stream(temp).map(Object::toString).collect(Collectors.joining());\n\n    return result.startsWith(\"0\") ? \"0\" : result;\n}\n```","tags":["Leetcode - Sort"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 166. Fraction to Recurring Decimal","url":"/Leetcode-166-Fraction-to-Recurring-Decimal/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nDo arithmetic division, if it is a cyclic decimal, the part of the loop should be enclosed in parentheses.\n\n## Solution\nIn simple words, this question is actually a simulation of our division process.\n\nFirst, let ’s talk about what process we want to simulate, taking `20/11` as an example.\n\nThe quotient obtained for the first time is the integer part, denoted as `integer`. We can directly use division between two ints.\n\n```\ninteger = 20 / 11 = 1\n```\n\nThen let's recall the process of division.\n\nAs shown in the figure below, the `quotient` is `1`, and the `remainder` is `9`. To get the `remainder` in the program, we can use `numerator - quotient * denominator`.\n\n```\nremainder = 20 - 1 * 11 = 9\n```\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nNext we multiply the `remainder` by `10` as the new `numerator`, and continue to use `11` as the `denominator`. Then get the `quotient` and the new `remainder`.\n\nSo calculate `90/11`.\n\n{% asset_img 2.png %}\n<br/>\n<br/>\n\nThen repeat the above process, multiply the `remainder` by `10` as the new `numerator`, and continue to use `11` as the `denominator`. Then get the `quotient` and the new `remainder`.\n\nSo calculate `20/11`.\n\n{% asset_img 3.png %}\n<br/>\n<br/>\n\nThen repeat the above process again, multiply the `remainder` by `10` as the new `numerator`, and continue to use `11` as the `denominator`. Then get the `quotient` and the new `remainder`.\n\nSo calculate `90/11`.\n\n{% asset_img 4.png %}\n<br/>\n<br/>\n\nSo when does it end?\n\n1. The `remainder` is 0, indicating that there is no cyclic decimal.\n2. At first, I felt that as long as there are repeated `quotient` (not considering the integer part number, which is the first 1 in the above example), it can be considered that there is a cyclic decimal.\n\nIn the above example, `8` appears for the second time, so it will not be calculated further. The decimal part of the loop is the position that repeats from the previous appearance of current number to the previous position, which is `81`. So the final result is `1.(81)`.\n\nHowever there is a counterexample as below:\n\n{% asset_img 5.png %}\n<br/>\n<br/>\n\nAlthough there are repeated `8`s, the end result is not `8` cycles. Obviously next time it will be `40/17`, and `quotient` is `2`. The reason is that the `numerator` corresponding to the two quotients `8` are not the same. The first is `150` and the second is `140`.\n\nTherefore, in order to judge whether there is a cyclic decimal, we should not judge whether there is a repeated quotient, but rather whether there is a repeated dividend.\n\nTherefore, in order to determine whether there is a cyclic decimal, we should not judge whether there is a repeated `quotient`, but rather whether there is a repeated `numerator`.\n\nTo record `quotient`, we will record the integer part and the decimal part separately. Because the decimal part has to accumulate records, For example, the first `quotient` is 1, and the second `quotient` is 2. We can multiply the previous `quotient` by `10` and add the new `quotient`. That is, `1 * 10 + 2 = 12`, when the third `quotient` `5` comes, it is `12 * 10 + 5 = 125`.\n\nBut for the above example `1/17`, the first `quotient` is `0`, and the second `quotient` is `5`. If the above recording method is used, `5` is recorded instead of `05`. In addition, if there are too many parts of the `quotient`, overflow will occur, so we need to record the `quotient` with `String`, and a new `quotient` can be added to the `String` each time.\n\nAnother question is how to determine whether there are duplicate `quotients`?\n\nQuite simply, using a `HashMap`, key records the `numerator` that have occurred, and value records where the `quotient` appears, so that when repeated `dividends` occur, we can immediately know what the fractional part of the loop is by value.\n\nThe last question, we only considered the example of positive numbers divided by positive numbers. What about positive numbers divided by negative numbers or negative numbers divided by negative numbers? Just like we did on paper, first determine the sign of the `quotient`, and then convert both the `numerator` and the `denominator` to positive numbers.\n\nThe above operation will cause a problem. In java, for `int` type, the minimum value of negative number is `-2147483648`, the maximum value of positive number is `2147483647`, and `-2147483648` cannot be converted into a positive number.\n\nThe problem of overflow is actually not the key to this problem, so we can simply use the `long` data type to store the number.\n\n``` java\npublic String fractionToDecimal(int numerator, int denominator) {\n    long num = numerator;\n    long den = denominator;\n\n    String sign = \"\";\n\n    // first determine the sign\n    if ((num > 0 && den < 0) || (num < 0 && den > 0)) {\n        sign = \"-\";\n    }\n\n    // make num and den positive\n    num = Math.abs(num);\n    den = Math.abs(den);\n\n    // determine the digit before decimal point\n    long integer = num / den;\n\n    // use a map to record encountered num and it's location\n    Map<Long, Integer> map = new HashMap<>();\n\n    // location of index after decimal point\n    int index = 0;\n\n    // use a string to record all digits after decimal point\n    StringBuilder decimal = new StringBuilder();\n\n    // mark the location of starting point of repeating\n    int repeatingIndex = -1;\n\n    // get the remaining\n    num = num - integer * den;\n\n    // enter while loop\n    // condition to exit: remaining is 0 or find repeating\n    while (num != 0) {\n        // remaining * 10\n        num = num * 10;\n\n        // find if we have already encountered this 'num' before\n        if (map.containsKey(num)) {\n            repeatingIndex = map.get(num);\n            break;\n        }\n\n        // put num to map\n        map.put(num, index);\n\n        // calculate new digit\n        long temp = num / den;\n\n        decimal.append(temp);\n\n        // update num\n        num = num - temp * den;\n\n        // increase index\n        index++;\n    }\n\n    // see if there is repeating\n    if (repeatingIndex != -1) {\n        return sign + integer + \".\" + decimal.substring(0, repeatingIndex) + \"(\" + decimal.substring(repeatingIndex) + \")\";\n    } else {\n        if (decimal.length() == 0) {\n            return sign + integer;\n        } else {\n            return sign + integer + \".\" + decimal;\n        }\n    }\n}\n```","tags":["Leetcode - Hash Table","Leetcode - Math"],"categories":["Data Structure and Algorithms"]},{"title":"Java Multithreading 7: Interrupt and end thread","url":"/Java-Multithreading-7-Interrupt-and-end-thread/","content":"This blog will introduce the `interrupt()` method and termination of threads. The contents include:\n1. `interrupt()` introduction\n2. The way to terminate the thread\n  1. Terminate threads in the `blocked state`\n  2. Terminate threads in the `running state`\n3. Example of thread termination\n4. The difference between `interrupted()` and `isInterrupted()`\n\n## interrupt() introduction\nRegarding `interrupt()`, look at the java `jdk11` documentation(https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#interrupt()):\n> Interrupts this thread.\nUnless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.\nIf this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.\nIf this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a ClosedByInterruptException.\nIf this thread is blocked in a Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's wakeup method were invoked.\nIf none of the previous conditions hold then this thread's interrupt status will be set.\nInterrupting a thread that is not alive need not have any effect.\n\n## The way to terminate the thread\n**<font color=\"orange\">The `stop()` and `suspend()` methods in `Thread` have been suggested not to be used due to inherent insecurity!</font>**\n\nThen, let's first discuss the termination of threads in the `blocked state` and `running state`, and then summarize a general method.\n\n### Terminate threads in the blocked state\nNormally, we terminate threads in `blocked state` by interrupting.\n\nWhen the thread is blocked due to calling `sleep()`, `wait()`, `join()` etc, if the `interrupt()` method of the thread is called at this time, the thread's interrupt flag is set to `true`. Due to the `blocked state`, the interrupt flag will be cleared and an `InterruptedException` exception will be generated. Put the `InterruptedException` at the appropriate place can terminate the thread.\n\n``` java\n@Override\npublic void run() {\n    try {\n        while (true) {\n            // execute tasks...\n        }\n    } catch (InterruptedException ie) {\n        // catch InterruptedException, exit while(true) loop, the thread exits\n    }\n}\n```\n\nContinuously execute tasks in `while(true)`. When the thread is blocked, the `interrupt()` of the calling thread generates an `InterruptedException` exception. The exception is captured outside of `while(true)`, so that the `while(true)` loop is exited!\n\nNote: the capture of `InterruptedException` is generally placed outside the body of the `while(true)` loop, so that when the exception occurs, the `while(true)` loop is exited. Otherwise, the `InterruptedException` is within the `while(true)` loop, and additional exit processing needs to be added.\n\n``` java\n@Override\npublic void run() {\n    while (true) {\n        try {\n            // execute tasks...\n        } catch (InterruptedException ie) {  \n            // InterruptedException inside while(true)\n            // when catch InterruptedException, while(true) is still running\n            break;\n        }\n    }\n}\n```\n\n### Terminate threads in the running state\nUsually, we terminate the thread in `running state` by flagging, including `interrupt flag` and `additional flag`.\n\n#### Use interrupt flag\n``` java\n@Override\npublic void run() {\n    while (!isInterrupted()) {\n        // execute task....\n    }\n}\n```\n\n`isInterrupted()` will determine whether the thread's `interrupt flag` is `true`. When the thread is running and we need to terminate it, we can call the thread's `interrupt()` method to make the thread's `interrupt flag` as `true`. Then `isInterrupted()` will return `true`. At this point, the while loop will exit.\n\nNote: `interrupt()` does not terminate the thread in the `running state`! It will set the thread's `interrupt flag` to `true`.\n\n#### Use additional flag\n``` java\nprivate volatile boolean flag = true;\nprotected void stopTask() {\n    flag = false;\n}\n\n@Override\npublic void run() {\n    while (flag) {\n        // execute tasks....\n    }\n}\n```\n\nThere is a flag boolean in the thread, and its default value is `true`. We provide `stopTask()` to set the flag. When we need to terminate the thread, call the thread's `stopTask()` method to let the thread exit the while loop.\n\nNote: The flag is set as `volatile` to ensure the visibility of flag. That is, after other threads modify the flag through `stopTask()`, the current thread can see the value of the modified flag.\n\nThe more general form of termination thread is as follows, which can terminate thread in `blocked state` and `running state`:\n\n``` java\n@Override\npublic void run() {\n    try {\n        // 1. if the interrupt flag is true, the thread is terminated\n        while (!isInterrupted()) {\n            // execute tasks...\n        }\n    } catch (InterruptedException ie) {  \n        // 2. When catch InterruptedException, thread is terminated\n    }\n}\n```\n\n## Example of thread termination\n`interrupt()` is often used to terminate `blocked` threads.\n\n``` java\npublic class InterruptDemo {\n    public static void main(String[] args) {\n        try {\n            // create thread t1\n            Thread t1 = new MyThread(\"t1\");\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is new.\");\n\n            // start thread t1\n            t1.start();\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is started.\");\n\n            // main thread sleep 300 ms, then interrupt t1\n            Thread.sleep(300);\n\n            t1.interrupt();\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is interrupted.\");\n\n            // main thread sleep 300 ms, then check t1 state\n            Thread.sleep(300);\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is interrupted now.\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class MyThread extends Thread {\n        public MyThread(String name) {\n            super(name);\n        }\n\n        @Override\n        public void run() {\n            try {\n                int i = 0;\n                while (!isInterrupted()) {\n                    Thread.sleep(100);\n\n                    i++;\n\n                    System.out.println(Thread.currentThread().getName() + \" (\" + this.getState() + \") loop \" + i);\n                }\n            } catch (InterruptedException e) {\n                System.out.println(Thread.currentThread().getName() + \" (\" + this.getState() + \") catch InterruptedException.\");\n            }\n        }\n    }\n}\n```\n\nResults:\n```\nt1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 1\nt1 (RUNNABLE) loop 2\nt1 (TIMED_WAITING) is interrupted.\nt1 (RUNNABLE) catch InterruptedException.\nt1 (TERMINATED) is interrupted now.\n```\n\nThe `main thread` creates thread `t1` through `new MyThread(\"t1\")`, and then starts thread t1 through `t1.start()`.\n\nAfter `t1` starts, it will constantly check its interrupt flag. If the interrupt flag is `false`, then sleep for 100ms.\n\nAfter t1 `sleeps`, it will switch to the `main thread`. When the `main thread` runs again, it will execute `t1.interrupt()` to interrupt the thread `t1`. After `t1` receives the interrupt instruction, it will set the interrupt flag of `t1` to false and an `InterruptedException` will be thrown. In the `run()` method of `t1`, it is an exception caught outside the while of the loop body; therefore the loop is terminated.\n\nWe make a small modification to the above example and move the block of code that caught `InterruptedException` in the `run()` to the body of the while loop\n\n``` java\npublic class InterruptDemo2 {\n    public static void main(String[] args) {\n        try {\n            // create thread t1\n            Thread t1 = new MyThread(\"t1\");\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is new.\");\n\n            // start thread t1\n            t1.start();\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is started.\");\n\n            // main thread sleep 300 ms, then interrupt t1\n\n            Thread.sleep(300);\n\n            t1.interrupt();\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is interrupted.\");\n\n            // main thread sleep 300 ms, then check t1 state\n            Thread.sleep(300);\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is interrupted now.\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class MyThread extends Thread {\n        public MyThread(String name) {\n            super(name);\n        }\n\n        @Override\n        public void run() {\n            int i = 0;\n\n            while (!isInterrupted()) {\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ie) {\n                    System.out.println(Thread.currentThread().getName() + \" (\" + this.getState() + \") catch InterruptedException.\");\n                }\n\n                i++;\n                System.out.println(Thread.currentThread().getName() + \" (\" + this.getState() + \") loop \" + i);\n            }\n        }\n    }\n}\n```\n\nResults:\n```\nt1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 1\nt1 (RUNNABLE) loop 2\nt1 (RUNNABLE) catch InterruptedException.\nt1 (RUNNABLE) loop 3\nt1 (TIMED_WAITING) is interrupted.\nt1 (RUNNABLE) loop 4\nt1 (RUNNABLE) loop 5\nt1 (RUNNABLE) loop 6\nt1 (RUNNABLE) is interrupted now.\nt1 (RUNNABLE) loop 7\nt1 (RUNNABLE) loop 8\nt1 (RUNNABLE) loop 9\nt1 (RUNNABLE) loop 10\n....\n```\n\nThe program has entered an infinite loop!\n\nWhy is this so? This is because `t1` is interrupted by `interrupt()` while in the `blocked state`. At this time, the interrupt flag will be cleared(`isInterrupted ()` will return `false`), and an `InterruptedException` will be thrown. This exception is caught in the while loop. Therefore, `t1` will naturally enter an endless loop.\n\nTo solve this problem, we need to additionally deal with the exit of the while loop when catching the exception. For example, adding `break` or `return` to `MyThread`'s `catch(InterruptedException)`.\n\nThe following is an example of terminate a thread by additional flag.\n\n``` java\npublic class InterruptDemo3 {\n    public static void main(String[] args) {\n        try {\n            // create thread t1\n            MyThread3 t1 = new MyThread3(\"t1\");\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is new.\");\n\n            // start thread t1\n            t1.start();\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is started.\");\n\n            // main thread sleep 300 ms, then interrupt t1\n\n            Thread.sleep(300);\n\n            t1.stopTask();\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is interrupted.\");\n\n            // main thread sleep 300 ms, then check t1 state\n            Thread.sleep(300);\n            System.out.println(t1.getName() + \" (\" + t1.getState() + \") is interrupted now.\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class MyThread3 extends Thread {\n        private volatile boolean flag = true;\n\n        public void stopTask() {\n            flag = false;\n        }\n\n        public MyThread3(String name) {\n            super(name);\n        }\n\n        @Override\n        public void run() {\n            synchronized (this) {\n                try {\n                    int i = 0;\n                    while (flag) {\n                        Thread.sleep(100);\n\n                        i++;\n                        System.out.println(Thread.currentThread().getName() + \" (\" + this.getState() + \") loop \" + i);\n                    }\n                } catch (InterruptedException ie) {\n                    System.out.println(Thread.currentThread().getName() + \" (\" + this.getState() + \") catch InterruptedException.\");\n                }\n            }\n        }\n    }\n}\n```\n\nResults:\n```\nt1 (NEW) is new.\nt1 (RUNNABLE) is started.\nt1 (RUNNABLE) loop 1\nt1 (RUNNABLE) loop 2\nt1 (TIMED_WAITING) is interrupted.\nt1 (RUNNABLE) loop 3\nt1 (TERMINATED) is interrupted now.\n```\n\n## The difference between `interrupted()` and `isInterrupted()`\nBoth `interrupted()` and `isInterrupted()` can be used to detect the `interrupt flag` of an object.\n\nThe difference is that in addition to returning the `interrupt flag`, `interrupted()` will also clear the `interrupt flag` (that is, set the `interrupt flag` to `false`). `isInterrupted()` only returns the `interrupt flag`.","tags":["Multithreading"],"categories":["Java"]},{"title":"Leetcode 162. Find Peak Element","url":"/Leetcode-162-Find-Peak-Element/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nGive an array, find any peak. The peak is larger than its left and right neighbors.\n\n### Similar Questions\n* Easy - [852. Peak Index in a Mountain Array](https://leetcode.com/problems/peak-index-in-a-mountain-array/)\n\n## Solution 1 - Linear scan\nBecause nums[-1] is regarded as negative infinity, so start from the 0-th element the array must be an upward trend. Since we are looking for the peak, when it first falls, the value before the decline is what we are looking for.\n\nIf it rises to the last value, and because nums[n] is regarded as negative infinity, the last value can be regarded as a peak.\n\n``` java\npublic int findPeakElement(int[] nums) {\n    for (int i = 0; i < nums.length - 1; i++) {\n        // first decline\n        if (nums[i] > nums[i + 1]) {\n            return i;\n        }\n    }\n\n    // always increasing\n    return nums.length - 1;\n}\n```\n\n## Solution 2 - Binary search\nWe generally use binary search on ordered arrays, so why can we use it for this problem?\n\nIn any case, the reason why we can use binary search is because we can directly discard half of the elements according to a certain condition, thereby reducing the time complexity to `logarithmic` level.\n\nAs for this question, because the question tells us that we can return any peak in the array. So as long as there is at least one peak in one half, the other half can be discarded.\n\nWe only need to compare `nums[mid]` and `nums[mid + 1]`.\n\nConsider the first search, `start = 0`, `end = nums.length - 1`.\n\nIf `nums[mid] < nums[mid + 1]`, the left part is in the ascending phase, because `nums[n]` is regarded as negative infinity, so it will eventually fall, so there will be at least one peak between `mid + 1` and `end`, we can discard the left half.\n\nIf `nums[mid] > nums[mid + 1]`, the right part is in the descending phase, because `nums[0]` is regarded as negative infinity, it must initially be the ascending phase, so there will be at least one peak between `start` and `mid`, we can discard the right half.\n\nThrough the cutting above, we ensure that the subsequent left part must be rising, and the right part must be falling, so the second and third search is the same as the above.\n\n``` java\npublic int findPeakElement(int[] nums) {\n    // binary search\n    int start = 0;\n    int end = nums.length - 1;\n\n    while (start < end) {\n        int mid = (start + end) / 2;\n\n        // peak in left part\n        if (nums[mid] > nums[mid + 1]) {\n            end = mid;\n        // peak in right part\n        } else {\n            start = mid + 1;\n        }\n    }\n\n    return start;\n}\n```","tags":["Leetcode - Array","Leetcode - Binary Search"],"categories":["Data Structure and Algorithms"]},{"title":"Java Multithreading 6: Join","url":"/Java-Multithreading-6-Join/","content":"This blog will introduce the `join()` method in `Thread`. The content includes:\n1. Introduction to `join()`\n2. `join()` source code analysis (based on JDK11.0.5)\n3. Example\n\n## Introduction to join()\n`join()` is defined in `Thread.java`.\n\n`join()` will let the `main thread` wait for the end of the `sub-thread` to continue running. Look at the examples:\n\n``` java\n// Main thread\npublic class Father extends Thread {\n    public void run() {\n        Son s = new Son();\n        s.start();\n        s.join();\n        ...\n    }\n}\n// sub thread\npublic class Son extends Thread {\n    public void run() {\n        ...\n    }\n}\n```\n\n`Son thread` is created and started in `Father thread`, so `Father thread` is the main thread and `Son thread` is the sub-thread.\n\nThe `Father thread` create a new sub-threads through `new Son()`, and then start sub thread `s.start()` and call `s.join()`. After calling `s.join()`, the `Father thread` will wait until the sub thread has finished running. After the sub thread `s` has finished running, the `Father thread` can continue to run. This is what we mean by `join()`, so that the main thread will wait for the child thread to finish before continuing to run!\n\n## join() source code analysis (based on JDK11.0.5)\n``` java\npublic final void join() throws InterruptedException {\n    join(0);\n}\n\npublic final synchronized void join(long millis)\nthrows InterruptedException {\n    long base = System.currentTimeMillis();\n    long now = 0;\n\n    if (millis < 0) {\n        throw new IllegalArgumentException(\"timeout value is negative\");\n    }\n\n    if (millis == 0) {\n        while (isAlive()) {\n            wait(0);\n        }\n    } else {\n        while (isAlive()) {\n            long delay = millis - now;\n            if (delay <= 0) {\n                break;\n            }\n            wait(delay);\n            now = System.currentTimeMillis() - base;\n        }\n    }\n}\n```\n\nFrom the code, we can find out that when `millis == 0`, it will enter `while(isAlive ())` loop. That is, as long as the child thread is alive, the main thread will keep waiting.\n\nLet look back at the above example:\n\nAlthough `s.join()` is called in the `Father thread`, `s.join()` is the method call on the `sub thread s`. Then, `isAlive()` in the `join()` method should determine whether the `sub thread s` is in the Alive state. The corresponding `wait(0)` should also let the `sub thread s` wait. But if this is the case, how could `s.join()` make `main thread` wait until the `sub thread s` is completed? It should instead make the `sub thread s` wait (because the wait method of the `subb thread s` is called)?\n\nWell, the answer is that `wait()` will make the **current thread** wait, and the **current thread** here refers to `the thread currently running on the CPU`. Therefore, although the `wait()` of the `sub thread` is called, it is called through the `main thread`. Therefore, it is the `main thread` that waits, not the `sub thread`!\n\n## Example\nAfter understanding the function of `join()`, let's look at the usage of `join()` through examples.\n\n``` java\npublic class JoinDemo {\n    public static void main(String[] args) {\n        try {\n            ThreadA t1 = new ThreadA(\"t1\");\n\n            // start t1\n            t1.start();\n            // join t1 to main thread，and main thread will wait for t1 to complete\n            t1.join();\n            \n            System.out.printf(\"%s finish\\n\", Thread.currentThread().getName());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class ThreadA extends Thread {\n\n        public ThreadA(String name) {\n            super(name);\n        }\n\n        public void run() {\n            System.out.printf(\"%s start\\n\", this.getName());\n\n            // delay\n            for (int i = 0; i < 1000000; i++)\n                ;\n\n            System.out.printf(\"%s finish\\n\", this.getName());\n        }\n    }\n}\n```\n\nResults:\n```\nt1 start\nt1 finish\nmain finish\n```\n\nThe execution sequence is shown in the figure:\n1. Create a new `thread t1` in the `main thread` with `new ThreadA(\"t1\")`. Next, start `thread t1` with `t1.start()` and execute `t1.join()`.\n2. After executing `t1.join()`, the `main thread` will enter the `blocked state` and wait for `t1` to finish running. After `t1` ends, it will wake up the `main thread`, and `main thread` regains the cpu execution right and continues to run.\n\n{% asset_img 1.png %}\n<br/>\n<br/>","tags":["Multithreading"],"categories":["Java"]},{"title":"Leetcode 153. Find Minimum in Rotated Sorted Array","url":"/Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nGiven a rotated sorted array, find the smallest number.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-33-Search-in-Rotated-Sorted-Array '33. Search in Rotated Sorted Array' %}\n* Hard - [154. Find Minimum in Rotated Sorted Array II](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/)\n\n## Solution\nTo find the minimum value, we can certainly traverse the whole array. However here is an ordered array, so we can use the dichotomy method to find, the dichotomy method should ensure that after each comparison, half of the elements are removed.\n\nHere we compare the midpoint and the end point. So do we compare the midpoint and the start point, or the midpoint and the end point? Let's analyze it.\n\n### Compare mid and start\n`mid > start: The minimum value is in the left half`\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\n`mid < start: the minimum value is in the left half`\n\n{% asset_img 2.png %}\n<br/>\n<br/>\n\nWhether `mid` is greater or less than `start`, the minimum value is always in the left half. So `mid` and `start` comparison is not desirable.\n\n### Compare mid and end\n`mid < end: The minimum value is in the left half`\n\n{% asset_img 3.png %}\n<br/>\n<br/>\n\n{% asset_img 4.png %}\n<br/>\n<br/>\n\n`mid > end: The minimum value is in the right half`\n\n{% asset_img 5.png %}\n<br/>\n<br/>\n\nSo we only need to compare `mid` and `end`, `mid < end` discards the right half (update `end = mid`), `mid > end` discards the left half (update `start = mid`). It can be finished until `end` is equal to `start`.\n\nBut there will be a problem for the following example, we will get an endless loop:\n\n{% asset_img 6.png %}\n<br/>\n<br/>\n\nThe problem is that when there are two elements left, `mid = (start + end) / 2`, and `mid` equals `start`. In the example above, `mid > end`, update `start = mid`, the position of `start` will not change. Then the value of `mid` will not change next time, it will endlessly. Therefore, we need to update `start = mid + 1`, and also make `start` point to the minimum value.\n\n``` java\npublic int findMin(int[] nums) {\n    // use binary search\n    // start, mid, end\n    // compare mid and start\n    // if mid < end, means right half is sorted, min value must be in left half\n    // if mid > end, means array must pivot at some value in the right half, thus min in the right half\n    int start = 0;\n    int end = nums.length - 1;\n\n    while (start < end) {\n        int mid = (start + end) / 2;\n\n        if (nums[mid] > nums[end]) {\n            start = mid + 1;\n        } else {\n            end = mid;\n        }\n    }\n\n    return nums[start];\n}\n```","tags":["Leetcode - Array","Leetcode - Binary Search"],"categories":["Data Structure and Algorithms"]},{"title":"Java Multithreading 5: Sleep","url":"/Java-Multithreading-5-Sleep/","content":"This blog will introduce the `sleep()` method in `Thread`. The content includes:\n1. Introduction to `sleep()`\n2. `Sleep()` example\n3. Comparison of `sleep()` and `wait()`\n\n## Introduction to sleep()\n`sleep()` is defined in `Thread.java`.\n\n`sleep()` will make the current thread sleep, that is, the current thread will enter the `blocked state (sleep)` from the `running state`. `sleep()` will specify the sleep time, the thread sleep time will be greater than/equal to the sleep time. When the thread is woken up again, it will change from `blocked state (sleep)` to `runnable state`, thereby waiting for the CPU to execute.\n\n## sleep() example\n``` java\nclass ThreadA extends Thread{\n    public ThreadA(String name){ \n        super(name); \n    } \n\n    public synchronized void run() { \n        try {\n            for(int i = 0; i < 10; i++){ \n                System.out.printf(\"%s: %d\\n\", this.getName(), i); \n                \n                if (i%4 == 0)\n                    Thread.sleep(100);\n            } \n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    } \n} \n\npublic class SleepDemo{ \n    public static void main(String[] args){ \n        ThreadA t1 = new ThreadA(\"t1\"); \n        t1.start(); \n    } \n}\n```\n\nResults:\n```\nt1: 0\nt1: 1\nt1: 2\nt1: 3\nt1: 4\nt1: 5\nt1: 6\nt1: 7\nt1: 8\nt1: 9\n```\n\nStart thread `t1` in the main thread. After `t1` starts, when the calculation `i` in `t1` is divisible by `4`, `t1` will sleep for 100 milliseconds through `Thread.sleep(100)`.\n\n## Comparison of sleep() and wait()\nWe know that `wait()` will let the current thread enter the `blocked state (wait)` from the `running state`, and also release the synchronization lock. `sleep()` will make the current thread enter the `blocked state (sleep)` from the `running state`.\n\n**<font color=\"orange\">However, wait() will release the synchronization lock of the object, while sleep() will not release the lock.</font>**\n\nExample:\n``` Java\npublic class SleepDemo {\n    private static final Object obj = new Object();\n\n    public static void main(String[] args) {\n        ThreadA t1 = new ThreadA(\"t1\");\n        ThreadA t2 = new ThreadA(\"t2\");\n        t1.start();\n        t2.start();\n    }\n\n    static class ThreadA extends Thread {\n        public ThreadA(String name) {\n            super(name);\n        }\n\n        public void run() {\n            // Acquire synchronization lock of obj\n            synchronized (obj) {\n                try {\n                    for (int i = 0; i < 10; i++) {\n                        System.out.printf(\"%s: %d\\n\", this.getName(), i);\n\n                        if (i % 4 == 0)\n                            Thread.sleep(100);\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\nResults:\n```\nt1: 0\nt1: 1\nt1: 2\nt1: 3\nt1: 4\nt1: 5\nt1: 6\nt1: 7\nt1: 8\nt1: 9\nt2: 0\nt2: 1\nt2: 2\nt2: 3\nt2: 4\nt2: 5\nt2: 6\nt2: 7\nt2: 8\nt2: 9\n```\n\nThreads `t1` and `t2` are started in the main thread. `t1` and `t2` will reference the synchronization lock of the same object in run(), namely `synchronized(obj)`. While `t1` is running, although it will call `Thread.sleep(100)`, `t2` will not get cpu execution rights, as `t1` did not release the synchronous lock of `obj`!\n\nNote that if we comment out `synchronized(obj)` and execute the program again, `t1` and `t2` can be switched to each other.\n\n```\nt1: 0\nt2: 0\nt1: 1\nt1: 2\nt1: 3\nt1: 4\nt2: 1\nt2: 2\nt2: 3\nt2: 4\nt2: 5\nt2: 6\nt2: 7\nt2: 8\nt1: 5\nt1: 6\nt1: 7\nt1: 8\nt2: 9\nt1: 9\n```","tags":["Multithreading"],"categories":["Java"]},{"title":"Leetcode 152. Maximum Product Subarray","url":"/Leetcode-152-Maximum-Product-Subarray/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nGiven an array, find the continuous sub-array which have the maximum multiplication.\n\n### Similar Questions\n* Easy - [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)\n* Easy - [198. House Robber](https://leetcode.com/problems/house-robber/)\n* Medium - [238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)\n* Easy - [628. Maximum Product of Three Numbers](https://leetcode.com/problems/maximum-product-of-three-numbers/)\n* Medium - [713. Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/)\n\n## Solution\nWe first define an array `dpMax`, and use `dpMax[i]` to denote the value of the largest product with the sub-array ending with the i-th element, that is, this array must contain the i-th element.\n\nThen `dpMax[i]` has several possible values:\n* When `nums[i] >= 0` and `dpMax[i-1] > 0`, `dpMax[i] = dpMax[i-1] * nums[i]`\n* When `nums[i] >= 0` and `dpMax[i-1] < 0`, if it is multiplied by the previous number, it will become a negative number, so `dpMax[i] = nums[i]`\n* When `nums[i] < 0`, if the previous multiplication result is a large negative number, it will become a larger number if it is multiplied with the current negative number. So we also need an array `dpMin` to record the the smallest product value with sub-array ending in the i-th element, .\n  * When `dpMin[i-1] < 0`, `dpMax[i] = dpMin[i-1] * nums[i]`\n  * When `dpMin[i-1] >= 0`, `dpMax[i] = nums[i]`\n\nOf course, how to find `dpMin` is actually the same as the process of finding `dpMax` above.\n\nAccording to the above analysis, we need to have a lot of if else to determine different situations, here we can use a trick.\n\nWe noticed that the values of `dpMax[i]` above are nothing more than three types\n* `dpMax[i-1] * nums[i]`\n* `dpMin[i-1] * nums[i]`\n* `nums[i]`\n\nSo when we update, we don't need to distinguish the current situation, we only need to choose the largest one from the three values:\n\n``` java\ndpMax[i] = max(dpMax[i-1] * nums[i], dpMin[i-1] * nums[i], nums[i]);\n```\n\nThe same applis for `dpMin[i]`:\n\n``` java\ndpMin[i] = min(dpMax[i-1] * nums[i], dpMin[i-1] * nums[i], nums[i]);\n```\n\nAlso notice that  when updating `dp[i]`, we only used `dp[i-1]`, and the previous information would not be used. So we don't need an array at all, we just need a variable to repeat overwrite and update.\n\n``` java\npublic int maxProduct(int[] nums) {\n    int result = 0;\n\n    if (nums.length == 0) {\n        return result;\n    }\n\n    // need to keep a record of max product and min product ending at index i\n    // want to keep min because if current < 0, we want min * current become large if min < 0\n    int preMax = nums[0];\n    int preMin = nums[0];\n\n    result = preMax;\n\n    for (int i = 1; i < nums.length; i++) {\n        // 3 conditions\n        //  1 - nums[i] >= 0 and preMax > 0\n        //      then we update preMax = preMax * num[i]\n        //  2 - nums[i] >= 0 and preMax < 0\n        //      then we update preMax = nums[i]\n        //  3 - nums[i] < 0\n        //      then if preMin < 0, then update preMax = preMin * nums[i]\n        //           else preMax = nums[i]\n        // we can see there are 3 possible values: preMax * num[i], nums[i], preMin * nums[i]\n        int tempMax = preMax;\n\n        preMax = Math.max(preMax * nums[i], Math.max(nums[i], preMin * nums[i]));\n        preMin = Math.min(tempMax * nums[i], Math.min(nums[i], preMin * nums[i]));\n\n        result = Math.max(preMax, result);\n    }\n\n    return result;\n}\n```","tags":["Leetcode - Dynamic Programming","Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Java Multithreading 4: yield","url":"/Java-Multithreading-4-yield/","content":"This blog will introduce the `yield()` method in `Thread`. The content involved includes:\n1. Introduction to `yield()`\n2. `yield()` example\n3. Comparison of `yield()` and `wait()`\n\n## Introduction to yield()\nThe effect of `yield()` is to give in. It can make the current thread enter the `runnable state` from the `running state`, so that other waiting threads with the same priority can obtain execution rights. However, there is no guarantee that after the current thread calls `yield()`, others have the same priority will be able to obtain the execution right. It may also be that the current thread enters the `running state` and continues to run!\n\n## yield() example\n``` java\npublic class YieldDemo {\n    public static void main(String[] args) {\n        ThreadA t1 = new ThreadA(\"t1\");\n        ThreadA t2 = new ThreadA(\"t2\");\n        t1.start();\n        t2.start();\n    }\n\n    static class ThreadA extends Thread {\n        public ThreadA(String name) {\n            super(name);\n        }\n\n        public synchronized void run() {\n            for (int i = 0; i < 10; i++) {\n                System.out.printf(\"%s [%d]:%d\\n\", this.getName(), this.getPriority(), i);\n\n                if (i % 4 == 0)\n                    Thread.yield();\n            }\n        }\n    }\n}\n```\n\nOne of the possible result:\n```\nt1 [5]:0\nt2 [5]:0\nt1 [5]:1\nt1 [5]:2\nt1 [5]:3\nt1 [5]:4\nt1 [5]:5\nt1 [5]:6\nt1 [5]:7\nt1 [5]:8\nt1 [5]:9\nt2 [5]:1\nt2 [5]:2\nt2 [5]:3\nt2 [5]:4\nt2 [5]:5\nt2 [5]:6\nt2 [5]:7\nt2 [5]:8\nt2 [5]:9\n```\n\n`t1` did not switch to `t2` when it could be divided by 4. This shows that although `yield()` can make the thread enter the `runnable state` from the `running state`, it does not necessarily allow other threads to obtain CPU execution rights (that is, other threads enter the `running state`), even if other threads have the same priority as the thread currently calling `yield()`.\n\n## Comparison of yield() and wait()\nWe know that `wait()` will let the current thread enter the `blocked state (wait)` from the `running state`, and also release the synchronization lock. `yield()` will also make the current thread leave the `running state`. The difference is:\n\n1. `wait()` will let the thread enter the `blocked state  (wait)` from the `running state`, while `yield()` will let the thread enter the `runnable state` from the `running state`.\n2. `wait()` will release the synchronization lock of the object it holds, and the `yield()` method will **not release the lock**.\n3. `yield() will give up the CPU execution time, rather than giving up the resource lock`\n\n``` java\npublic class YieldDemo2 {\n    private static Object obj = new Object();\n\n    public static void main(String[] args) {\n        ThreadA t1 = new ThreadA(\"t1\");\n        ThreadA t2 = new ThreadA(\"t2\");\n        t1.start();\n        t2.start();\n    }\n\n    static class ThreadA extends Thread {\n        public ThreadA(String name) {\n            super(name);\n        }\n\n        public void run() {\n            synchronized (obj) {\n                for (int i = 0; i < 10; i++) {\n                    System.out.printf(\"%s [%d]:%d\\n\", this.getName(), this.getPriority(), i);\n\n                    if (i % 4 == 0)\n                        Thread.yield();\n                }\n            }\n        }\n    }\n}\n```\n\nResults:\n```\nt1 [5]:0\nt1 [5]:1\nt1 [5]:2\nt1 [5]:3\nt1 [5]:4\nt1 [5]:5\nt1 [5]:6\nt1 [5]:7\nt1 [5]:8\nt1 [5]:9\nt2 [5]:0\nt2 [5]:1\nt2 [5]:2\nt2 [5]:3\nt2 [5]:4\nt2 [5]:5\nt2 [5]:6\nt2 [5]:7\nt2 [5]:8\nt2 [5]:9\n```\n\nThe main thread started two threads `t1` and `t2`. `t1` and `t2` will reference the synchronization lock of the same object in `run()`, namely `synchronized(obj)`. While `t1` is running, although it will call `Thread.yield()`, `t2` will not get cpu execution rights. Because, `t1` did not release the synchronous lock of `obj`!","tags":["Multithreading"],"categories":["Java"]},{"title":"Leetcode 148. Sort List","url":"/Leetcode-148-Sort-List/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nSort a linked list. Required time complexity is `O(nlogn)`. The most commonly used method is `merge sort`.\n\n### Similar Questions\n* Easy - [21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)\n* Medium - {% post_link Leetcode-75-Sort-Colors '75. Sort Colors' %}\n* Medium - {% post_link Leetcode-147-Insertion-Sort-List '147. Insertion Sort List' %}\n\n## Solution\nFirstly, merge sort requires a helper method, which is used to merge two sorted linked lists.\n\nMerge sorting is done half and half, so we need to find the midpoint. The most common method is to find the midpoint with fast and slow pointer.\n\n``` java\n// add a dummy pointer to the start\n// so that in the end, the slow pointer always point to the last element of left half\nListNode dummy = new ListNode(0);\ndummy.next = node;\n\n// use fast and slow pointer\nListNode slow = dummy;\nListNode fast = dummy;\n\n// split the list\nwhile (fast != null && fast.next != null) {\n    slow = slow.next;\n    fast = fast.next.next;\n}\n```\n\nIn the above code, there is a dummy node. When the number of nodes is even, then `slow` just point to the last node of the previous half of the node, which is the state below.\n```\n1    2    3    4\n     ^         ^\n    slow      fast\n```\n\nIf both `slow` and `fast` start from the `head`, then when `fast` ends, `slow` will go to the beginning of the next half of the node.\n\n``` java\npublic static ListNode sortList(ListNode head) {\n    return mergeSort(head);\n}\n\n// helper method to split original list into 2 half\n// recursive the left and right half\n// merge the left and right half\nprivate static ListNode mergeSort(ListNode node) {\n    // reach the end\n    if (node == null || node.next == null) {\n        return node;\n    }\n\n    // add a dummy pointer to the start\n    // so that in the end, the slow pointer always point to the last element of left half\n    ListNode dummy = new ListNode(0);\n    dummy.next = node;\n\n    // use fast and slow pointer\n    ListNode slow = dummy;\n    ListNode fast = dummy;\n\n    // split the list\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    // slow is the last node of left half\n    ListNode rightHalf = slow.next;\n\n    // make slow.next = null so we have 2 split list\n    slow.next = null;\n\n    // recursive sort the left and right half\n    ListNode head1 = mergeSort(node);\n    ListNode right = mergeSort(rightHalf);\n\n    return merge(head1, right);\n}\n\n// helper method to merge 2 sorted list\nprivate static ListNode merge(ListNode head1, ListNode head2) {\n    ListNode dummyHead = new ListNode(0);\n    ListNode lastNode = dummyHead;\n\n    while (head1 != null && head2 != null) {\n        if (head1.val < head2.val) {\n            // head1 is smaller\n            // add head1 to the last\n            // move head1 to next\n            lastNode.next = head1;\n            lastNode = lastNode.next;\n            head1 = head1.next;\n        } else {\n            lastNode.next = head2;\n            lastNode = lastNode.next;\n            head2 = head2.next;\n        }\n    }\n\n    // we exit the while loop because one of the head1 or head2 reach end\n    // append the other one to the last\n    if (head1 != null) {\n        lastNode.next = head1;\n    }\n\n    if (head2 != null) {\n        lastNode.next = head2;\n    }\n\n    return dummyHead.next;\n}\n```\n\nOf course, strictly speaking, the space complexity of the solution above is not `O(1)`, because pushing the stack in the recursive process consumes space, and takes half each time, so the space complexity is `O(logn)`.","tags":["Leetcode - Linked List","Leetcode - Sort"],"categories":["Data Structure and Algorithms"]},{"title":"Java Multithreading 3: Wait and notify","url":"/Java-Multithreading-3-Wait-and-notify/","content":"In this blog I will introduce the thread wait/notify method. Contents include:\n1. `wait()`, `notify()`, `notifyAll()` and other methods\n2. `wait()` and `notify()`\n3. `wait(long timeout)` and `notify()`\n4. `wait()` and `notifyAll()`\n5. Why `notify()`, `wait()` and other functions are defined in `Object` instead of `Thread`\n\n## wait(), notify(), notifyAll() and other methods\n`Object.java` defines interfaces such as `wait()`, `notify()` and `notifyAll()`. The role of `wait()` is to put the current thread into a wait state. At the same time, `wait()` will let the current thread release the lock it holds. The role of `notify()` and `notifyAll()` is to wake up the waiting thread on the current object; `notify()` will wake up a single thread, and `notifyAll()` will wake up all threads.\n\nThe detailed information about the wait/notify API in the `Object` class is as follows:\n* **notify ()**: wakes up a single thread waiting on this object monitor.\n* **notifyAll()**: wake up all threads waiting on this object monitor.\n* **wait()**: puts the current thread in the `blocked state  (wait)`, until other threads call this object's `notify()` method or `notifyAll()` method\", the current thread is woken up and enter the `runnable` state.\n* **wait(long timeout)**: put the current thread in the `blocked state  (wait)`, until other threads call this object's `notify()` method or `notifyAll()` method, or exceed the specified amount of time, the current thread is woken up and enter the `runnable` state.\n* **wait(long timeout, int nanos)**: put the current thread in the `blocked state  (wait)`, until other threads call the `notify()` method or `notifyAll()` method of this object, or some other thread interrupts the current thread, or a certain amount of time has been exceeded, the current thread is woken up and enter the `runnable` state.\n\n## wait() and notify() example\n``` java\npublic class WaitAndNotify {\n    public static void main(String[] args) {\n        ThreadA t1 = new ThreadA(\"t1\");\n\n        synchronized(t1) {\n            try {\n                // Start thread t1\n                System.out.println(Thread.currentThread().getName()+\" start t1\");\n                t1.start();\n\n                // Main thread waits for t1 to wake up via notify ()\n                System.out.println(Thread.currentThread().getName()+\" wait()\");\n                t1.wait();\n\n                System.out.println(Thread.currentThread().getName()+\" continue\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nclass ThreadA extends Thread {\n    public ThreadA(String name) {\n        super(name);\n    }\n\n    public void run() {\n        synchronized (this) {\n            System.out.println(Thread.currentThread().getName()+\" call notify()\");\n            // awake current wait thread\n            notify();\n        }\n    }\n}\n```\n\nResults:\n```\nmain start t1\nmain wait()\nt1 call notify()\nmain continue\n```\n\nThe following figure illustrates the flow of \"main thread\" and \"thread t1\".\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\n* Note that \"thread t1\" stands for `Thread t1` started in `WaitAndNotify`. And \"lock\" stands for synchronization lock of t1.\n* `Main thread` creates a new `thread t1` through `new ThreadA (\"t1\")`. Then acquire synchronization lock of t1 through `synchronized(t1)`. Then call `t1.start()` to start `thread t1`.\n* The `main thread` executes `t1.wait()` to release the t1 object's lock and enters the `blocked state  (wait)`. Wait for the thread on the `t1` object to wake it up via `notify()` or `notifyAll()`.\n* After `thread t1` runs, it acquire lock of current object through `synchronized(this)`. Then call `notify()` to wake up \"waiting thread on current object\", that is, wake up `main thread`.\n* After `thread t1` is finished, release lock of current object. Immediately after that, the `main thread` acquires the t1 object's lock and continues running.\n\nFor the code above, `t1.wait()` should let `thread t1` wait; but why did it let `main thread` wait?\n\nLet's look at the comments of `wait()` in JDK:\n\n> Causes the current thread to wait until it is awakened, typically by being notified or interrupted.\n\nNote: In the comments, `wait()` is to let the **current thread** wait, and the **current thread** refers to the thread running on the CPU!\n\nThis means that although `t1.wait()` is the `wait()` method called through `thread t1`, the place where `t1.wait()` is called is in `main thread`. The `main thread` must be the current thread, which is in **running** state to execute `t1.wait()`. Therefore, the current thread at this time is the `main thread`! Therefore, `t1.wait()` makes the `main thread` wait, not `thread t1`!\n\n## wait(long timeout) and notify()\n`wait(long timeout)` will make the current thread in the `blocked state  (wait)`, until other threads call this object's `notify()` method or `notifyAll()` method, or exceed the specified amount of time, the current thread is woken up and enter `runnable state`.\n\n``` java\npublic class WaitTimeout {\n    public static void main(String[] args) {\n        ThreadB t1 = new ThreadB(\"t1\");\n\n        synchronized(t1) {\n            try {\n                // start Thread t1\n                System.out.println(Thread.currentThread().getName() + \" start t1\");\n                t1.start();\n\n                // The main thread waits for t1 to wake up via notify() or notifyAll()\n                // or a delay of more than 3000ms; then it is woken up.\n                System.out.println(Thread.currentThread().getName() + \" call wait \");\n                t1.wait(3000);\n\n                System.out.println(Thread.currentThread().getName() + \" continue\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nclass ThreadB extends Thread {\n    public ThreadB(String name) {\n        super(name);\n    }\n\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+\" run\");\n\n        // infinite loop\n        while(true)\n            ;\n    }\n}\n```\n\nResults:\n```\nmain start t1\nmain call wait \nt1 run          // After around 3 seconds...output \"main continue\"\nmain continue\n```\n\nThe following figure illustrates the flow of \"main thread\" and \"thread t1\".\n\n{% asset_img 2.png %}\n<br/>\n<br/>\n\n* The `main thread` executes `t1.start()` to start `thread t1`.\n* The `main thread` executes `t1.wait(3000)`. At this time, the `main thread` enters the `blocked state  (wait)`. Need the thread used for t1 object lock to wake it up through `notify()` or `notifyAll()` or after a timeout of 3000ms, the `main thread` enters the `runnable state` before it can run.\n* After `thread t1` runs, it enters an endless loop and runs continuously.\n* After a timeout of 3000ms, the `main thread` will enter the `runnable state`, and then enter the `running state`.\n\n## wait() and notifyAll()\n``` java\npublic class NotifyAll {\n    private static Object obj = new Object();\n\n    public static void main(String[] args) {\n        ThreadC t1 = new ThreadC(\"t1\");\n        ThreadC t2 = new ThreadC(\"t2\");\n        ThreadC t3 = new ThreadC(\"t3\");\n        t1.start();\n        t2.start();\n        t3.start();\n\n        try {\n            System.out.println(Thread.currentThread().getName()+\" sleep(3000)\");\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        synchronized(obj) {\n            System.out.println(Thread.currentThread().getName()+\" notifyAll()\");\n            obj.notifyAll();\n        }\n    }\n\n    static class ThreadC extends Thread{\n        public ThreadC(String name){\n            super(name);\n        }\n\n        public void run() {\n            synchronized (obj) {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \" wait\");\n\n                    // awake current wait thread\n                    obj.wait();\n\n                    System.out.println(Thread.currentThread().getName() + \" continue\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\nResults:\n```\nt1 wait\nmain sleep(3000)\nt3 wait\nt2 wait\nmain notifyAll()\nt2 continue\nt3 continue\nt1 continue\n```\n\n{% asset_img 3.png %}\n<br/>\n<br/>\n\n* `main thread` created and started `t1`, `t2` and `t3`.\n* The `main thread` sleeps for 3 seconds through `sleep(3000)`. In the process of `main thread` sleeping, we assume that the three threads `t1`, `t2` and `t3` are all running. Take `t1` as an example, when it is running, it will execute `obj.wait()` to wait for other threads to wake it up via `notify()` or `nofityAll()`. The same reason, `t2` and `t3` will also wait for other threads to wake them up via `nofity()` or `nofityAll()`.\n* After the `main thread` sleeps for 3 seconds, it continue runs and execute `obj.notifyAll()` to wake up the waiting thread on `obj`, that is, wake up the three threads `t1`, `t2` and `t3`. Immediately after the `synchronized(obj)` of the `main thread` is finished, the `main thread` releases the `obj` lock. In this way, `t1`, `t2` and `t3` can acquire the `obj` lock and continue to run!\n\n## Why notify(), wait() and other functions are defined in Object instead of Thread\nThe `wait()`, `notify()` and other functions in `Object`, like `synchronized`, will operate on \"object synchronization lock\".\n\n`wait()` will make the current thread wait, because the thread enters the `blocked state  (wait)`, so the thread should release the synchronization lock it holds, otherwise other threads cannot obtain the synchronization lock and cannot run!\n\nOK, after the thread calls `wait()`, it releases the synchronous lock it holds. According to previous introduction, we know that the waiting thread can be woken up by `notify()` or `notifyAll()`. Now, think about a question: on what basis does `notify()` wake up the waiting thread? In other words, what is the relationship between `wait()` and `notify()`? The answer is: according to object synchronization lock.\n\nThe thread responsible for awakening the waiting thread (we call it \"awakening thread\"), it is only acquiring the object synchronization lock (the synchronization lock here must be the same as the synchronization lock of the waiting thread), and calling `notify()` or `notifyAll()` method, the waiting thread can be woken up. Although, the waiting thread is awakened, it cannot be executed immediately because the awakening thread also holds the object synchronization lock. You must wait for the awakening thread to release the object synchronization lock before the waiting thread can acquire the object synchronization lock and continue to run.\n\nIn short, `notify()`, `wait()` depends on object synchronization lock, and object synchronization lock is held by an object, and each object has only one lock! This is why `notify()`, `wait()` and other functions are defined in the `Object` class, not the `Thread` class.\n","tags":["Multithreading"],"categories":["Java"]},{"title":"Leetcode 147. Insertion Sort List","url":"/Leetcode-147-Insertion-Sort-List/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nImplement insertion sorting based on linked lists.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-148-Sort-List '148. Sort List' %}\n\n## Solution\nThe so-called insertion sorting is to take one number at a time and insert it to the correct position.\n\nFor exampel:\n```\n4 2 1 3\nres = []\n\nTake 4\nres = [4]\n\nTake 2\nres = [2 4]\n\nTake 1\nres = [1 2 4] \n\nTake 3\nres = [1 2 3 4]\n```\n\nTo implement it, because we want to take out an element from the linked list that we want to insert it into the sorted list, we must first traverse the sorted list, find the first position that is larger than the element to be inserted, and insert the element in front.\n\nAs for insertion, we need to know the node before the insertion position, so we can use `node.next` to compare with the node to be inserted, `node` is the node before the insertion position.\n\nThe head pointer is already at the forefront, so we can use a dummy pointer to unify the situation of the head pointer.\n\n``` java\npublic ListNode insertionSortList(ListNode head) {\n    // if input list has no element return null\n    if (head == null) {\n        return null;\n    }\n\n    // create a dummyHead, the node before the actual head\n    ListNode dummyHead = new ListNode(0);\n\n    // current node\n    ListNode current = head;\n\n    // loop original list\n    while (current != null) {\n        ListNode temp = dummyHead;\n        // need this temp to record the next of current\n        final ListNode currentNext = current.next;\n\n        // set current.next to null as we don't want to move everything after current\n        current.next = null;\n\n        // find the node in the result that is greater than current node\n        while (temp.next != null) {\n            if (temp.next.val > current.val) {\n                // move the head from original to the result\n                current.next = temp.next;\n                temp.next = current;\n\n                // find the spot for this node, move to next\n                break;\n            }\n\n            // check next in result\n            temp = temp.next;\n        }\n\n        // didn't find, mean current greater than all in the result\n        if (temp.next == null) {\n            temp.next = current;\n        }\n\n        // move current node\n        current = currentNext;\n    }\n\n    return dummyHead.next;\n}\n```","tags":["Leetcode - Linked List","Leetcode - Sort"],"categories":["Data Structure and Algorithms"]},{"title":"Java Multithreading 2: Synchronized Keyword","url":"/Java-Multithreading-2-Synchronized-Keyword/","content":"## Principle of synchronized\n**In Java, each object has only one synchronization lock. This also means that the synchronization lock is dependent on the existance of object.**\n\n**When we call the synchronized method of an object, we acquire the synchronization lock of the object.** For example, `synchronized(obj)` acquires the synchronization lock of \"obj\".\n\n**The access from different threads to synchronization locks are mutually exclusive.** In other words, at a certain point in time, the synchronization lock of an object can only be acquired by one thread! With synchronization locks, we can achieve mutually exclusive access to \"objects/methods\" in multiple threads environment. For example, there are now two threads `A` and `B`, both of which will access the \"synchronous lock of object obj\". Suppose, at a certain moment, thread `A` acquires \"obj's synchronization lock\" and is performing some operations; and at this time, thread `B` also attempts to acquire \"obj's synchronization lock\" - thread `B` will fail to acquire it and must wait, Until thread `A` releases the \"synchronization lock of the obj\", thread `B` cannot acquire the \"synchronization lock of obj\".\n\n## Basic rules of synchronized\n**<font color=\"orange\">When a thread accesses the \"synchronized method\" or \"synchronized code block\" of \"some object\", other threads' access to the \"synchronized method\" or \"synchronized code block\" of \"this object\" will be blocked</font>**\n\nExample:\n\n``` java\nclass MyRunable implements Runnable {\n    @Override\n    public void run() {\n        synchronized(this) {\n            try {  \n                for (int i = 0; i < 5; i++) {\n                    Thread.sleep(100); // sleep 100ms\n                    System.out.println(Thread.currentThread().getName() + \" loop \" + i);  \n                }\n            } catch (InterruptedException ie) {  \n            }\n        }  \n    }\n}\n\npublic class Demo1_1 {\n    public static void main(String[] args) {  \n        Runnable demo = new MyRunable();     // create “Runnable”\n\n        Thread t1 = new Thread(demo, \"t1\");  // create “thread t1”\n        Thread t2 = new Thread(demo, \"t2\");  // create “thread t2”\n        t1.start();                          // start “thread t1”\n        t2.start();                          // start “thread t2”\n    } \n}\n```\n\nResults:\n```\nt1 loop 0\nt1 loop 1\nt1 loop 2\nt1 loop 3\nt1 loop 4\nt2 loop 0\nt2 loop 1\nt2 loop 2\nt2 loop 3\nt2 loop 4\n```\n\nThe `synchronized (this)` exists in the `run()` method, and both `t1` and `t2` are threads created based on `demo`. We can think of `this` in `synchronized(this)` as the `demo`. Threads `t1` and `t2` share the \"`demo` synchronization lock\". Therefore, when one thread is running, the other thread must wait for the \"running thread\" to release the \"`demo` synchronization lock\" before running.\n\nThen let's modify the above code, and then run to see how is the results:\n``` java\nclass MyThread extends Thread {\n    \n    public MyThread(String name) {\n        super(name);\n    }\n\n    @Override\n    public void run() {\n        synchronized(this) {\n            try {  \n                for (int i = 0; i < 5; i++) {\n                    Thread.sleep(100); // sleep 100ms\n                    System.out.println(Thread.currentThread().getName() + \" loop \" + i);  \n                }\n            } catch (InterruptedException ie) {  \n            }\n        }  \n    }\n}\n\npublic class Demo1_2 {\n    public static void main(String[] args) {  \n        Thread t1 = new Thread(demo, \"t1\");  // create “thread t1”\n        Thread t2 = new Thread(demo, \"t2\");  // create “thread t2”\n        t1.start();                          // start “thread t1”\n        t2.start();                          // start “thread t2”\n    } \n}\n```\n\nThis time `MyThread` class directly inherits from `Thread`, and both `t1` and `t2` are `MyThread` child threads.\n\nResults:\n```\nt1 loop 0\nt2 loop 0\nt1 loop 1\nt2 loop 1\nt1 loop 2\nt2 loop 2\nt1 loop 3\nt2 loop 3\nt1 loop 4\nt2 loop 4\n```\n\n`This` in `synchronized(this)` refers to the \"current class object\", that is, the current object corresponding to the class where `synchronized(this)` is located. Its role is to acquire the \"synchronization lock of the current object\".\n\nFor `Demo1_2`, `this` in `synchronized(this)` represents the `MyThread` object, and `t1` and `t2` are two different `MyThread` objects, so when `t1` and `t2` execute `synchronized(this)`, they acquire synchronization locks of different objects. For `Demo1_1`, `this` in `synchronized(this)` represents the `MyRunable` object; `t1` and `t2` share a `MyRunable` object. Therefore, one thread acquires the synchronization lock of the object and causes another thread to wait.\n\n**<font color=\"orange\">When a thread accesses the \"synchronized method\" or \"synchronized code block\" of \"some object\", other threads can still access the \"non synchronized code block\" of \"this object\".</font>**\n\n``` java\nclass Count {\n    // method with synchronized block\n    public void synMethod() {\n        synchronized(this) {\n            try {  \n                for (int i = 0; i < 5; i++) {\n                    Thread.sleep(100); // sleep 100ms\n                    System.out.println(Thread.currentThread().getName() + \" synMethod loop \" + i);  \n                }\n            } catch (InterruptedException ie) {  \n            }\n        }  \n    }\n\n    // non synchronized block\n    public void nonSynMethod() {\n        try {  \n            for (int i = 0; i < 5; i++) {\n                Thread.sleep(100);\n                System.out.println(Thread.currentThread().getName() + \" nonSynMethod loop \" + i);  \n            }\n        } catch (InterruptedException ie) {  \n        }\n    }\n}\n\npublic class Demo2 {\n    public static void main(String[] args) {  \n        final Count count = new Count();\n\n        // create t1, t1 will call count object's synMethod()\n        Thread t1 = new Thread(\n                new Runnable() {\n                    @Override\n                    public void run() {\n                        count.synMethod();\n                    }\n                }, \"t1\");\n\n        // create t2, t2 will call count object's nonSynMethod()\n        Thread t2 = new Thread(\n                new Runnable() {\n                    @Override\n                    public void run() {\n                        count.nonSynMethod();\n                    }\n                }, \"t2\");  \n\n\n        t1.start();  // start t1\n        t2.start();  // start t2\n    } \n}\n```\n\nResults:\n```\nt1 synMethod loop 0\nt2 nonSynMethod loop 0\nt1 synMethod loop 1\nt2 nonSynMethod loop 1\nt1 synMethod loop 2\nt2 nonSynMethod loop 2\nt1 synMethod loop 3\nt2 nonSynMethod loop 3\nt1 synMethod loop 4\nt2 nonSynMethod loop 4\n```\n\nMain thread creates `t1` and `t2`. `t1` will call the `synMethod()` method of the `count` object, which contains the synchronization block; and `t2` will call the `nonSynMethod()` method of the `count` object, which is not a synchronization method. While `t1` is running, although `synchronized(this)` is called to obtain the `count` synchronization lock. It does not cause `t2` to block because `t2` does not use the \"`count` synchronization lock.\n\n**<font color=\"orange\">When a thread accesses the \"synchronized method\" or \"synchronized code block\" of \"an object\", other threads' access to other \"synchronized methods\" or \"synchronized code blocks\" of the \"object\" will be blocked.</font>**\n\nWe modify the `nonSynMethod()` method in the above example with `synchronized (this)`\n\n``` java\nclass Count {\n    // method with synchronized block\n    public void synMethod() {\n        synchronized(this) {\n            try {  \n                for (int i = 0; i < 5; i++) {\n                    Thread.sleep(100); // sleep 100ms\n                    System.out.println(Thread.currentThread().getName() + \" synMethod loop \" + i);  \n                }\n            } catch (InterruptedException ie) {  \n            }\n        }  \n    }\n\n    // synchronized block 2\n    public void nonSynMethod() {\n        synchronized(this) {\n            try {  \n                for (int i = 0; i < 5; i++) {\n                    Thread.sleep(100);\n                    System.out.println(Thread.currentThread().getName() + \" nonSynMethod loop \" + i);  \n                }\n            } catch (InterruptedException ie) {  \n            }\n        }\n    }\n}\n\npublic class Demo2 {\n    public static void main(String[] args) {  \n        final Count count = new Count();\n\n        // create t1, t1 will call count object's synMethod()\n        Thread t1 = new Thread(\n                new Runnable() {\n                    @Override\n                    public void run() {\n                        count.synMethod();\n                    }\n                }, \"t1\");\n\n        // create t2, t2 will call count object's nonSynMethod()\n        Thread t2 = new Thread(\n                new Runnable() {\n                    @Override\n                    public void run() {\n                        count.nonSynMethod();\n                    }\n                }, \"t2\");  \n\n\n        t1.start();  // start t1\n        t2.start();  // start t2\n    } \n}\n```\n\nResults:\n```\nt1 synMethod loop 0\nt1 synMethod loop 1\nt1 synMethod loop 2\nt1 synMethod loop 3\nt1 synMethod loop 4\nt2 nonSynMethod loop 0\nt2 nonSynMethod loop 1\nt2 nonSynMethod loop 2\nt2 nonSynMethod loop 3\nt2 nonSynMethod loop 4\n```\n\nMain thread creates `t1` and `t2`. `synchronized(this)` is called when both `t1` and `t2` run, `this` is the `count` object, and `t1` and `t2` share the `count`. Therefore, when `t1` is running, `t2` will be blocked and wait for `t1` to run and release the `count` synchronization lock.\n\n## Synchronized method and Synchronized block\nSynchronized method is to modify the method with `synchronized`\n\n``` java\npublic synchronized void foo1() {\n    System.out.println(\"synchronized methoed\");\n}\n```\n\nSynchronized code block is to modify the code block with `synchronized`.\n``` java\npublic void foo2() {\n    synchronized (this) {\n        System.out.println(\"synchronized methoed\");\n    }\n}\n```\n\n`this` in the synchronized code block refers to the current object. You can also replace `this` with other objects, for example, replace `this` with `obj`, then `foo2()` acquires the synchronization lock of `obj` when executing `synchronized(obj)`.\n\nSynchronized code blocks can more precisely control conflicts and restrict access to areas, and sometimes perform more efficiently.\n\n## Instance lock and global lock\n**<font color=\"orange\">Instance loc</font>**\n  * lock on an instance object. If the class is a singleton, then the lock also has the concept of a global lock.\n  * The instance lock corresponds to the `synchronized` keyword.\n\n**<font color=\"orange\">Global lock</font>**\n  * The lock is for a class, no matter how many objects are instantiated, the thread shares the lock.\n  * The global lock corresponds to `static synchronized` (or locked on the class or classloader object of the class)\n\nLet's look at the following example:\n``` java\npublic class Something {\n    public synchronized void isSyncA(){\n        try {\n            for (int i = 0; i < 5; i++) {\n                Thread.sleep(100); // Sleep 100ms\n                System.out.println(Thread.currentThread().getName()+\" : isSyncA\");\n            }\n        }catch (InterruptedException ie) {\n        }\n    }\n    \n    public synchronized void isSyncB(){\n        try {\n            for (int i = 0; i < 5; i++) {\n                Thread.sleep(100); // Sleep 100ms\n                System.out.println(Thread.currentThread().getName()+\" : isSyncB\");\n            }\n        }catch (InterruptedException ie) {\n        }\n    }\n    \n    public static synchronized void cSyncA(){\n        try {\n            for (int i = 0; i < 5; i++) {\n                Thread.sleep(100); // Sleep 100ms\n                System.out.println(Thread.currentThread().getName()+\" : cSyncA\");\n            }\n        }catch (InterruptedException ie) {\n        }\n    }\n    \n    public static synchronized void cSyncB(){\n        try {\n            for (int i = 0; i < 5; i++) {\n                Thread.sleep(100); // Sleep 100ms\n                System.out.println(Thread.currentThread().getName()+\" : cSyncB\");\n            }\n        }catch (InterruptedException ie) {\n        }\n    }\n}\n```\n\nSuppose, `Something` has two instances `x` and `y`. Analyze the locks acquired by the following 4 scenarios.\n1. `x.isSyncA()` and `x.isSyncB()`\n2. `x.isSyncA()` and `y.isSyncA()`\n3. `x.cSyncA()` and `y.cSyncB()`\n4. `x.isSyncA()` and `Something.cSyncA()`\n\n### x.isSyncA() and x.isSyncB()\n**Cannot** be accessed simultaneously. Because `isSyncA()` and `isSyncB()` share the same synchronization locks on the object instance `x`!\n\n``` java\npublic class LockTest1 {\n    Something x = new Something();\n\n    // x.isSyncA() and x.isSyncB() \n    private void test1() {\n        // create t11, t11 will call x.isSyncA()\n        Thread t11 = new Thread(\n                new Runnable() {\n                    @Override\n                    public void run() {\n                        x.isSyncA();\n                    }\n                }, \"t11\");\n\n        // create t12, t12 will call x.isSyncA()\n        Thread t12 = new Thread(\n                new Runnable() {\n                    @Override\n                    public void run() {\n                        x.isSyncB();\n                    }\n                }, \"t12\");\n\n\n        t11.start();  // start t11\n        t12.start();  // start t12\n    }\n\n    public static void main(String[] args) {\n        LockTest1 demo = new LockTest1();\n        demo.test1();\n    }\n}\n```\n\nResults:\n```\nt11 : isSyncA\nt11 : isSyncA\nt11 : isSyncA\nt11 : isSyncA\nt11 : isSyncA\nt12 : isSyncB\nt12 : isSyncB\nt12 : isSyncB\nt12 : isSyncB\nt12 : isSyncB\n```\n\n### x.isSyncA() and y.isSyncA()\n**Can** be accessed simultaneously. Because t21 and t22 don't try to acquire the same lock. `x.isSyncA()` accesses the synchronization lock of `x`, and `y.isSyncA()` accesses the synchronization lock of `y`.\n\n``` java\npublic class LockTest2 {\n    Something x = new Something();\n    Something y = new Something();\n\n    // x.isSyncA() and y.isSyncA()\n    private void test2() {\n        // create t21, t22 will call x.isSyncA()\n        Thread t21 = new Thread(\n                new Runnable() {\n                    @Override\n                    public void run() {\n                        x.isSyncA();\n                    }\n                }, \"t21\");\n\n        // create t22, t22 will call x.isSyncA()\n        Thread t22 = new Thread(\n                new Runnable() {\n                    @Override\n                    public void run() {\n                        y.isSyncA();\n                    }\n                }, \"t22\");\n\n\n        t21.start();  // start t21\n        t22.start();  // start t22\n    }\n\n    public static void main(String[] args) {\n        LockTest2 demo = new LockTest2();\n        demo.test2();\n    }\n}\n```\n\nResults:\n```\nt21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\nt22 : isSyncA\nt21 : isSyncA\n```\n\n### x.cSyncA() and y.cSyncB()\n**Cannot** be accessed simultaneously. Because `cSyncA()` and `cSyncB()` are `static`, `x.cSyncA()` is equivalent to `Something.isSyncA()`, and `y.cSyncB()` is equivalent to `Something.isSyncB()`, so they share the same synchronization lock and cannot be acquired at the same time.\n\n``` java\npublic class LockTest3 {\n    Something x = new Something();\n    Something y = new Something();\n\n    // x.cSyncA() and y.cSyncB()\n    private void test3() {\n        // create t31, t31 will call x.cSyncA()\n        Thread t31 = new Thread(\n                new Runnable() {\n                    @Override\n                    public void run() {\n                        x.cSyncA();\n                    }\n                }, \"t31\");\n\n        // create t32, t32 will call y.cSyncB()\n        Thread t32 = new Thread(\n                new Runnable() {\n                    @Override\n                    public void run() {\n                        y.cSyncB();\n                    }\n                }, \"t32\");\n\n\n        t31.start();  // start t31\n        t32.start();  // start t32\n    }\n\n    public static void main(String[] args) {\n        LockTest3 demo = new LockTest3();\n        demo.test3();\n    }\n}\n```\n\nResults:\n```\nt31 : cSyncA\nt31 : cSyncA\nt31 : cSyncA\nt31 : cSyncA\nt31 : cSyncA\nt32 : cSyncB\nt32 : cSyncB\nt32 : cSyncB\nt32 : cSyncB\nt32 : cSyncB\n```\n\n### x.isSyncA() and Something.cSyncA()\n**Can** be accessed simultaneously. Because `isSyncA()` is an instance method, `x.isSyncA()` uses the lock of object `x`; while `cSyncA()` is a static method, `Something.cSyncA()` uses class lock. Therefore, they can be accessed simultaneously.\n\n``` java\npublic class LockTest4 {\n    Something x = new Something();\n\n    // x.isSyncA() and x.cSyncA()\n    private void test4() {\n        // create t41, t41 will call x.isSyncA()\n        Thread t41 = new Thread(\n                new Runnable() {\n                    @Override\n                    public void run() {\n                        x.isSyncA();\n                    }\n                }, \"t41\");\n\n        // create t42, t42 will call x.cSyncA()\n        Thread t42 = new Thread(\n                new Runnable() {\n                    @Override\n                    public void run() {\n                        x.cSyncA();\n                    }\n                }, \"t42\");\n\n\n        t41.start();  // start t41\n        t42.start();  // start t42\n    }\n\n    public static void main(String[] args) {\n        LockTest4 demo = new LockTest4();\n        demo.test4();\n    }\n}\n```\n\nResults:\n```\nt41 : isSyncA\nt42 : cSyncA\nt42 : cSyncA\nt41 : isSyncA\nt42 : cSyncA\nt41 : isSyncA\nt42 : cSyncA\nt41 : isSyncA\nt41 : isSyncA\nt42 : cSyncA\n```","tags":["Multithreading"],"categories":["Java"]},{"title":"Java Multithreading 1: Basic Concepts","url":"/Java-Multithreading-1-Basic-Concepts/","content":"From today, I will start a series of blogs introducing topics related to multithreading in Java. It will only focus on entry contents rather than in-depth complicated issues.\n\nIn this blog I will disucss the following topics:\n* Process and Thread\n* State of thread\n* Implement multithreading in Java\n  * Thread\n  * Runnable\n* The difference between start() and run() in Thread\n\n## Process and Thread\nLet's first look at the difference between `processes` and `threads` in the operating system:\n\n* **Process**: Each process has its own code and data space (process context). Switching between processes will have a large overhead. A process contains 1--n threads. (Process is the smallest unit of resource allocation)\n* **Thread**: The same type of thread shares code and data space, each thread has an independent running stack and program counter (PC), and the thread switching overhead is small. (Thread is the smallest unit of CPU scheduling)\n\n`Multi-process` means that the operating system can run multiple tasks (programs) at the same time.\n\n`Multithreading` refers to the execution of multiple sequential streams in the same program.\n\n## State of thread\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nThread includes the following 5 states.\n1. **New**: after the thread object is created, it enters the `new` state. For example, `Thread thread = new Thread()`.\n2. **Runnable**: also known as \"executable state\". After the thread object is created, other threads call the object's `start()` method to start the thread. For example, `thread.start()`. Threads in the `runnable` state may be scheduled for execution by the CPU at any time.\n3. **Running**: thread obtains CPU permission to execute. It should be noted that the `thread can only enter the running state from the runnable state`.\n4. **Blocked**: the thread gives up the CPU usage right for some reasons and temporarily stops running. Until the thread enters the `runnable` state, there is no chance to go to the `running` state. There are three blocking situations:\n  1. *Waiting blocking* - by calling the thread's `wait()` method, the thread is allowed to wait for the completion of a job.\n  2. *Synchronous blocking* - the thread fails to acquire the synchronized lock (because the lock is occupied by other threads), it will enter the synchronized blocking state.\n  3. *Other blocking* - by calling the thread's `sleep()` or `join()` or issuing an I/O request, the thread will enter the blocking state. When the `sleep()` state times out, `join()` waits for the thread to terminate or time out, or the I/O processing is complete, the thread re-enters the `runnable` state.\n5. **Dead**: the thread finishes execution or exits the `run()` method due to an exception, the thread ends its life cycle.\n\n## Implement multithreading in Java\nTo implement multithreading in Java, there are two methods: one is to `inherit the Thread class`, and the other is to `implement the Runable interface`. (Actually, there should be three, and one is to `implement the Callable interface` and use with `Future` and `Thread pool`, this blog does not talk about this)\n\n### Introduction to Thread and Runnable\n`Runnable` is an interface that contains only one `run()` method:\n\n``` Java\npublic interface Runnable {\n    public abstract void run();\n}\n```\n\n`Thread` is a class. `Thread` itself implements the `Runnable` interface:\n\n``` java\npublic class Thread implements Runnable {}\n```\n\n### Comparing Thread and Runnable\n`Thread` and `Runnable` are both used to implement multithread.\n\n**Difference**:\n* `Thread` is a class, and `Runnable` is an interface. We know that \"a class can only have one parent class, but it can implement multiple interfaces\", so `Runnable` has better scalability.\n* `Runnable` can be used for \"resource sharing\". That is, multiple threads are based on a certain `Runnable` object, they will share the resources on the `Runnable` object.\n\nGenerally, it is recommended to implement multithreading through `Runnable`\n* `Runnable` is suitable for multiple threads of the same program code to process the same resource\n* The limitation of single inheritance in Java can be avoided by using `Runnable`\n* Using `Runnable` creases the robustness of the program, the code can be shared by multiple threads. The code and data are independent\n* The thread pool can only be put into the thread that implements `Runable` or `Callable`, not directly into the class that inherits `Thread`\n\n## Thread example\n``` Java\nclass MyThread extends Thread{  \n    private int ticket = 10;  \n\n    public void run(){\n        for(int i = 0; i < 20; i++){ \n            if(this.ticket > 0){\n                System.out.println(this.getName()+\" Selling ticket: ticket\" + this.ticket--);\n            }\n        }\n    } \n};\n\npublic class ThreadTest {  \n    public static void main(String[] args) {  \n        // Create 3 threads t1, t2, t3: every thread sell 10 tickets\n        MyThread t1=new MyThread();\n        MyThread t2=new MyThread();\n        MyThread t3=new MyThread();\n\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n```\n\nResults:\n```\nThread-0 Selling ticket: ticket10\nThread-1 Selling ticket: ticket10\nThread-2 Selling ticket: ticket10\nThread-1 Selling ticket: ticket9\nThread-0 Selling ticket: ticket9\nThread-1 Selling ticket: ticket8\nThread-2 Selling ticket: ticket9\nThread-1 Selling ticket: ticket7\nThread-0 Selling ticket: ticket8\nThread-1 Selling ticket: ticket6\nThread-2 Selling ticket: ticket8\nThread-1 Selling ticket: ticket5\nThread-0 Selling ticket: ticket7\nThread-1 Selling ticket: ticket4\nThread-2 Selling ticket: ticket7\nThread-1 Selling ticket: ticket3\nThread-0 Selling ticket: ticket6\nThread-1 Selling ticket: ticket2\nThread-2 Selling ticket: ticket6\nThread-2 Selling ticket: ticket5\nThread-2 Selling ticket: ticket4\nThread-1 Selling ticket: ticket1\nThread-0 Selling ticket: ticket5\nThread-2 Selling ticket: ticket3\nThread-0 Selling ticket: ticket4\nThread-2 Selling ticket: ticket2\nThread-0 Selling ticket: ticket3\nThread-2 Selling ticket: ticket1\nThread-0 Selling ticket: ticket2\nThread-0 Selling ticket: ticket1\n```\n\n`MyThread` inherits from `Thread`, it is a custom thread. Each `MyThread` will sell 10 tickets.\n\nThe main thread creates and starts three `MyThread` sub-threads. Each child thread sold 10 tickets.\n\n## Runnable example\nNext, we modify the above program: implement `Runnable` interface to achieve multithreading\n\n``` Java\nclass MyThread implements Runnable {  \n    private int ticket = 10;\n\n    public void run(){\n        for(int i = 0; i < 20; i++){ \n            if(this.ticket > 0){\n                System.out.println(Thread.currentThread().getName()+\" Selling ticket: ticket\" + this.ticket--);\n            }\n        }\n    } \n}; \n\npublic class RunnableTest {  \n    public static void main(String[] args) {  \n        MyThread mt = new MyThread();\n\n        Thread t1 = new Thread(mt);\n        Thread t2 = new Thread(mt);\n        Thread t3 = new Thread(mt);\n\n        t1.start();\n        t2.start();\n        t3.start();\n    }  \n}\n```\n\nResults:\n\n```\nThread-0 Selling ticket: ticket10\nThread-2 Selling ticket: ticket8\nThread-1 Selling ticket: ticket9\nThread-2 Selling ticket: ticket6\nThread-0 Selling ticket: ticket7\nThread-2 Selling ticket: ticket4\nThread-1 Selling ticket: ticket5\nThread-2 Selling ticket: ticket2\nThread-0 Selling ticket: ticket3\nThread-1 Selling ticket: ticket1\n```\n\nUnlike the above \"`MyThread` inherits from `Thread`\", `MyThread` here implements the `Runnable` interface.\n\nThe main thread creates and starts 3 child threads, and these 3 child threads are all created based on `mt`. The running result is that these 3 sub-threads sold a total of 10 tickets. This shows that they share the `MyThread` interface.\n\nNote that this example could sell more than 10 tickets! `T1`, `t2`, and `t3` share a task and operate on the ticket at the same time. It may cause concurrency problems. For example, the value of the tickets read at the beginning of `t1` and `t2` are both `10`, and after `t1` sells a ticket, `ticket = 9`; at this time `t2` sells tickets, and the number of tickets read before `t2` is `10`, so, after `t2` sells, it is also `9` tickets. In this case, the problem arises: after the original `10` tickets, `t1` and `t2` each sell one ticket, but there are `9` tickets left! This leads to \"the actual number of tickets sold may be more than 10\"! We will discuss how to avoid this in the future blogs.\n\n## The difference between start() and run() in Thread\n* **start()**: start a new thread, and the new thread will execute the corresponding `run()` method. `start()` cannot be called repeatedly\n  * After the `start()` method is called, the multi-threaded code is not executed immediately, but the thread is made to be `Runnable`. When to run the code is determined by the operating system\n  * If the `start()` method is called repeatedly, a `java.lang.IllegalThreadStateException` exception will occur\n* **run()**: `run()` is just like the normal member method and can be called repeatedly. Calling `run()` alone will execute `run()` in the current thread without starting a new thread!\n\n## start() and run() example\n``` Java\npublic class StartAndRun {\n    public static void main(String[] args) {\n        Thread myThread=new MyThread(\"myThread\");\n\n        System.out.println(Thread.currentThread().getName()+\" call myThread.run()\");\n        myThread.run();\n\n        System.out.println(Thread.currentThread().getName()+\" call myThread.start()\");\n        myThread.start();\n    }\n}\n\nclass MyThread extends Thread{\n    public MyThread(String name) {\n        super(name);\n    }\n\n    public void run(){\n        System.out.println(Thread.currentThread().getName()+\" is running\");\n    }\n}\n```\n\nResults:\n```\nmain call myThread.run()\nmain is running\nmain call myThread.start()\nmyThread is running\n```\n\n`Thread.currentThread().getName()` is used to get the name of \"current thread\". The current thread refers to the thread that is being scheduled for execution in the CPU.\n\n`myThread.run()` is called in \"main thread\", and the `run()` method runs directly on \"main thread\".\n\n`myThread.start()` will start \"thread myThread\". After \"thread myThread\" starts, it will call the `run()` method; the `run()` method at this time is running on \"thread myThread\".\n\n## Source code of start() and run() (based on JDK 11.0.5)\nThe source code of the `start()` method in `Thread.java` is as follows:\n\n``` Java\npublic synchronized void start() {\n    // If the thread is not in the \"Runnable\" state, an exception is thrown!\n    if (threadStatus != 0)\n        throw new IllegalThreadStateException();\n\n    // Add the thread to ThreadGroup\n    group.add(this);\n\n    boolean started = false;\n    try {\n        // Start the thread via start0()\n        start0();\n        // Set the started variable\n        started = true;\n    } finally {\n        try {\n            if (!started) {\n                group.threadStartFailed(this);\n            }\n        } catch (Throwable ignore) {\n        }\n    }\n}\n```\n\nNote: `start()` actually starts the thread through the native method `start0()`. And `start0()` will run a new thread, and the new thread will call the `run()` method.\n\n``` Java\nprivate native void start0();\n```\n\nThe source code of the `run()` method in `Thread.java` is as follows:\n``` Java\npublic void run() {\n    if (target != null) {\n        target.run();\n    }\n}\n```\n\n`target` is a `Runnable` object. `run()` will directly call the `run()` method of the `Runnable` member of the `Thread`, and does not create a new thread.","tags":["Multithreading"],"categories":["Java"]},{"title":"Leetcode 142. Linked List Cycle II","url":"/Leetcode-142-Linked-List-Cycle-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven a linked list,  determine the entry point of the loop. The entry point is essentially the intersection point of the line and the circle.\n\n### Similar Questions\n* Easy - [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)\n* Medium - [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\n\n## Solution - HashSet\nTraverse the linked list, and save the traversed nodes with `HashSet`. If we encounter the previous node during the traversal, it means that this node is the entry point we want to find. If it reaches `null`, there is no loop.\n\n``` java\npublic ListNode detectCycle(ListNode head) {\n    Set<ListNode> nodes = new HashSet<>();\n\n    while (head != null) {\n        nodes.add(head);\n\n        head = head.next;\n\n        if (nodes.contains(head)) {\n            return head;\n        }\n    }\n\n    return null;\n}\n```\n\n## Solution - Two Pointers\nTwo pointers is one of the most commonly used method when solving linked list problems.\n\n> The principle of fast and slow pointers is easy to understand. Imagine a round track where two people are running. If one person runs fast and one person runs slowly, then no matter where they start from, the two will definitely meet during the run.\nSo here we use two pointers fast and slow. Fast takes two steps at a time, and slow takes one step at a time. If fast reaches null, there is no ring. If fast and slow meet, there is a loop.\n\nBut for this problem, we need to find the entry point, and the point where the `fast` and `slow` pointers meet may not be the entry point, but a certain point in the loop, so some mathematical derivation is needed here. Referenced from: https://leetcode.com/problems/linked-list-cycle-ii/discuss/44793/O(n)-solution-by-using-two-pointers-without-change-anything\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nThe distance from the `head` to the `entry point` is set to `x`, the distance from the `entry point` to the `meeting point` is set to `y`, and the length of the loop is set to `n`.\n\nAssuming the distance traveled by the `slow` pointer is `t`, then the `fast` pointer must travel twice the distance of the `slow` pointer, which is `2t`.\n\nThe `slow` pointer starts from the `head` and walks the distance of `x` to reach the `entry point`, and then possibly walks `k1` circles, then returns to the `entry point` again, and then walks the distance of `y` to reach the `meeting point` and meet the `fast` pointer.\n\n```\nt = x + k1 * n + y\n```\n\nThe same applies to the `fast` pointer. The `fast` pointer starts from the `head` and walks a distance of `x` to reach the `entry point`, and then possibly walks `k2` circle, then returns to the `entry point` again, and then walks a distance of `y` to reach the `meeting point` and meet the `slow` pointer.\n\n```\n2t = x + k2 * n + y\n```\n\nTake the difference by the two equations above, you can get\n\n```\nt = (k2 - k1) * n\n```\n\nLet `k = k2-k1`, then `t = k * n`.\n\nSubstitute `t = k * n` into the first expression `t = x + k1 * n + y`.\n\n```\nk * n = x + k1 * n + y\n```\n\nShift term, `x = (k-k1) * n-y`\n\nTake a combination of `n` and `y`, get:\n\n```\nx = (k-k1-1) * n + (n-y)\n```\n\nThe left part of the equation means: reach the `entry point` from `head`.\n\nThe right part of the equation means: `n-y` is the distance from the `meeting point` to the `entry point`, `(k-k1-1) * n` is to turn `(k-k1-1)` circle.\n\nCombining left and right part: walking from the `meeting point` to the `entry point`, then turning `(k-k1-1)` circle and returning to the `entry point` again is exactly the same time from `head` to the `entry point`.\n\nSo for the code, we only need the `meet` pointer to start from the `meeting point`, and let the `head` pointer also start. The position where the `head` pointer meets the `meet pointer` is the `entry point`.\n\n``` Java\npublic ListNode detectCycle(ListNode head) {\n    ListNode slow = head;\n    ListNode fast = head;\n    ListNode meet = null;\n\n    while (fast != null) {\n        // no loop\n        if (fast.next == null) {\n            return null;\n        }\n    }\n\n    // move forward slow and fast\n    slow = slow.next;\n    fast = fast.next.next;\n\n    // reach the meet point\n    if (fast == slow) {\n        meet = fast;\n\n        // start move forward head, until meet point\n        while (head != meet) {\n            head = head.next;\n            meet = meet.next;\n        }\n\n        return head;\n    }\n\n    return null;\n}\n```","tags":["Leetcode - Linked List","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 139. Word Break","url":"/Leetcode-139-Word-Break/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGive a string, and some words, and determine if the string can be composed of these words. Each word can be used multiple times or not.\n\n### Similar Questions\n* Hard - [140. Word Break II](https://leetcode.com/problems/word-break-ii/)\n\n## Solution\nDivide and conquer, big problems are converted into small problems and solved by small problems.\n\nWe now need to determine whether the target string `s` can be composed of `wordDict`.\n\nUse `canBreak[i]` to indicate whether the substring `s[0, i)` can be composed of `wordDict`.\n\nSuppose we know `canBreak[1]`, `canBreak[2]`, `canBreak[2]`, ... `canBreak[len - 1]`, that is, whether all substrings except `s` can be composed of `wordDict`.\n\nThen we can know\n\n```\ncanBreak[len] =  canBreak[1] && wordDict.contains(s[1,len))\n            || canBreak[2] && wordDict.contains(s[2,len))\n            || canBreak[3] && wordDict.contains(s[3,len))   \n            ...\n            || canBreak[len - 1] && wordDict.contains(s[len - 1,len))\n```\n\n`canBreak[len]` represents whether `s` can be composed of `wordDict`.\n\n``` java\npublic boolean wordBreak(String s, List<String> wordDict) {\n    // want to know if canBreak[s.length] is true\n    boolean[] canBreak = new boolean[s.length() + 1];\n\n    canBreak[0] = true;\n\n    for (int i = 1; i <= s.length(); i++) {\n        // if canBreak[i] is true, then must canBreak[j] and substring(j, i) in wordDict\n        for (int j = 0; j < i; j++) {\n            canBreak[i] = canBreak[j] && wordDict.contains(s.substring(j, i));\n\n            if (canBreak[i]) {\n                break;\n            }\n        }\n    }\n\n    return canBreak[s.length()];\n}\n```","tags":["Leetcode - Dynamic Programming"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 134. Gas Station","url":"/Leetcode-134-Gas-Station/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nJust understand this question as the picture below:\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nEach node represents the amount of oil added, and each edge represents the amount of oil consumed. The meaning of the question is to ask us which node we start from and return to that node. We can only go clockwise.\n\n## Solution\nFor this question, we can just use Brute Force.\n\nConsider whether starting from the `0` point, and can return to the `0` point.\n\nConsider whether starting from the `1` point, and can return to the `1` point.\n\nConsider whether starting from the `2` point, and can return to the `2` point.\n\n...\n\nConsider whether starting from the `n` point, and can return to the `n` point.\n\nSince it is a circle, we need to take the remainder when we get the next point.\n\n``` Java\n// already assume gas and cost are non-empty and have same length\n\n// consider starting from each point\nfor (int i = 0; i < gas.length; i++) {\n    int startIndex = i;\n\n    // initial gas\n    int remaining = gas[startIndex];\n\n    // check if remaining can reach next\n    while (remaining - cost[startIndex] > 0) {\n        // minus cost and add gas\n        remaining = remaining - cost[startIndex] + gas[(startIndex + 1) % gas.length];\n\n        startIndex = (startIndex + 1) % gas.length;\n\n        // if returned to i\n        if (startIndex == i) {\n            return i;\n        }\n    }\n}\n\n// looped all nodes, not node is possible\nreturn -1;\n```","tags":["Leetcode - Greedy"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 131. Palindrome Partitioning","url":"/Leetcode-131-Palindrome-Partitioning/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nGive a string, and then cut several times at arbitrary positions to ensure that each substring after cutting is a palindrome string. Output all cutting results that meet the requirements.\n\n### Similar Questions\n* Hard - [132. Palindrome Partitioning II](https://leetcode.com/problems/palindrome-partitioning-ii/)\n\n## Solution\nBreak down big problems into small problems, and use the results of small problems to solve current big problems.\n\nFor this question, give an example.\n\n```\naabb\nFirst consider cutting at the first position, a | abb\nIn this way, we only need to know all the results of abb, and then add a to the head of all results\nAll results of abb are [a b b] [a bb]\nAdd a to the head of each result, which is [a a b b] [a a bb]\n\naabb\nConsider cutting at the second position again, aa | bb\nIn this way, we only need to know all the results of bb, and then add aa to the head of all the results\nAll results of bb are [b b] [bb]\nAdd aa to the head of each result, which is [aa b b] [aa bb]\n\naabb\nThen consider cutting at the third position, aab | b\nBecause aab is not a palindrome string, skip directly\n\naabb\nThen consider cutting at the fourth position, aabb |\nBecause aabb is not a palindrome string, skip directly\n\nIn the end all the results are all added up\n[a a b b] [a a bb] [aa b b] [aa bb]\n```\n\nThe intermediate process to get all the results of `abb`, `aab`, etc., and can be done with recursion. In the case of recursive exit point, all substrings of an empty string are just an empty list.\n\n``` Java\npublic List<List<String>> partition(String s) {\n    return helper(s, 0);\n}\n\nprivate List<List<String>> helper(String s, int start) {\n    // exit recursive\n    if (start == s.length()) {\n        List<List<String>> temp = new ArrayList<>();\n        temp.add(new ArrayList<>());\n\n        return temp;\n    }\n\n    List<List<String>> result = new ArrayList<>();\n    for (int i = start; i < s.length(); i++) {\n        // only continue if left part is palindrome\n        if (isPalindrome(s.substring(start, i + 1))) {\n            String left = s.substring(start, i + 1);\n\n            for (List<String> temp : helper(s, i + 1)) {\n                // append left part in beginning\n                temp.add(0, left);\n                result.add(temp);\n            }\n        }\n    }\n\n    return result;\n}\n\n// helper method to check whether a string is palindrome\nprivate boolean isPalindrome(String s) {\n    int i = 0;\n    int j = s.length() - 1;\n\n    while (i < j) {\n        if (s.charAt(i) != s.charAt(j)) {\n            return false;\n        }\n\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```","tags":["Leetcode - Backtracking"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 130. Surrounded Regions","url":"/Leetcode-130-Surrounded-Regions/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nIt's a little bit like Go, turning the `O` enclosed by `X` into `X`, and the `O` at the boundary will not be enclosed. If `O` and `O` on the boundary are connected, then these `O` are counted as unenclosed, as in the example below.\n\n```\nX X X X X\nO O O X X\nX X X O X\nX O X X X\n```\n\nThe example above only needs to change one `O`.\n\n```\nX X X X X\nO O O X X\nX X X X X\nX O X X X\n```\n\n### Similar Question\n* Medium - {% post_link Leetcode-200-Number-of-Islands '200. Number of Islands' %}\n\n## Solution - DFS\nConsider adjacent `O` as a connected graph, and then start DFS from each `O`.\n\nIf `O` does not reach the boundary after the traversal is completed, we change the current `O` to `X` (meaning this `O` is not connected to a `O` at the boundary, hence enclosed by `X`).\n\nIf the boundary `O` is reached during the traversal, DFS is ended directly, and the current `O` does not need to be changed (because it's connected to a `O` at the boundary).\n\nThen continue to consider the next `O`, continue to do DFS.\n\n## Solution - Union Find\nUnion find data structure: https://en.wikipedia.org/wiki/Disjoint-set_data_structure\n\n> In computer science, union find is a tree-shaped data structure, used to deal with some disjoint sets merge and query problems. There is a union-find algorithm that defines two operations for this data structure:\n* Find: Determine which subset the element belongs to. It can be used to determine whether two elements belong to the same subset.\n* Union: Merging two sub-collections into the same set.\n\nIn order to define these methods more precisely, we need to define how to represent collections. A common strategy is to select a fixed element for each collection, called a representative, to represent the entire collection. Next, `find(x)` returns the representatives of the set to which `x` belongs, and `union()` uses the representatives of the two sets as parameters.\n\nKnowing the union-find, it's easy to find a solution to the problem. We can find that what we do is the problem of classification. In fact, `O` is ultimately divided into two categories, one can be connected to the boundary, and the other can not be connected to the boundary.\n\nWe need to iterate over each `O` node and merge it with the `O` nodes above, below, left and right.\n\nIf the current node is the boundary `O`, merge it with the dummy node (a node outside all nodes). Finally, all `O` nodes and dummy nodes connected to the boundary will be combined into one category. The other `O` nodes that are not connected to boundary `O` are another category.\n\nFinally, we only need to find out whether each `O` node is the same as the dummy node.\n\n``` Java\npublic void solve(char[][] board) {\n    int rowNum = board.length;\n    if (rowNum < 3) {\n        return;\n    }\n\n    int colNum = board[0].length;\n    if (colNum < 3) {\n        return;\n    }\n\n    // at least 3 * 3\n    UnionFind unionFind = new UnionFind(rowNum * colNum + 1);\n\n    // create a dummy node\n    int dummyNode = rowNum * colNum;\n\n    // first loop, connect border with dummy node\n    // or connect all 'o' node\n    for (int i = 0; i < rowNum; i++) {\n        for (int j = 0; j < colNum; j++) {\n            if (board[i][j] == 'O') {\n                // border\n                if (i == 0 || i == rowNum - 1 || j == 0 || j == colNum - 1) {\n                    unionFind.union(dummyNode, i * colNum + j);\n                } else {\n                    // connect up, left, down, right\n                    if (board[i - 1][j] == 'O') {\n                        unionFind.union(i * colNum + j, (i - 1) * colNum + j);\n                    }\n\n                    if (board[i + 1][j] == 'O') {\n                        unionFind.union(i * colNum + j, (i + 1) * colNum + j);\n                    }\n\n                    if (board[i][j - 1] == 'O') {\n                        unionFind.union(i * colNum + j, i * colNum + (j - 1));\n                    }\n\n                    if (board[i][j + 1] == 'O') {\n                        unionFind.union(i * colNum + j, i * colNum + (j + 1));\n                    }\n                }\n            }\n        }\n    }\n\n    // now that everything is classified into 2 classes\n    // second loop to find all node not same as dummy node\n    for (int i = 0; i < rowNum; i++) {\n        for (int j = 0; j < colNum; j++) {\n            if (unionFind.isConnected(i * colNum + j, dummyNode)) {\n                board[i][j] = 'O';\n            } else {\n                board[i][j] = 'X';\n            }\n        }\n    }\n}\n```\n\n``` Java\npublic class UnionFind {\n    // each node point to it's parent, the parent of the root is itself\n    private int[] parent;\n\n    public UnionFind(int size) {\n        parent = new int[size];\n\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n        }\n    }\n\n    // union 2 trees together, change root of node2 to node1\n    public void union(int node1, int node2) {\n        int root1 = findRoot(node1);\n        int root2 = findRoot(node2);\n\n        if (root1 != root2) {\n            parent[root2] = root1;\n        }\n    }\n\n    public boolean isConnected(int p, int q) {\n        return findRoot(p) == findRoot(q);\n    }\n\n    // find the root of the node\n    public int findRoot(int node) {\n        // loop until find parent is itself\n        while (parent[node] != node) {\n            parent[node] = parent[parent[node]];\n            node = parent[node];\n        }\n\n        return node;\n    }\n}\n```","tags":["Leetcode - Depth First Search","Leetcode - Breadth First Search","Leetcode - Union Find"],"categories":["Data Structure and Algorithms"]},{"title":"Compare HashSet and TreeSet","url":"/Compare-HashSet-and-TreeSet/","content":"Last time we talked about `TreeSet` in Java: {% post_link Java-TreeSet 'Java TreeSet' %}. This blog is just to provide a quick summary of the comparison between `HashSet` and `TreeSet`.\n\n## Characteristic of HashSet\n* The order of the elements cannot be guaranteed. The order stored may be different from the order of addition and may change later\n* `HashSet` is NOT synchronized. If multiple threads access a `HashSet` at the same time and threads modify the `HashSet` elements, the code must be used to ensure its synchronization\n* The elements of `HashSet` can be null\n\n## Characteristic of TreeSet\n* Elements in `TreeSet` is ordered. After the element is inserted, it will be arranged according to a specified order\n* `TreeSet` is NOT synchronized.\n* The elements of `TreeSet` can't be null\n\n## Differences\n* `HashSet` is implemented by hash table. The data in `HashSet` is unordered and can be put into null, but only one null is allowed. \n* `TreeSet` is implemented by binary tree. The data in `Treeset` is sorted automatically, and null values are not allowed.\n* The values in `TreeSet` and `HashSet` can not be repeated, just like the only constraint in the database.\n* `HashSet` requires that the objects placed must implement the `HashCode()` method. The objects placed are identified by the hash code. \n  * The `String` objects with the same content have the same hashcode, so the content cannot be repeated. But objects of the same class can be put into different instances.","tags":["Java Collections"],"categories":["Java"]},{"title":"Leetcode 129. Sum Root to Leaf Numbers","url":"/Leetcode-129-Sum-Root-to-Leaf-Numbers/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven a binary tree, the path from the root node to the leaf node forms a number. Calculates the sum of all numbers.\n\n### Similar Question\n* Easy - [112. Path Sum](https://leetcode.com/problems/path-sum/)\n* Hard - [124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/)\n* Medium - [988. Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/)\n\n## Solution\nWe need to traverse the binary tree, and record the sum of the current path during the traversal process. When it comes to traversal, it is nothing more than `BFS` and `DFS`. If `BFS` is performed, we need to maintain the sum of multiple paths during the process, so we choose `DFS`.\n\nWhen it comes to `DFS`, we can use recursion, or use the stack.\n\nWhen it comes to recursion, we can use both backtracking and divide and conquer.\n\nLet's look at the backtracking solution.\n\nThe idea of backtracking is to keep traversing in depth until a solution is obtained and record the current solution. Then return to the previous state to continue the depth traversal.\n\nSo we need to define a function to get this solution.\n\n``` Java\nprivate void dfs(TreeNode node, int tempSum)\n```\n\nThis function means that when traversing from the `root` node to the `node`, the cumulative sum of the paths is `cursum`.\n\nHere we use a global variable `result` to store the sum of each path.\n\nSo the exit of backtracking is that when we reach the leaf node, save the current accumulated path sum.\n\n``` java\nif (node.left == null && node.right == null) {\n    result += tempSum;\n    return;\n}\n```\n\nThen just try the left and right subtrees separately.\n\n``` java\nint result = 0;\n\npublic int sumNumbers(TreeNode root) {\n    if (root == null) {\n        return 0;\n    }\n\n    dfs(root, root.val);\n\n    return result;\n}\n\nprivate void dfs(TreeNode node, int tempSum) {\n    // reach leaf node\n    if (node.left == null && node.right == null) {\n        result += tempSum;\n    }\n\n    // try left tree\n    if (node.left != null) {\n        dfs(node.left, tempSum * 10 + node.left.val);\n    }\n\n    // try right tree\n    if (node.right != null) {\n        dfs(node.right, tempSum * 10 + node.right.val);\n    }\n}\n```","tags":["Leetcode - Tree","Leetcode - Depth First Search"],"categories":["Data Structure and Algorithms"]},{"title":"Java TreeSet","url":"/Java-TreeSet/","content":"The `TreeSet` in Java is a subclass of `Set`. The `TreeSet` collection is used to sort the object elements, and it can also guarantee the uniqueness of the elements.\n\n`TreeSet` is an implementation class of `SortedSet` interface. `SortedSet` can ensure that the collection elements are in sorted state.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nThe underlying structure of `TreeSet` is a `black red tree`. Every new element (except the first one) will be compared with the last inserted element and arrange them according to the structure of the binary tree.\n\nThere are two comparative methods in `TreeSet`. They are `Comparable` interface and `Comparator` interface.\n\n## Using Comparable\nUsing `Comparable` interface requires Object to implement `Comparable` interface. The `Comparable` interface requres the implementation of `compareTo(Object object)` method. `TreeSet` will call the `compareTo(Object object)` method of elements to compare the relationship between the elements, and then arranges the collection elements in ascending order. \n\nIf the Object doesn't implement `Comparable` interface, a `ClassCastException` will be thrown.\n\nSome common classes in Java have implemented the `Comparable` interface: `BigDecimal`, `BigInteger`, `Character`, `Boolean`, `String`, `Date`, `Time`, etc.\n\nExample:\n\n``` java\npublic static void main(String[] args) {\n    TreeSet<Person> ts = new TreeSet<>();\n    \n    ts.add(new Person(\"Person A\", 23));\n    ts.add(new Person(\"Person B\", 44));\n    ts.add(new Person(\"Person C\", 13));\n    ts.add(new Person(\"Person D\", 43));\n    ts.add(new Person(\"Person E\", 33));\n        \n    System.out.println(ts);\n}\n\npublic class Person implements Comparable<Person> {\n    private String name;\n    private int age;\n\n    // Compare by age\n    public int compareTo(Person o) {\n        return this.age - o.age;      \n    }\n}\n\n// Output\n// [\n//  Person{name='Person C', age=13},\n//  Person{name='Person A', age=23},\n//  Person{name='Person E', age=33},\n//  Person{name='Person D', age=43},\n//  Person{name='Person B', age=44}\n// ]\n```\n\nWhen the `compareTo` method returns 0, the two elements are considered to be equal. Therefore, when we need to put an object into the `TreeSet` and rewrite the `equals()` method of this class, we should ensure that when the `equals()` method returns true, the `compareTo` method returns `0`.\n\nAfter an element have been added to the `TreeSet`, it's not recommended to modify the value of the elements. It is easy to cause some errors. Example:\n\n``` Java\npublic static void main(String[] args) {\n    TreeSet<Person> ts = new TreeSet<>();\n\n    ts.add(new Person(\"Person A\", 23));\n    ts.add(new Person(\"Person B\", 44));\n    ts.add(new Person(\"Person C\", 13));\n    ts.add(new Person(\"Person D\", 43));\n    ts.add(new Person(\"Person E\", 33));\n\n    ts.forEach(obj -> System.out.println(\"Before modification: \" + obj.getName() + \" \" + obj.getAge()));\n\n    Person person = ts.first();\n    person.setAge(80);\n\n    person = ts.last();\n    person.setAge(5);\n\n    ts.forEach(obj -> System.out.println(\"After modification: \" + obj.getName() + \" \" + obj.getAge()));\n}\n```\n\n`TreeSet` will not be re-sorted after we modify the values. Also, if we make the elements equal after the modification, the `TreeSet` will not be re-sorted as well. At this time, if we want to delete the modified element, it will fail, and the element equal to the modified element will also be deleted. However, we can delete elements that have not changed normally.\n\n## Using Comparator\nWe can also define a comparator to implement the `Comparator` interface, rewrite the `compare` method, and pass the comparator into the `TreeSet` constructor.\n\nExample:\n\n``` Java\npublic class ComparatorDemo {\n    public static void main(String[] args) {\n        TreeSet<PersonB> ts = new TreeSet<>(new Comparator<PersonB>() {\n            @Override\n            public int compare(PersonB o1, PersonB o2) {\n                return Integer.compare(o1.age, o2.age);\n            }\n        });\n\n        ts.add(new PersonB( 23));\n        ts.add(new PersonB(44));\n        ts.add(new PersonB(13));\n\n        ts.forEach(System.out::println);\n    }\n\n    static class PersonB {\n        int age;\n\n        public PersonB(int age) {\n            this.age = age;\n        }\n\n        @Override\n        public String toString() {\n            return \"Age: \" + age;\n        }\n    }\n}\n```\n\n## Conclusion\n1. Feature\n  * `TreeSet` is used for sorting, you can specify an order. After the object is stored, it will be arranged in the specified order.\n2. Usage\n  * Comparable\n    * Call the `compareTo()` method of the object and compare it with the objects in the collection\n    * Store the elements according to the result returned by the `compareTo()` method\n  * Comparator\n    * A `Comparator` can be specified when creating a `TreeSet`\n    * If a subclass object of `Comparator` is passed in, the `TreeSet` will be sorted according to the order specified by the comparator\n    * The `add()` method will automatically call the `compare()` method of the `Comparator` interface to sort\n    * The called object is the first parameter of the `compare()` method, and the object in the collection is the second parameter of the `compare()` method\n  * Difference\n    * If the `TreeSet` constructor gets nothing, it will by default use `Comparable` (`ClassCastException` is thrown if the object doesn't implement `Comparable`)\n    * If `TreeSet` constructor gets a `Comparator`, it will be given priority to `Comparator`","tags":["Java Collections"],"categories":["Java"]},{"title":"Leetcode 120. Triangle","url":"/Leetcode-120-Triangle/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nFrom current layer can only choose two adjacent elements to walk down. For example, the third layer of `5`, we can only choose the fourth layer of `1` and `8`, starting from the top. Take a path to the bottom with the smallest sum.\n\n## Solution\nWe can construct the result from top to down, get the possible minimum at a specific positon. Lastly the minimum in the last is the answer we want to get.\n\nThere are two options to get to the current position. Choose a smaller one and add the number at the current position.\n\nThe point to note is that the left and right borders need to be considered separately, because there is only one position to reach the left and right borders.\n\nWe are updating layer by layer, and updating the current layer only requires the information of the previous layer, so we do not need a two-dimensional array, only a one-dimensional array.\n\nE.g\n```\n    [2],\n   [3, 4],\n  [6, 5, 7],\n[4, 1, 8, 3]\n     \nUpdate 2-nd layer:\n     [2],\n   [5, 6],\n  [6, 5, 7],\n[4, 1, 8, 3]   \n\nUpdate 3-rd layer:\n      [2],\n     [5, 6],\n  [11, 10, 13],\n[4,  1,   8,  3] \n\nUpdate last layer:\n      [2],\n     [5, 6],\n  [11, 10, 13],\n[15, 11, 18, 16]   \n```\n\n``` java\npublic int minimumTotal(List<List<Integer>> triangle) {\n    List<Integer> previousRow = triangle.get(0);\n\n    // loop every row\n    for (int row = 1; row < triangle.size(); row++) {\n        List<Integer> temp = new ArrayList<>();\n\n        // loop elements in the row\n        for (int i = 0; i < triangle.get(row).size(); i++) {\n            // current element\n            int elementCurrent = triangle.get(row).get(i);\n\n            // first or last element, add current one with previous row adjacent elements\n            if (i == 0) {\n                temp.add(elementCurrent + previousRow.get(i));\n            } else if (i == triangle.get(row).size() - 1) {\n                temp.add(elementCurrent + previousRow.get(previousRow.size() - 1));\n            } else {\n                temp.add(Math.min(elementCurrent + previousRow.get(i - 1), elementCurrent + previousRow.get(i)));\n            }\n        }\n\n        previousRow.clear();\n        previousRow.addAll(temp);\n    }\n\n    // now previous row is the last row\n    // sort and find the minimum one\n    Collections.sort(previousRow);\n    return previousRow.get(0);\n}\n```","tags":["Leetcode - Dynamic Programming","Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Java CompletableFuture","url":"/Java-CompletableFuture/","content":"In modern software development, system functions are becoming more and more complex, and the method of managing complexity is to divide and conquer. Many functions of the system may be divided into small services, providing Web APIs for external development, deployment, and maintenance. For example, in an e-commerce system, there may be product services, order services, user services, recommendation services, preferential services, search services, etc. When displaying a page externally, multiple services may be called. There may be certain dependencies between calls, for example, to display a product page, you need to call the product service. You may also need to call the recommendation service to obtain other recommendations related to the product, and you may need to call the discount service to obtain the promotional offers related to the product. In order to call the preferential service, you may need to call the user service to obtain the user's membership level.\n\nIn addition, modern software often depends on many third-party services, such as map services, SMS services, weather services, exchange rate services, etc. When implementing a specific function, you may need to access multiple such services, and there may be dependencies.\n\nIn order to improve performance and make full use of system resources, these calls to external services should generally be `asynchronous` and as `concurrent` as possible. Asynchronous task execution service, using `ExecutorService` can easily submit a single independent asynchronous task, you can easily obtain the result of the asynchronous task through the `Future` interface when needed, but for multiple asynchronous tasks, especially with certain dependencies, this support is not enough.\n\nSo, there comes `CompletableFuture`, which is a concrete class that implements two interfaces, one is `Future` and the other is `CompletionStage`. `Future` represents the result of an asynchronous task, and `CompletionStage` literally means the completion stage, multiple `CompletionStage` can be pipelined in combination, for one of the `CompletionStage`, it has a calculation task, but it may need to wait for one or more other stages to complete before it can start. After it is completed, it may trigger other stages to start running. `CompletionStage` provides a large number of methods. Using them, you can easily respond to task events, build a task pipeline, and implement combined asynchronous programming. How to use it? Below we will explain step by step, `CompletableFuture` is also a `Future`, let us first look at the similarities with `Future`.\n\n`Future` is a class added by Java5 to describe the result of an asynchronous calculation. You can use the `isDone()` method to check whether the calculation is complete, or use `get()` to block the calling thread until the calculation is completed and return the result, or you can use the `cancel()` method to stop the execution of the task.\n\n``` Java\npublic class BasicFuture {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService es = Executors.newFixedThreadPool(10);\n        Future<Integer> f = es.submit(() -> {\n            // long running asynchronous task\n            // ...\n            // return sth\n            return 100;\n        });\n        f.get();\n    }\n}\n```\n\n`Future` and related methods provide the ability to execute tasks asynchronously, but it is inconvenient to obtain results, and the task results can only be obtained by blocking or polling. The blocking method is contrary to the asynchronous programming we understand, and polling consumes unnecessary CPU resources. Moreover, the calculation result cannot be obtained in time. Why can't the observer design mode be used to notify the listener in time when the calculation result is completed?\n\nIn Java 8, a new class with about 50 methods has been added: [CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html), which provides a very powerful extension of `Future`, which can help us simplify the complexity of asynchronous programming, provides the ability of functional programming, and the way to deal with the calculation results, and provides a method to convert and combine `CompletableFuture`.\n\nLet's take a look at its function below.\n\n``` Java\npublic class CompletableFutureSimple {\n    public static void main(String[] args) {\n        CompletableFuture<Double> futurePrice = getPriceAsync();\n\n        //do anything you want, current thread is not blocked\n        System.out.println(111);\n\n        // task complete, call the callback without block subsequent operations\n        futurePrice.whenComplete((aDouble, throwable) -> {\n            System.out.println(aDouble);\n            //do something else\n        });\n\n        System.out.println(222);\n    }\n\n    static CompletableFuture<Double> getPriceAsync() {\n        CompletableFuture<Double> futurePrice = new CompletableFuture<>();\n\n        new Thread(() -> {\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            futurePrice.complete(23.55);\n        }).start();\n\n        return futurePrice;\n    }\n}\n```\n\n`getPriceAsync()` is an asynchronous method. It returns a `futurePrice` immediately after the call. It is simulated as a time-consuming operation with `Thread.sleep(5000)`. After the thread is executed, it sets `futurePrice` to the completion state and gives the result.\n\n`CompletableFuture`'s `whenComplete()` is also asynchronous, so we can see the output as follows:\n\n```\n111\n222\n23.55\n```\n\n## Completion of calculations\nThe `CompletableFuture` class implements the [CompletionStage](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html) and [Future](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html) interfaces, so you can still get the results by blocking or polling as before, although this method is not recommended.\n\n``` Java\npublic T get()\npublic T get(long timeout, TimeUnit unit)\npublic T getNow(T valueIfAbsent)\npublic T join()\n```\n\n`getNow()` is a bit special. If the result has been calculated, it will return the result or throw an exception, otherwise return the given `valueIfAbsent` value.\n\n`join()` returns the result of the calculation or throws an unchecked exception(`CompletionException`), which is slightly different from `get()`'s handling of the thrown exception.\n\n## Create CompletableFuture\n`CompletableFuture.completedFuture()` is a static helper method used to return an already calculated `CompletableFuture`.\n\n``` Java\npublic static <U> CompletableFuture<U> completedFuture(U value)\n```\n\nThe following four static methods are used to create a `CompletableFuture` object for an asynchronously executed code:\n\n``` Java\npublic static CompletableFuture<Void>   runAsync(Runnable runnable)\npublic static CompletableFuture<Void>   runAsync(Runnable runnable, Executor executor)\npublic static <U> CompletableFuture<U>  supplyAsync(Supplier<U> supplier)\npublic static <U> CompletableFuture<U>  supplyAsync(Supplier<U> supplier, Executor executor)\n```\n\nMethods that end in `Async` and do not specify `Executor` will use `ForkJoinPool.commonPool()` as its thread pool to execute asynchronous code.\n\nThe `runAsync()` method is also easy to understand. It takes the `Runnable` functional interface type as a parameter, so the `CompletableFuture` calculation result is empty.\n\nThe `supplyAsync` method takes the `Supplier<U>` functional interface type as a parameter, and the `CompletableFuture` calculation result type is `U`.\n\nBecause the parameter types of methods are all functional interfaces, `lambda` expressions can be used to implement asynchronous tasks, such as:\n\n``` java\nCompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n    // long running task\n    return \"·00\";\n});\n```\n\n## Processing when the calculation is completed\nWhen the calculation of `CompletableFuture` is completed, or when an exception is thrown, we can execute a specific `Action`. The main methods are as follows:\n\n``` java\npublic CompletableFuture<T> whenComplete(BiConsumer<? super T,? super Throwable> action)\npublic CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action)\npublic CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action, Executor executor)\npublic CompletableFuture<T> exceptionally(Function<Throwable,? extends T> fn)\npublic CompletableFuture<T> whenComplete(BiConsumer<? super T,? super Throwable> action)\npublic CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action)\npublic CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action, Executor executor)\npublic CompletableFuture<T> exceptionally(Function<Throwable,? extends T> fn)\n```\n\nWe can see that the type of `Action` is `BiConsumer<? Super T ,? super Throwable>`, which can handle normal calculation results or abnormal exceptions.\n\nThe methods that do not end with `Async` means that `Action` uses the same thread to execute, and `Async` may use other threads to execute (if the same thread pool is used, it may also be selected for execution by the same thread).\n\nNote that these methods will return `CompletableFuture`. When the `Action` is executed, its result will return to the original `CompletableFuture` calculation result or return an exception.\n\nThe `exceptionally()` method returns a new `CompletableFuture`. When the original `CompletableFuture` throws an exception, it will trigger the calculation of the `CompletableFuture` and call the function to calculate the value, otherwise if the original `CompletableFuture` is calculated normally, the new `CompletableFuture` is also calculated, The value is the same as the calculated value of the original `CompletableFuture`. So, this `exceptionally()` method is used to handle abnormal situations.\n\nAlthough the following set of methods also returns a `CompletableFuture` object, the value of the object is different from the value calculated by the original `CompletableFuture`. When the original `CompletableFuture` value calculation is completed or an exception is thrown, the `CompletableFuture` object calculation is triggered, and the result is calculated by the `BiFunction` parameter. Therefore, this group of methods has both functions of `whenComplete` and `conversion`.\n\n``` java\npublic <U> CompletableFuture<U> handle(BiFunction<? super T,Throwable,? extends U> fn)\npublic <U> CompletableFuture<U> handleAsync(BiFunction<? super T,Throwable,? extends U> fn)\npublic <U> CompletableFuture<U> handleAsync(BiFunction<? super T,Throwable,? extends U> fn, Executor executor)\n```\n\nSimilarly, the method that does not end with `Async` is calculated by the original thread, and the method that ends with `Async` is run by the default thread pool `ForkJoinPool.commonPool()` or the specified thread pool executor.\n\n## Conversion\n`CompletableFuture` can be used as a `monad` and `functor`. Due to the implementation of the callback style, we do not have to block the calling thread just waiting for a calculation to complete, but rather tell `CompletableFuture` to perform a certain function when the calculation is completed. And we can also chain these operations together, or combine `CompletableFuture`.\n\n``` Java\npublic <U> CompletableFuture<U> thenApply(Function<? super T,? extends U> fn)\npublic <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn)\npublic <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn, Executor executor)\n```\n\nThe function of these methods is to pass the result to the function `fn` after the original `CompletableFuture` is calculated, and use the result of `fn` as the new `CompletableFuture` calculation result. Therefore, its function is equivalent to converting `CompletableFuture<T>` into `CompletableFuture<U>`.\n\nThe difference between these three functions is the same as described above. The method that does not end with `Async` is calculated by the original thread, and the method that ends with `Async` is run by the default thread pool `ForkJoinPool.commonPool()` or the specified thread pool `executor`. Java's `CompletableFuture` class always follows this principle.\n\nExample:\n``` java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 100);\n\nCompletableFuture<String> conversion = future.thenApplyAsync(i -> i * 10).thenApply(Object::toString);\n\nSystem.out.println(conversion.get());\n```\n\nIt should be noted that these conversions are not executed immediately and will not block, but will continue to execute after the previous stage is completed.\n\nThe difference between them and the `handle()` method is that the `handle()` method will handle normal calculated values and exceptions, so it can shield exceptions and prevent them from being thrown. The `thenApply()` method is only used to handle normal values, so it will be thrown once there is an exception.\n\n## Pure consumption (execution Action)\nThe above methods are that when the calculation is completed, a new calculation result(`thenApply()`, `handle()`) will be generated, or the same calculation result is returned `whenComplete()`. `CompletableFuture` also provides a method of processing the result, only execute `Action` on the result, and not return new calculated value, so the calculated value is `Void`:\n\n``` Java\npublic CompletableFuture<Void> thenAccept(Consumer<? super T> action)\npublic CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action)\npublic CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action, Executor executor)\n```\n\nIt is clear by looking at its parameter types. They are functional interface consumers. This interface has only inputs and no return values.\n\n``` Java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    return 100;\n});\n\nCompletableFuture<Void> f =  future.thenAccept(System.out::println);\n\nSystem.out.println(f.get());\n```\n\n`thenAcceptBoth()` and related methods provide similar functions. When the two `CompletionStage` complete the calculation normally, the provided action will be executed, which is used to combine another asynchronous result.\n\n`runAfterBoth()` is to execute a `Runnable` when both `CompletionStage` finishes the calculation normally. This `Runnable` does not use the calculation result.\n\n``` Java\npublic <U> CompletableFuture<Void> thenAcceptBoth(CompletionStage<? extends U> other, BiConsumer<? super T,? super U> action)\npublic <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super T,? super U> action)\npublic <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super T,? super U> action, Executor executor)\npublic     CompletableFuture<Void> runAfterBoth(CompletionStage<?> other,  Runnable action)\n```\n\nExample:\n\n``` java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 100);\n\nCompletableFuture<Void> f =  future.thenAcceptBoth(CompletableFuture.completedFuture(10), (x, y) -> System.out.println(x * y));\n\nSystem.out.println(f.get());  // null\n```\n\nMore thoroughly, the following set of methods will execute a `Runnable` when the calculation is complete. Unlike `thenAccept()`, `Runnable` does not use the results of `CompletableFuture` calculations.\n\n``` java\npublic CompletableFuture<Void> thenRun(Runnable action)\npublic CompletableFuture<Void> thenRunAsync(Runnable action)\npublic CompletableFuture<Void> thenRunAsync(Runnable action, Executor executor)\n```\n\nThe result of the previous `CompletableFuture` calculation is ignored, and this method returns an object of type `CompletableFuture<Void>`.\n\n``` java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 100);\nCompletableFuture<Void> f =  future.thenRun(() -> System.out.println(\"finished\"));\nSystem.out.println(f.get());  // null\n```\n\n> A simple way to memorize the methods based on the type of parameters. `Runnable` type parameters will ignore the calculation results. `Consumer` is the pure consumption calculation result (not return value). `BiConsumer` will combine another `CompletionStage`. `Function` will convert the calculation result. `BiFunction` will combine another `CompletionStage` calculation result to perform conversion.\n\n## Compose\n``` java\npublic <U> CompletableFuture<U> thenCompose(Function<? super T,? extends CompletionStage<U>> fn)\npublic <U> CompletableFuture<U> thenComposeAsync(Function<? super T,? extends CompletionStage<U>> fn)\npublic <U> CompletableFuture<U> thenComposeAsync(Function<? super T,? extends CompletionStage<U>> fn, Executor executor)\n```\n\nThis set of methods accepts a `Function` as a parameter. The input of this `Function` is the current `CompletableFuture` calculation value, and the returned result will be a new `CompletableFuture`, which will combine the original `CompletableFuture` and the `CompletableFuture` returned by the function.\n\nRemember, the objects returned by `thenCompose()` are not the objects returned by the function `fn`. If the original `CompletableFuture` has not been calculated, it will generate a new combined `CompletableFuture`.\n\n``` java\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 100);\n\nCompletableFuture<String> f =  future.thenCompose( i -> CompletableFuture.supplyAsync(() -> (i * 10) + \"\"));\n        \nSystem.out.println(f.get()); //1000\n```\n\nThe following set of methods `thenCombine()` is used to compound the results of another `CompletionStage`.\n\nThe two `CompletionStage` are executed in parallel, and there is no order of dependency between them. The other does not wait for the previous `CompletableFuture` to complete before executing.\n\n``` java\npublic <U,V> CompletableFuture<V> thenCombine(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn)\npublic <U,V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn)\npublic <U,V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn, Executor executor)\n```\n\nIn fact, in terms of functionality, their function is more similar to `thenAcceptBoth()`, except that `thenAcceptBoth()` is pure consumption, its function parameter has no return value, and `thenCombine()`'s function parameter `fn` has a return value.\n\n## Either\n`thenAcceptBoth()` and `runAfterBoth()` are calculated when both `CompletableFutures` are completed, and the method we want to understand below is when any `CompletableFuture` is calculated.\n\n``` java\npublic CompletableFuture<Void> acceptEither(CompletionStage<? extends T> other, Consumer<? super T> action)\npublic CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action)\npublic CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action, Executor executor)\npublic <U> CompletableFuture<U> applyToEither(CompletionStage<? extends T> other, Function<? super T,U> fn)\npublic <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T,U> fn)\npublic <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T,U> fn, Executor executor)\n```\n\nThe `acceptEither()` method is that when any `CompletionStage` is completed, the action consumer will be executed. This method returns `CompletableFuture<Void>`\n\nThe `applyToEither()` method is when any `CompletionStage` is completed, `fn` will be executed, and its return value will be used as the calculation result of the new `CompletableFuture<U>`.\n\nThe following example sometimes outputs 100 and sometimes 200. Which `Future` is completed first will be calculated based on its result.\n\n``` java\nRandom rand = new Random();\n\nCompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return 100;\n});\n\nCompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> {\n    try {\n        Thread.sleep(10000 + rand.nextInt(1000));\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return 200;\n});\n\nCompletableFuture<String> f =  future.applyToEither(future2,i -> i.toString());\n```\n\n## CompletableFuture exception handling\nIf an exception occurs before setting `CompletableFuture.complete(value)`, then `get()` or other callback functions like `whenComplete()` will wait indefinitely.\n\nOne method is to give a timeout when calling `get(timeout)`, and get a `TimeoutException` if no result is obtained within the specified time. Another way is to spread the exception through `completeExceptionally(ex)` in the thread\n\n## Helper methods allOf() and anyOf()\n``` java\npublic static CompletableFuture<Void>   allOf(CompletableFuture<?>... cfs)\npublic static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs)\n```\n\nThe `allOf()` method is to perform calculations after all `CompletableFuture` have been executed.\n\nThe `anyOf()` method is to execute a calculation after any `CompletableFuture` is executed, and the calculation result is the same.\n\n`anyOf()` and `applyToEither()` are different. `anyOf()` accepts any number of `CompletableFuture` but `applyToEither()` only has two `CompletableFuture`. The calculation result of the return value of `anyOf()` is one of the `CompletableFuture` calculation parameters. The calculation result of the return value of `applyToEither()` is processed by `fn`.\n\n## References\n1. http://colobu.com/2016/02/29/Java-CompletableFuture/\n2. http://www.cnblogs.com/swiftma/p/7424185.html\n3. https://unmi.cc/java-8-completablefuture-brief-touch/","categories":["Java"]},{"title":"Leetcode 114. Flatten Binary Tree to Linked List","url":"/Leetcode-114-Flatten-Binary-Tree-to-Linked-List/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nExpand a binary tree into a linked list.\n\n### Similar Question\n* Medium - [430. Flatten a Multilevel Doubly Linked List](https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/)\n\n## Solution\nIt can be found that the order of flatten is actually the pre-order traversal of the binary tree. So the problem is actually to convert the binary tree through the right pointer to form a linked list. \n\nE.g. given:\n```\n    1\n   / \\\n  2   5\n / \\   \\\n3   4   6\n```\n\nTry to get:\n```\n1 -> 2 -> 3 -> 4 -> 5 -> 6\n```\n\nOnce we have this pre-order list, we can tranverse through it. Each time a node is traversed, the right pointer of the previous node is updated to the current node.\n\nThe pre-order list is `1 2 3 4 5 6`.\n\nTraverse to `2` and point the right pointer of `1` to `2`. `1-> 2` `3 4 5 6`.\n\nTraverse to `3` and point the right pointer of `2` to `3`. `1-> 2-> 3` `4 5 6`.\n\n...\n\nBecause we saved the right child with the list, there is no need to worry about the right child being lost.\n\nCode:\n``` Java\npublic void flatten(TreeNode root) {\n    // store the pre-order list\n    Queue<Integer> preOrder = new LinkedList<>();\n\n    // get the preorder list of the tree\n    preOrder(root, preOrder);\n\n    TreeNode current = root;\n    preOrder.poll();\n\n    // traverse the list\n    while (!preOrder.isEmpty()) {\n        TreeNode newNode = new TreeNode(preOrder.poll());\n\n        // left node always null\n        current.left = null;\n        current.right = newNode;\n\n        current = newNode;\n    }\n}\n\n// pre order traverse\nprivate void preOrder(TreeNode root, Queue<Integer> preOrder) {\n    if (root == null) {\n        return;\n    }\n\n    preOrder.offer(root.val);\n    preOrder(root.left, preOrder);\n    preOrder(root.right, preOrder);\n}\n```","tags":["Leetcode - Tree","Leetcode - Depth First Search"],"categories":["Data Structure and Algorithms"]},{"title":"Java final and static keyword","url":"/Java-final-and-static-keyword/","content":"## Final keyword\nAccording to the context of the program, the Java keyword `final` has the meaning of \"this cannot be changed\" or \"end state\", which can be used for non-abstract classes, non-abstract class member methods and variables. You may need to prevent change for two reasons: design or efficiency.\n\n*  Final class **<font color=\"orange\">cannot be inherited and has no subclasses. The methods in the final class are final by default</font>**.\n* Final methods **<font color=\"orange\">cannot be overridden by subclass methods, but can be inherited</font>**.\n* Final member variable represents a constant and **<font color=\"orange\">can only be assigned once, and the value will not change after the assignment</font>**.\n* Final cannot be used to the construction method.\n\nNote: The private member methods of the parent class cannot be overridden by subclass methods, so private type methods are final by default.\n\nIn general, final is used to **<font color=\"orange\">declare attributes, methods, and classes, respectively, indicating that attributes are immutable, methods cannot be overridden, and classes cannot be inherited</font>**.\n\n### Apply final to a class\nWhen a class is modified with final, **<font color=\"orange\">it indicates that this class cannot be inherited. The member methods of the final class have no chance to be overwritten, so the default is final</font>**. That means this class is a leaf class in the inheritance tree, and the design of this class has been considered perfect without modification or expansion. For member variabbles of the final class, you can define it as final or not final. As for the method, it naturally becomes final. When using final to modify a class, you should choose carefully, unless this class will not be used for inheritance in the future or for safety reasons, try not to design the class as a final class.\n\n**<font color=\"orange\">The class that most often modified with final is the utility class</font>**. There are a lot of utility classes used in Java projects, such as JDK's own utility class `java.lang.Math`, `java.util.Collections`, etc. The methods and properties of the utility class are static and can be accessed without generating an instance. The utility class has been well designed and does not need to be inherited. Since it does not want to be initialized or inherited, JDK has dealt with this. Let's take a look at the code of `java.lang.Math`:\n\n``` Java\npublic final class Math {   \n    private  Math() { }  \n    public static final double E = 2.7182818284590452354;\n    public static final double PI = 3.14159265358979323846;\n\n    public static double sin(double a ) { \n        return StrictMath.sin(a);\n    }   \n}\n```\n\n### Apply final to a method\nThere are two reasons for using the final method:\n1. To show that **<font color=\"orange\">the functions provided by this method have met the requirements, do not need to be extended, and do not allow any subclasses that inherit from this class to override this method, but the inherited class can still use this method directly</font>**. \n2. Efficiency. **<font color=\"orange\">When the compiler encounters the call to the final method, it will convert all calls to this method into an inline call mechanism, greatly improving execution efficiency</font>**. However, when the method body is very large, or when the method is called in multiple places, the calling code will quickly expand, which may affect efficiency, so final should be used to define the method with caution. Only set the method to final if you want to explicitly prohibit the method from being overridden in subclasses.\n\nNote: The private method of the class will be implicitly designated as the final method.\n\n### Apply final to a variable\nDinal is used the most to modify variables . For a final variable, if the variable is of primitive data type, its value cannot be changed once it is initialized; if it is a variable of reference type, it cannot point to another object after it is initialized. \n\n**<font color=\"orange\">The initialization of variables can be in two places, one is its definition, and the other is in the constructor</font>**. \n\nThere are three types of final modified variables: static variables, instance variables and local variables, which represent three types of constants. When the final variable is defined, you can declare it first without giving an initial value. This variable is also called final blank. In any case, **<font color=\"orange\">the compiler ensures that the blank final must be initialized before use</font>**. With this guarantee, the final data member can be implemented differently according to the object, but has the characteristics of keeping it constant.\n\nAnother usage is to define the parameters in the method as final. **<font color=\"orange\">For basic type variables, this has no practical meaning, because the basic type variables are passed by value when calling the method</font>**. When you change this parameter variable in the method, the formal parameters are changed, and the actual parameters are not affected. However, **<font color=\"orange\">it is very practical for object variables, because object variables are passed by reference</font>**. Your modification of the object variable in the method will also affect the actual parameter object. When you restrict the object variable that cannot be changed as a parameter in the method, be sure to explicitly use final to declare it.\n\n## Static keyword\n`Static` means \"global\" or \"static\", used to modify member variables and member methods, and can also form static code blocks, but there is no concept of global variables in the Java language. \n\n**<font color=\"orange\">Member variables and member methods modified by static are independent of any objects of this class</font>**. In other words, it does not depend on a specific instance of the class and is **<font color=\"orange\">shared by all instances of the class</font>**. As long as the class is loaded, the Java virtual machine can find them in the method area of the runtime data area based on the class name. Therefore, the static object can be accessed before any object of the class to which it belongs is created without reference to any object. There are three types of static members in a class: static member variables, static methods, and static code blocks. They all have the following characteristics:\n* When the class is loaded, create and initialize or execute code;\n* They have only one copy for a class;\n* All instances of the class can access them.\n\n**Static member variable**: it will be created and initialized after the class is loaded. Because of its uniqueness, it is usually used for the data record of the object, for example, reference storage in singleton mode.\n\n**Static method**: it can be accessed by the object or directly by the class name.\n\n**Static code block**: which is decorated with static code surrounded by curly brackets \"{...}\". These codes can use static member variables and methods, which are also called when the class is loaded.\n\n### Static variables\nThere are two types of member variables according to whether they are static: one is a variable modified by static, called `static variable` or `class variable`; the other is a variable that is not modified by static, called `instance variable`. The difference between the two is that **<font color=\"orange\">for static variables, they have only one copy in memory (saving memory), the JVM only allocates memory for statics once, and completes the memory allocation of static variables during the class loading process</font>**, which can be accessed directly by the class name (convenient), Of course it can also be accessed through objects (but this is not recommended). For instance variables, if an instance is created, the instance variable will be allocated once, and **<font color=\"orange\">the instance variable can have multiple copies in memory without affecting each other (flexible)</font>**.\n\n### Static method\nStatic methods can be called directly by the class name, any instance can be called, so **<font color=\"orange\">the static method can not use this and super keywords, can not directly access the instance variables and instance methods of the class (that is, non-static member variables and members method)</font>**. Static methods can only access the static member variables and static member methods of the class because instance members are associated with specific objects.\n\nBecause the static method is independent of any instance, the static method must be implemented. It can not be an abstract abstract.\n\n### Static code block\nThe static code block is a static statement block in the class that is independent of the class members. There can be more than one, and the position can be placed anywhere. It is not in any method body. These static code blocks will be executed when the JVM loads the class. If there are multiple static code blocks, the JVM will execute them in the order in which they appear in the class, and each code block will only be executed once.\n\nSee details about static code block: {% post_link Java-Static-code-block 'Java Static code block' %}.\n\n## What does putting static and final together mean\nWhen static and final modifies member variables or member methods together, it can be simply understood as a \"global constant\"! \n\n**<font color=\"orange\">For variables, it means that once a value is given, it cannot be modified, and can be accessed by the class name, the variable is shared by all instances of the class</font>**. \n\n**<font color=\"orange\">For methods, it means that they cannot be overridden and can be accessed directly by the class name</font>**. In particular, pay attention to a problem: for instance constants modified by static and final, the instance itself cannot be changed, but for instance variables of some container types (for example, ArrayList, HashMap), the container variable itself cannot be changed, but it can be modified. Objects stored in containers are used a lot in programming.\n","categories":["Java"]},{"title":"Leetcode 113. Path Sum II","url":"/Leetcode-113-Path-Sum-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven a sum, output tha paths which starts from the root node to the leaf nodes, and add up to sum.\n\n### Similar Question\n* Easy - [112. Path Sum](https://leetcode.com/problems/path-sum/)\n* Easy - [257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/)\n* Easy - [437. Path Sum III](https://leetcode.com/problems/path-sum-iii/)\n\n## Solution\nThis is an upgrade version from [112. Path Sum](https://leetcode.com/problems/path-sum/). For that question, we have the solution as follows:\n\n``` Java\npublic boolean hasPathSum(TreeNode root, int sum) {\n    if (root == null) {\n        return false;\n    }\n\n    // reach leave node\n    if (root.left == null && root.right == null && sum == root.val) {\n        return true;\n    }\n\n    // check left tree and right tree\n    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\n}   \n```\n\nHere we need an `ans` variable to hold all the results. A `temp` variable to hold the traversed path. The thing to note is that the list in java is passed by reference, so after the recursion, you must delete the previously added elements without affecting the `temp` of other branches.\n\n``` Java\npublic List<List<Integer>> pathSum(TreeNode root, int sum) {\n    List<List<Integer>> results = new ArrayList<>();\n\n    if (root == null) {\n        return results;\n    }\n\n    sum(root, sum, new ArrayList<>(), results);\n\n    return results;\n}\n\nprivate void sum(TreeNode root, int sum, List<Integer> temp, List<List<Integer>> results) {\n    if (root == null) {\n        return;\n    }\n\n    // reach leaf node\n    if (root.left == null && root.right == null) {\n        if (sum == root.val) {\n            temp.add(root.val);\n\n            results.add(new ArrayList<>(temp));\n\n            temp.remove(temp.size() - 1);\n        }\n\n        return;\n    }\n\n    // check left tree\n    temp.add(root.val);\n    sum(root.left, sum - root.val, temp, results);\n    temp.remove(temp.size() - 1);\n\n    // check right tree\n    temp.add(root.val);\n    sum(root.right, sum - root.val, temp, results);\n    temp.remove(temp.size() - 1);\n}\n```","tags":["Leetcode - Tree","Leetcode - Depth First Search"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 109. Convert Sorted List to Binary Search Tree","url":"/Leetcode-109-Convert-Sorted-List-to-Binary-Search-Tree/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven an ascending linked list and generate a balanced binary search tree.\n\n### Similar Question\n* Easy - [108. Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)\n\n## Solution\nThe key of the algorithm is to take the mid point as the root node. However, linked list here does not support random access.\n\nOne of the most commonly used method to find mid point in linked list is to use fast and slow pointers.\n\nThe fast pointer and the slow pointer traverse from the head at the same time. The fast pointer takes two steps at a time, and the slow pointer takes one step at a time. When the fast pointer reaches the end of the list, the slow pointer points to the mid position.\n\n``` Java\npublic static TreeNode sortedListToBST(ListNode head) {\n    return findMiddle(head, null);\n}\n\n// need to find the middle node in the linked list\nprivate static TreeNode findMiddle(ListNode start, ListNode end) {\n    if (start == end) {\n        return null;\n    }\n\n    // slow and fast pointer to find middle node\n    ListNode slow = start;\n    ListNode fast = start;\n\n    while (fast != end && fast.next != end) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    // slow is the middle point\n    TreeNode root = new TreeNode(slow.val);\n    root.left = findMiddle(start, slow);\n    root.right = findMiddle(slow.next, end);\n\n    return root;\n}\n```\n\nTime complexity: according to the recursive formula, T(n) = 2 * T(n / 2) + n = O(nlog(n)).\n\nSpace complexity: O(log(n)).","tags":["Leetcode - Depth First Search","Leetcode - Linked List"],"categories":["Data Structure and Algorithms"]},{"title":"Java Static code block","url":"/Java-Static-code-block/","content":"`Static code block`: declared with `staitc`, executed when the jvm loads the class, only once\n`Constructing code blocks`: defined by `{}` directly in the class and is executed every time an object is created.\n`Execution order`: static block, main(), function, constructing block, constructor.\n\n## Constructor\n``` Java\n// Constructor\npublic HelloA(){\n}\n```\n\nRegarding the constructor, the following points should be noted:\n1. Once the object is created, the corresponding constructor will be called, that is, if the object is not created, the constructor will not run.\n2. The function of the constructor is used to initialize the object.\n3. To create an object, the constructor is run only once, and normal methods can be called multiple times by the object.\n\n## Construction code block\n``` Java\n// Construction code block\n{    \n}\n```\n\nWith regard to constructing code blocks, the following points should be noted:\n1. The purpose of the construction code block is to initialize the object.\n2. The construction block is run as soon as the object is created, and it takes precedence over the execution of the constructor. It should be emphasized here that only when an object is created, the construction code block can be run. The class cannot call the construction code block, and the execution order of the construction code block and the constructor is that the former is executed before the latter.\n3. The difference between a construction code block and a constructor is that a construction code block is a uniform initialization of all objects, and a constructor is a corresponding object initialization, because there can be multiple constructors, whichever constructor is run will create what Object, but no matter which object is created, the same building code block is executed first. In other words, what is defined in the construction code block is the initialization content common to different objects.\n\n## Static code block\n``` Java\n// Static code block\nstatic {\n}\n```\n\nRegarding static code blocks, note that:\n1. It is executed as the class loads, only once, and takes precedence over the main function. Specifically, static code blocks are called by classes. When the class is called, the static code block is executed before the main function is executed.\n2. Static code blocks are actually initialized to classes, while constructing code blocks are initialized to objects.\n3. Variables in static code blocks are local variables, and they are no different from local variables in ordinary functions.\nThere can be multiple static code blocks in a class\n\nExample:\n``` Java\npublic class Test{\n    static int cnt=6;\n\n    static{\n        cnt+=9;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(cnt);\n    }\n\n    static{\n        cnt/=3;\n    }\n}\n\n// Results：\n// 5\n```\n\n## Execution order\nFor a class, constructor, static block and construction code block are executed in the following order:\n1. Static code block\n2. Construction code block\n3. Constructor\n\n**Example 1:** Static block is called when JVM loads the class. Even if not object of the class is defines, it will be called.\n``` Java\npublic class Test {\n    // Constructor\n    public Test(){\n        System.out.println(\"A's constructor\");   \n    }\n\n    // Construction code block\n    {\n        System.out.println(\"A's construction code block\");  \n    }\n\n    // Static block\n    static {\n        System.out.println(\"A's static block\");      \n    }\n\n    public static void main(String[] args) {\n    }\n}\n\n// Output:\n// A's static block\n```\n\n**Example 2:** Static code block is executed before construction code block and constructor\n``` Java\npublic class Test {\n    // Constructor\n    public Test(){\n        System.out.println(\"A's constructor\");   \n    }\n\n    // Construction code block\n    {\n        System.out.println(\"A's construction code block\");  \n    }\n\n    // Static block\n    static {\n        System.out.println(\"A's static block\");      \n    }\n\n    public static void main(String[] args) {\n        Test test = new Test();  \n    }\n}\n\n// Output:\n// A's static block\n// A's construction code block\n// A's constructor\n```\n\n**Example 3:** Static block is only executed once.\n``` Java\npublic class Test {\n    // Constructor\n    public Test(){\n        System.out.println(\"A's constructor\");   \n    }\n\n    // Construction code block\n    {\n        System.out.println(\"A's construction code block\");  \n    }\n\n    // Static block\n    static {\n        System.out.println(\"A's static block\");      \n    }\n\n    public static void main(String[] args) {\n        Test test = new Test();  \n        Test test2 = new Test();\n    }\n}\n\n// Output:\n// A's static block\n// A's construction code block\n// A's constructor\n// A's construction code block\n// A's constructor\n```\n\nWhen it comes to inheritance, the order is as follows:\n1. The static code block of the parent class and initialize the static member variables of the parent class\n2. The static code block of the subclass and initialize the static member variables of the subclass\n3. The parent class's construction code block, execute the parent's constructor, and initialize the ordinary member variables of the parent class\n4. The construction code block of the subclass, execute the constructor of the subclass, and initialize the ordinary member variables of the subclass\n\n``` Java\npublic class TestA {\n    // Constructor\n    public TestA(){\n        System.out.println(\"A's constructor\");   \n    }\n\n    // Construction code block\n    {\n        System.out.println(\"A's construction code block\");  \n    }\n\n    // Static block\n    static {\n        System.out.println(\"A's static block\");      \n    }\n}\n\npublic class TestB extends TestA{\n    // Constructor\n    public TestB(){\n        System.out.println(\"B's constructor\");   \n    }\n\n    // Construction code block\n    {\n        System.out.println(\"B's construction code block\");  \n    }\n\n    // Static block\n    static {\n        System.out.println(\"B's static block\");      \n    }\n\n    public static void main(String[] args) {\n        TestB testB = new TestB();      \n    }\n}\n\n// Output:\n// A's static block\n// B's static block\n// A's construction code block\n// A's constructor\n// B's construction code block\n// B's constructor\n```","categories":["Java"]},{"title":"Leetcode 105. Construct Binary Tree from Preorder and Inorder Traversal","url":"/Leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nRestored binary tree according to the pre-order and in-order traversal.\n\n### Similar Question\n* Medium - [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n\n## Solution\nThe order of the `pre-order traversal` is the root node, the left subtree, and the right subtree. The order of the `in-order` traversal is the left subtree, the root node, and the right subtree.\n\nSo we just need to get the root node according to the pre-order traversal, and then find the position of the root node in the in-order traversal. The left side is the nodes of the left subtree, and the right is the nodes of the right subtree.\n\nThe left and right subtrees can then be generated recursively.\n\nFor example\n\n```\npreorder = [3,9,20,15,7]\ninorder = [9,3,15,20,7]\nFirst find root node from pre-order, which is 3\n\nThen split in-order into left subtree and right subtree\n    Left:\n        in-order [9]\n    Right\n        in-order [15,20,7]\n\nAdd in subarray in pre-order\n    Left\n        pre-order [9] \n        in-order  [9]\n    Right\n        pre-order [20 15 7] \n        in-order  [15,20,7]\n\nNow we just need to build left subtree and right subtree, which turns original problem into a smaller one\n\nRepeat above steps, until pre-order and in-order are empty, then return null\n```\n\nIn fact, we don't need to really split the pre-order and in-order, we just need to use two pointers to point to the beginning and end respectively. Note that the range of the array pointed to by the two pointers below includes the left boundary, not includes the right boundary.\n\n``` Java\npublic static TreeNode buildTree(int[] preorder, int[] inorder) {\n    // map of value -> index in inorder array, for fast access\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < inorder.length; i++) {\n        map.put(inorder[i], i);\n    }\n\n    return getTree(preorder, 0, preorder.length, inorder, 0, inorder.length, map);\n}\n\nprivate static TreeNode getTree(int[] preOrder, int preOrderStart, int preOrderEnd,\n                                int[] inOrder, int inOrderStart, int inOrderEnd,\n                                Map<Integer, Integer> map) {\n    if (preOrderStart == preOrderEnd) {\n        return null;\n    }\n\n    // get root node value from preOrder\n    int rootVal = preOrder[preOrderStart];\n    // find the index of root node in inorder\n    int rootIndex = map.get(rootVal);\n\n    // number of nodes in left tree\n    int leftNumber = rootIndex - inOrderStart;\n\n    TreeNode node = new TreeNode(rootVal);\n\n    // recursively construct left tree\n    node.left = getTree(preOrder, preOrderStart + 1, preOrderStart + leftNumber + 1,\n            inOrder, inOrderStart, rootIndex, map);\n\n    // construct right tree\n    node.right = getTree(preOrder, preOrderStart + leftNumber + 1, preOrderEnd,\n            inOrder, rootIndex + 1, inOrderEnd, map);\n\n    return node;\n}\n```","tags":["Leetcode - Array","Leetcode - Tree","Leetcode - Depth First Search"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 13: Security","url":"/Spring-Cloud-13-Security/","content":"Security is a fundamental feature that cannot be bypassed in almost any application development. As we move applications to microservices architecture, security will become more complex. David Borsos presented the following four options at the London Microservices Conference in 2016:\n\n1. `Single sign-on (SSO)`: Every microservice needs to interact with the authentication service, but this will generate a lot of very trivial network traffic and repeated work. The disadvantages of the scheme are very obvious;\n\n2. `Distributed session`: This solution stores user authentication information in shared storage (such as: Redis), and uses the user session ID as a key to implement a simple distributed hash mapping. When a user accesses the microservice, the user authentication information can be obtained from the shared storage through the session ID. This solution is very good most of the time, but its main disadvantage is that shared storage requires a certain protection mechanism, and the corresponding implementation will be relatively complicated at this time;\n\n3. `Client token`: The token is generated on the client and signed by the authentication server. The token contains enough information so that microservices can use it. A token is attached to each request to provide user authentication for the microservice. The security of this solution is relatively good, but because the token is generated and saved by the client, it is very troublesome to log out. A compromise solution is to verify the validity of the token through short-term tokens and frequent checking of authentication services. `JSON Web Tokens (JWT)` is a very good choice for client tokens;\n\n4. `Client token combined with API gateway`: Using this scheme means that all requests pass through the gateway, effectively hiding the microservice. When requested, the gateway converts the original user token into an internal session. In this way, the gateway can deregister the token, thereby solving the problems in the previous solution.\n\nIn this article we will focus on token-based solutions, and the best option for token-based solutions is `OAuth2.0`.\n\n## OAuth2.0\nOAuth2.0 is described in Wikipedia as follows:\n\n> Open Authorization (OAuth) is an open standard that allows users to allow third-party applications to access private resources (such as photos, videos, contact lists) that the user has stored on a website without providing a username and password to the third party application.\n\n> OAuth allows users to provide a token instead of a username and password to access their data stored in a particular service provider. Each token authorizes a specific website (for example, a video editing website) to access a specific resource (for example, just a video in a certain album) within a specific period (for example, within the next 2 hours). In this way, OAuth allows users to authorize third-party websites to access certain information, but not all content, that they have stored in another service provider.\n\n> OAuth 2.0 is the next version of the OAuth protocol, but is not backward compatible with OAuth 1.0. OAuth 2.0 focuses on the simplicity of client developers, while providing specialized authentication processes for web applications, desktop applications and mobile phones, and living room devices.\n\nFor let us first understand a few key terms in `OAuth2.0`:\n\n* `Resource Owner`: The resource owner, in other words: User;\n* `User Agent`: User agent can be directly understood as a browser for Web applications;\n* `Authorization server`: Authentication server, that is, a server that provides user authentication and authorization. It can be a stand-alone server;\n* `Resource server`: the microservices that need to be protected.\n\nThen, let's take a look at the authentication flow chart of `OAuth2.0` (taken from [RFC6749](https://tools.ietf.org/html/rfc6749#section-1.2)):\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nThe authentication process are as follows:\n1. After the `user` opens the `client`, the `client` asks the `user` for authorization;\n2. the `user` agrees to authorize the `client`;\n3. The `client` uses the authorization obtained in the previous step to apply for a token from the `authentication server`;\n4. After the `authentication server` authenticates the `client`, it confirms that it is correct and agrees to issue the token;\n5. The `client` uses the token to apply to the `resource server` for resources;\n6. The `resource server` confirms that the token is correct and agrees to open the resource to the `client`.\n\nFrom the process we can see that the `client` can obtain the token from the `authentication service` only after the user authorize it. `OAuth2.0` provides the following four authorization methods for client authorization:\n\n* `Authorization code mode`: This mode is the most complete and strictest authorization mode;\n* `Simplified mode (implicit)`: This mode does not require the server of a third-party application, skips the \"authorization code\" step, and directly applies a token to the authentication server in the browser.\n* `Password mode`: The user provides his or her username and password to the client, and the client obtains authorization from the authentication server directly through this information;\n* `Client credentials`: The client obtains authentication from the authentication server in its own name, not in the name of the user. In this way, the authentication server treats the client as a user.\n\n## Example Project\n\n### 1. Authentication server\nFirst, we will build an authentication server. The server is also a standard Spring Boot application.\n\n#### 1.1 Dependency\n``` xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-security</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.security.oauth</groupId>\n    <artifactId>spring-security-oauth2</artifactId>\n</dependency>\n<dependency>\n    <groupId>jakarta.xml.bind</groupId>\n    <artifactId>jakarta.xml.bind-api</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.glassfish.jaxb</groupId>\n    <artifactId>jaxb-runtime</artifactId>\n</dependency>\n```\n\nHere we introduced `spring-cloud-security` and `spring-security-oauth2` dependencies. `jakarta.xml.bind-api` and `jaxb-runtime` are needed if using `Java11`.\n\n#### 1.2 Client management\nFor `OAuth2.0` applications, it is necessary to implement a client authentication management. Here we directly inherit `AuthorizationServerConfigurerAdapter` and add a client application through in-memory management.\n\n``` Java\n@Configuration\npublic class OAuthConfig extends AuthorizationServerConfigurerAdapter {\n    @Autowired\n    AuthenticationManager authenticationManager;\n    @Qualifier(\"userDetailsServiceBean\")\n    @Autowired\n    UserDetailsService userDetailsService;\n\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n        clients.inMemory()\n                .withClient(\"demo\")\n                .secret(\"{noop}pgDBd99tOX8d\")\n                .authorities(\"test\")\n                .authorizedGrantTypes(\"authorization_code\", \"refresh_token\", \"implicit\", \"password\", \"client_credentials\")\n                .scopes(\"spring-cloud-demo\")\n                .redirectUris(\"http://localhost:8761\");\n    }\n\n    @Override\n    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {\n        //if used permitAll() this will make oauth/check_token endpoint to be unsecure\n        //security.checkTokenAccess(\"permitAll()\");\n        security.checkTokenAccess(\"hasAuthority('test')\");\n    }\n\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {\n        endpoints\n                .authenticationManager(authenticationManager)\n                .userDetailsService(userDetailsService);\n    }\n\n    @Bean\n    public TokenStore tokenStore() {\n        return new InMemoryTokenStore();\n    }\n}\n```\n\nThe client ID is set to `demo`.\n\nhe secret is set to: `pgDBd99tOX8d`. `{noop}` is the **Password Storage Format** used for `Spring Security 5` default password encoder `DelegatingPasswordEncoder`. For details refer to: [Password Storage Format](https://spring.io/blog/2017/11/01/spring-security-5-0-0-rc1-released#password-storage-format).\n\nWe also authorized the client with `authorization_code`, `refresh_token`, `implicit`, `password`, `client_credentials` authentication mode. And in the following examples we will use `authorization code` mode and `password` mode for testing.\n\n#### 1.3 User authentication and authorization management\n``` Java\n@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class OAuthWebSecurityConfigurer extends WebSecurityConfigurerAdapter {\n    @Override\n    @Bean\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    @Override\n    @Bean\n    public UserDetailsService userDetailsServiceBean() throws Exception {\n        return super.userDetailsServiceBean();\n    }\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.inMemoryAuthentication()\n                .withUser(\"user001\")\n                .password(\"{noop}pwd001\")\n                .roles(\"USER\")\n                .and()\n                .withUser(\"admin\")\n                .password(\"{noop}pwdAdmin\")\n                .roles(\"USER\", \"ADMIN\");\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.csrf().disable();\n        http.authorizeRequests()\n                .anyRequest()\n                .authenticated()\n                .and()\n                .httpBasic();\n    }\n}\n```\n\nIn the above code, we still manage using in-memory and create two users:\n* **user001**: is an ordinary user, only `USER` role;\n* **admin**: is an administrator user with `USER` and `ADMIN` roles.\n\nWe also specified that all access needs to be secured, and enabled `httpBasic` authentication. Through this, when an unauthenticated user accesses, an authentication dialog box can pop up through the browser, allowing the user to enter a username and password for authentication.\n\n#### 1.4 Main application\n``` Java\n@SpringBootApplication\n@EnableAuthorizationServer\npublic class AuthServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(AuthServerApplication.class, args);\n    }\n}\n```\n\nAdding `@EnableAuthorizationServer` annotation to main class. With this annotation, the applicatoin will start with `Spring Cloud Security` and provide us with a series of endpoints to achieve `OAuth2.0` authentication. These endpoints are:\n* `/oauth/authorize`: endpoint for authorization;\n* `/oauth/token`: endpoint for getting the access token;\n* `/oauth/confirm_access`: endpoint for submit user authorization confirmation;\n* `/oauth/error`: endpoint for acquire authentication server error information;\n* `/oauth/check_token`: token resolution endpoint for resource server access;\n* `/oauth/token_key`: If using a `JWT` token, expose the public key used for token verification.\n\n#### 1.5 User information loading endpoint\nFor the authentication service, we also need to provide a user information loading endpoint, so that other microservices can use the token to obtain information about the authenticated user from the authentication server, so that user authentication and authentication processing can be achieved.\n\n``` Java\n@RestController\npublic class AuthEndpoint {\n    protected Logger logger = LoggerFactory.getLogger(AuthEndpoint.class);\n\n    @RequestMapping(value = { \"/auth/user\" }, produces = \"application/json\")\n    public Map<String, Object> user(OAuth2Authentication user) {\n        Map<String, Object> userInfo = new HashMap<>();\n        userInfo.put(\"user\", user.getUserAuthentication().getPrincipal());\n        userInfo.put(\"authorities\", AuthorityUtils.authorityListToSet( user.getUserAuthentication().getAuthorities()));\n        return userInfo;\n    }\n}\n```\n\nThis piece of code will obtain the current user information from `Spring Security` and convert it into a `Map` object to return.\n\n#### 1.6 Configuration file\n```\n# PORT\nserver.port=8290\n\nspring.application.name=authserver\n\nlogging.level.org.springframework=INFO\nlogging.level.springclouddemo.authserver=DEBUG\n```\n\n### 2. User service\n#### 2.1 Dependency\nThe user service is a `Resource server`. When certain resources are accessed, user authentication and authentication are required. Therefore, a dependency on `Spring Cloud Security` needs to be introduced\n\n``` xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-security</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.security.oauth</groupId>\n    <artifactId>spring-security-oauth2</artifactId>\n</dependency>\n<dependency>\n    <groupId>jakarta.xml.bind</groupId>\n    <artifactId>jakarta.xml.bind-api</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.glassfish.jaxb</groupId>\n    <artifactId>jaxb-runtime</artifactId>\n</dependency>\n```\n\nSimilar to `authentication server`, `jakarta.xml.bind-api` and `jaxb-runtime` are needed if using `Java11`.\n\n#### 2.2 Main application\nIn `Spring Cloud Security`, we only need to add the `@EnableResourceServer` annotation to applications that need security management to enable security management and control.\n\n``` Java\n@EnableDiscoveryClient\n@SpringBootApplication\n@EnableResourceServer\npublic class UserServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(UserServiceApplication.class, args);\n    }\n}\n```\n\nWhen `spring-cloud-security` is introduced and the `@EnableResourceServer` annotation is added, the application will start the default security management process. If you want to add more detailed security management to your application, you need to inherit `WebSecurityConfigurerAdapter` And implement security-related configuration, we will not go into details here.\n\n#### 2.3 Configuration file\n```\nserver.port=2200\n\nspring.application.name=USER-SERVICE\n\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n\n# OAuth\nsecurity.oauth2.resource.user-info-uri=http://localhost:8290/auth/user\n```\n\nWe need to add an `OAuth2` endpoint in the application configuration file to obtain authenticated user information\n\n#### 2.4 Endpoint of the current user information\nIn order to test, we need to add an endpoint in the `user service` to get the information of the currently logged in user。\n\n``` Java\n@RequestMapping(value = \"/my\", method = RequestMethod.GET)\npublic User myDetail() {\n    String userName = SecurityContextHolder.getContext().getAuthentication().getPrincipal().toString();\n\n    return new User(userName, userName, \"/avatar/default.png\", \"\");\n}\n```\n\nThe code is very simple, directly obtain the information of the currently logged-in user from the `SecurityContextHolder`, construct a `User` object, and then return.\n\n#### 2.5 ResourceServerConfig\nAs our `authenticatoin-server` and `user-service` are seperated service, they need to share the same `tokenStore` to share and recognize a token. In `user-service`, we need to tell the service to use the `RemoteTokenStore` located at `authenticatoin-server`.\n\n``` Java\n@Configuration\npublic class ResourceServerConfig extends ResourceServerConfigurerAdapter {\n    @Bean\n    public ResourceServerTokenServices tokenService() {\n        RemoteTokenServices tokenServices = new RemoteTokenServices();\n        tokenServices.setClientId(\"demo\");\n        tokenServices.setClientSecret(\"pgDBd99tOX8d\");\n        tokenServices.setCheckTokenEndpointUrl(\"http://localhost:8290/oauth/check_token\");\n        return tokenServices;\n    }\n\n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n                .anyRequest()\n                .authenticated()\n                .and()\n                .requestMatchers()\n                .antMatchers(\"/users/**\");\n    }\n}\n```\n\nOk, now `user-service` is secured. If we now start the `user-service` and access: http://localhost:2200/users/my, we will see the following return:\n\n{% asset_img 2.png %}\n<br/>\n<br/>\n\nThat is, permissions are now required to access the endpoint. So how do we provide permissions?\n\nEarlier when we talked about `OAuth2.0`, we mentioned that there are four client authorization modes, so let's take a look at how to use these authorization modes to implement specific user authentication processing.\n\n## Access through authorization code mode\nFirst, let's take a look at how to implement user authentication through the most comprehensive authorization process authorization code model provided by `OAuth2.0`.\n\nStart the service in following order:\n1. Eureak Server\n2. Auth Server\n3. User service\n\nFirstly, we need tp construct a URL to obtain an access token:\n```\nhttp://localhost:8290/oauth/authorize?response_type=code&client_id=demo&redirect_uri=http://localhost:8761&scope=spring-cloud-demo&state=63879\n```\n\nFor this URL:\n* `/oauth/authorize`: This is the endpoint to get the authorization code;\n* `client_id`: ID of the client. It must be included in the requested URL. Please note that the value we give here is: `demo`, this is what we configured the client list in the `authentication server`;\n* `response_type`: indicates the authorization type, which is also required. For the authorization code mode, it is fixed as: `code`;\n* `scope`: indicates the scope of the requested authority, which can be omitted. This refers to whether the authorization is reused when there are different clients;\n* `redirect_uri`: the URI to redirect to after successful authorization;\n* `state`: indicates the current state of the client. Any value can be specified. This value will be returned regardless of whether the authorization is successful or not.\n\nVisiting the URL, the page as follows:\n\n{% asset_img 3.png %}\n<br/>\n<br/>\n\nThis is the browser's own user login window. Because we haven't logged in, the `authentication server` turns on the browser login mode through `httpBasic`, so that when the user has not been authenticated, the above login window will pop up.\n\nEnter `user001` and `pwd001` in the login window, which is one of the user configured in the previous `authentication server`, and then it will jump to the following page:\n\n{% asset_img 4.png %}\n<br/>\n<br/>\n\nHere is the interface for whether the user is authorized. In this interface we can see that the `ID` and `authorization scope` of the incoming client. Here we click `Approve`, and the browser will jump to the address specified by `redirect_uri`. At this time, carefully observe the returned address, as follows:\n\n```\nhttp://localhost:8761/?code=w3ZOlC&state=63879\n```\n\nWe can see that the address contains two parameters:\n* `code`: The authorization code issued for the authentication service. The validity period of the code is short. The default is `10 minutes`, and the client can only use the code once, otherwise it will be rejected by the `authentication server`. The code has a one-to-one correspondence with the `client ID` and the `redirect URI`;\n* `state`: This is the parameter passed in when we requested above. The `authentication server` will return unaltered.\n\nNow that we have obtained the `authorization code` in the first step. Then the second step is to obtain the `access token` based on this `authorization code`.\n\n{% asset_img 5.png %}\n<br/>\n<br/>\n\nWe need the following parameters to construct the http post request:\n* `/oauth/token`: This is the endpoint that gets the access token;\n* `grant_type`: indicates the `authorization mode` to be used, which must be filled in.\n* `code`: the `authorization code` we obtained in the previous step;\n* `redirect_uri`: The URI to redirect to after successfully. Similarly, we need to set it to the address given previously;\n* `client_id`: Client ID, must be filled in, and it must be the same as before.\n\nIn addition, in the screenshot above, we also need to fill in the authorization information. This is because our `authentication server` has enabled authorization verification. Here you can fill in the `client ID` and `secret`. At this point, the server treats the client as a user and is able to access the `/oauth/token` endpoint.\n\n> Here we mainly simplify the test method, so that we can pop up the authentication dialog box during the previous visit. However, this should not be done in actual production use. You need to define your own user login page and authorization page.\n\nFor the above request, we can get the following return\n\n{% asset_img 6.png %}\n<br/>\n<br/>\n\nThe returned content is as follows:\n* `access_token`: this is the access token obtained;\n* `token_type`: Token type. The default value returned by `Spring Cloud OAuth` is `bearer`;\n* `expires_in`: indicates the token expiration time, in seconds, the default is 12 hours;\n* `refresh_token`: update token, which can be used to obtain the next access token after expiration;\n* `scope`: The scope of the permission, which is generally consistent with the scope applied by the client.\n\nWith the access token next step we can access the `user service`:\n\n{% asset_img 7.png %}\n<br/>\n<br/>\n\nThe response:\n\n{% asset_img 8.png %}\n<br/>\n<br/>\n\nWhen accessing, we need to specify `Authorization` in the header, and set the value to the `access token` obtained in the previous step, so that we can get the correct data returned, as shown in the figure above.\n\nWe have completed the test of user authentication through the `authorization code` mode. To summarize the steps:\n1. Visit `auth-server` and obtain `authentication code`.\n2. Use `authentication code` to get a `access code`.\n3. Use `access code` to access `resource server`.\n\n## Access through password mode\nIf the `authentication server` is third party, using the above process is not a big problem. If the `authentication server` is built by us, such as this example, the authorization above is a bit complicated. Let's take a look at how to use `password mode` to simplify.\n\nWe directly request the `authentication server` to obtain the `access token`:\n\n{% asset_img 9.png %}\n<br/>\n<br/>\n\nWe need to set the `client ID`, `secret`, `username` and `password` of the user, and set `grant_type` to `password`, so that you can directly obtain the `access token`, as shown in the following figure:\n\n{% asset_img 10.png %}\n<br/>\n<br/>\n\nAnd using the `access token` to access `user service`:\n\n{% asset_img 11.png %}\n<br/>\n<br/>\n\nThis shows that user authentication is also successful.\n\nIt can be seen that the `password` authentication mode can greatly simplify the user authentication process, but it is provided only when the user trusts the client. Therefore, this method is suitable for the case where the client and the authentication server are the same application.\n\nFor other client authorization modes, we will not discuss here.\n\nCheck out the source code here: [Security demo](https://github.com/nicklee1006/SpringCloudDemo/tree/master/security)","categories":["Spring Cloud"]},{"title":"Leetcode 89. Gray Code","url":"/Leetcode-89-Gray-Code/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nGenerate n-bit Gray codes. The so-called Gray codes are two consecutive numbers with only one bit different.\n\n### Similar Questions\n* Easy - [717. 1-bit and 2-bit Characters](https://leetcode.com/problems/1-bit-and-2-bit-characters/)\n\n## Solution - Dynamic Programming\nUse dynamic programming or recursive, that is, how to solve small problems and use it to solve large problems.\n\nWe assume that we have a solution of `n = 2` and then consider how to get a solution of `n = 3`.\n\n```\nSolution of n = 2\n00 - 0\n10 - 2\n11 - 3\n01 - 1\n```\n\nIf we add another bit, it is nothing more than adding 0 or 1 to the most significant bit. Consider adding 0 first. Since it is 0, the value has not changed.\n\n```\nSolution of n = 3, the most significant bit is 0\n000 - 0\n010 - 2\n011 - 3\n001 - 1\n```\n\nThen consider adding 1 and jsut putting 1 in the highest position based on the solution of n = 2?\n\n```\nSolution of n = 3\n000 - 0\n010 - 2\n011 - 3\n001 - 1  \n------------- Below are added\n100 - 4\n110 - 6\n111 - 7\n101 - 5\n```\n\nIt seems that it is not that simple. The fourth line `001` and the new fifth line `100` have 3 bits difference. So how to solve it?\n\nQuite simply, the most significant bit of the new data in line 5 changed from 0 in the previous line 4 to 1, so don't change the other bits, just pull the other bits in the 4th line, that is, `101`.\n\nNext, in order to make only one bit different between line 6 and line 5, because line 5 pulls the low bit of line 4, and line 4 and line 3 are only one bit different. So line 6 can take the low position of line 3. The other lines are the same, as shown below.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nThe blue part has the same value as all solutions with `n = 2` because the most significant bit is 0. And the orange part adds 1 to the most significant bit, so if it is a value, add 4 to its corresponding value, which is 2<sup>2</sup>, that is, 2<sup>3-1</sup>, which is 1 << (n-1). So our algorithm can be solved by iteration.\n\nSo if we know the solution of `n = 2`, which is `{0, 1, 3, 2}`, then the solution of `n = 3` is `{0, 1, 3, 2, 2 + 4, 3 + 4, 1 + 4 , 0 + 4}`, which is `{0 1 3 2 6 7 5 4}`. The previous solution is directly copied, and then each number plus `1 << (n-1)` is added to the result in reverse order.\n\n``` Java\nList<Integer> results = new ArrayList<>();\nresults.add(0);\n\nfor (int i = 0; i < n; i++) {\n    int add = (int) Math.pow(2, i);\n\n    for (int j = results.size() - 1; j >= 0; j--) {\n        results.add(results.get(j) + add);\n    }\n}\n        \nreturn results;\n```\n\nTime complexity: 2<sup>n</sup> because there are such many results.\n\nSpace complexity: O (1).","tags":["Leetcode - Backtracking"],"categories":["Data Structure and Algorithms"]},{"title":"Backtracking Algorithm","url":"/Backtracking-Algorithm/","content":"## Concept\nThe backtracking algorithm is actually an enumeration-like search attempt process, which is mainly to find a solution to the problem during the search attempt. When it is found that the solution conditions have not been met, it \"backtracks\" and try another path.\n\nThe backtracking method is a search method for optimal selection. It searches forward according to the optimal conditions to achieve the goal. However, when exploring a certain step, if it is found that the original choice is not good or does not reach the goal, it goes back one step and chooses again, which is called \"backtrack point\".\n\nMany complex and large-scale problems can use the backtracking method. So it is known as the \"universal problem solving method\".\n\n## Basic idea\nIn the solution space which contains all the solutions to the problem, the solution space is explored from the root node according to the `depth-first search` strategy. When a node is explored, first determine whether the node contains a solution to the problem. If it does, continue to explore from that node. If the node does not contain a solution to the problem, go back to its ancestor layers. (in fact, the backtracking method is a `depth-first search` algorithm for implicit graphs).\n\nIf using the backtracking method to find all the solutions to the problem, you must backtrack to the root, and all feasible subtrees of the root node must have been searched through before ending.\n\nIf you use the backtracking method to find any solution, you can end as long as you find a solution to the problem.\n\n## General steps to solve a problem using backtracking\n1. Determine the solution space for the given problem. The solution space of the problem should be clearly defined. The solution space of the problem should contain at least one (optimal) solution of the problem.\n\n2. Determine search rules for nodes\n\n3. Search the solution space in a `depth-first` manner, and use pruning functions to avoid invalid searches during the search.\n\n## Algorithm framework\n1. Problem framework\n\n```\nSuppose the solution of the problem is an n-dimensional vector(a1, a2, ...... an), and the constraint condition is that ai(i = 1,2,3, ....., n) satisfies a certain condition and is denoted as f(ai).\n```\n\n2. Non-recursive backtracking framework\n\n```\nint a[n],i;\ninitialize a[];\ni = 1;\n\n// haven't backtrack to the root\nwhile (i > 0 (still have path to go) and (haven't reach target)) { \n    // search leaf node\n    if(i > n) {                                             \n        find a solution, output\n    // process i-th element\n    } else {                                                 \n        a[i] the first possible value；\n        \n        while(a[i] not satisfy constraint condition, but still within search space) {\n            a[i] next possible value；\n        }\n\n        if(a[i] within search space) {\n            mark occupied resource;\n\n            // extend to next node\n            i = i+1;  \n        } else {\n            clear occupied resource;\n\n            // backtrack\n            i = i –1; \n        }\n    }\n}\n```\n\n3. Recursive backtracking framework\nThe backtracking method is a `depth-first search` of the solution space. In general, it is relatively simple to use a recursive function to implement the backtracking method, where `i` is the depth of the search, and the framework is as follows:\n\n```\nint a[n];\ntry(int i) {\n    if(i>n)\n        output result;\n    else {\n        // iterate all possible path for i\n        for(j = lower bound; j <= upper bound; j=j+1) {\n            // satisfy boundary and constraint condition\n            if(fun(j)) {                 \n                a[i] = j;\n                // other operations\n                ...\n                try(i+1);\n                    cleaning tasks before backtracking (e.g set a[i] to empty etc);\n            }\n        }\n    }\n}\n```","tags":["Leetcode - Backtracking"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 77. Combinations","url":"/Leetcode-77-Combinations/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nGiven `n`, `k`, select `k` numbers from `{1, 2, 3 ... n}`, output all possible, and sort numbers from small to large, and each number can only be used once.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-39-Combination-Sum '39. Combination Sum' %}\n* Medium - {% post_link Leetcode-46-Permutations '46. Permutations' %}\n\n## Solution\nVery classic backtracking problem. First select a number, then enter the recursion to continue to select, meet the conditions and add to the result, then back to the previous step and continue the recursion. \n\nLook at the code directly, it is easy to understand.\n\n``` Java\npublic List<List<Integer>> combine(int n, int k) {\n    List<List<Integer>> result = new ArrayList<>();\n\n    backtrack(result, new ArrayList<>(), n, k, 1);\n\n    return result;\n}\n\n// similar to permutation\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int n, int k, int start) {\n    // find a solution, add to result list\n    if (tempList.size() == k) {\n        result.add(new ArrayList<>(tempList));\n        return;\n    }\n\n    for (int i = start; i <= n; i++) {\n        // avoid duplicates\n        if (tempList.contains(i)) {\n            continue;\n        }\n\n        // add current number in\n        tempList.add(i);\n\n        // add other numbers in\n        backtrack(result, tempList, n, k, i + 1);\n\n        // all possible number has been added, remove last number and start\n        tempList.remove(tempList.size() - 1);\n    }\n}\n```\n\nA for loop, `add`, `recurse`, `delete`, is a classic backtracking template. Here is an optimization method. In the for loop, `i` goes from `start` to `n`, but it is not necessary to go to `n`. For example, `n = 5`, `k = 4`, `tempList.size () == 1`, which means that we need `(4-1 = 3)` numbers. If `i = 4`, we will at most add  4 and 5 to `tempList`. In this case, `tempList.size()` is equal to `1 + 2 = 3`, which is less than 4, so `i` does not need to be equal to 4, and it is sufficient for `i` to loop to 3.\n\nSo the end condition of the `for` loop can be changed to `i <= n-(k-tempList.size()) + 1`, `k-tempList.size()` represents the numbers we need. Because we got `n` in the end, we need to add 1.\n\n``` Java\npublic List<List<Integer>> combine(int n, int k) {\n    List<List<Integer>> result = new ArrayList<>();\n\n    backtrack(result, new ArrayList<>(), n, k, 1);\n\n    return result;\n}\n\n// similar to permutation\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int n, int k, int start) {\n    // find a solution, add to result list\n    if (tempList.size() == k) {\n        result.add(new ArrayList<>(tempList));\n        return;\n    }\n\n    for (int i = start; i <= n - (k -tempList.size()) + 1; i++) {\n        // avoid duplicates\n        if (tempList.contains(i)) {\n            continue;\n        }\n\n        // add current number in\n        tempList.add(i);\n\n        // add other numbers in\n        backtrack(result, tempList, n, k, i + 1);\n\n        // all possible number has been added, remove last number and start\n        tempList.remove(tempList.size() - 1);\n    }\n}\n```\n\nAlthough only one line of code is changed, the speed is much faster.\n\nThere are other methods, such as `recursion`, `iteration`, `dynamic programming` can be applied here, which I will be discuss in the future if have time.\n","tags":["Leetcode - Backtracking"],"categories":["Data Structure and Algorithms"]},{"title":"Java CountDownLatch","url":"/Java-CountDownLatch/","content":"The JDK concurrency package provides several very useful tool classes. These tool classes provide us with a means of concurrent process control in the development. This article will introduce how to use `CountDownLatch` and the internal implementation mechanism based on actual application scenarios. \n\n## What is CountDownLatch\n`CountDownLatch`, was introduced in JDK 1.5, allowing one or more threads to wait for other threads to complete operations before executing.\n\n`CountDownLatch` internally maintains a `counter` whose initial value is the number of threads. The main thread executes the await method. If the `counter` is greater than 0, it blocks and waits. When a thread finishes its task, the `counter` value is decremented. When the `counter` is 0, it means that all threads have completed their tasks, and the waiting main thread is awakened to continue execution.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\n## Example\nThe main thread of the application wants to execute after all other threads are completed.\n\nThe main class that uses a thread pool to perform tasks for each worker. Responsible for initializing the `CountDownLatch`, and then wait until all workers complete.\n\n``` Java\npublic class CountDownLatchApplication {\n    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch countDownLatch = new CountDownLatch(3);\n\n        List<Worker> workers = new ArrayList<>();\n        workers.add(new Worker(countDownLatch, \"worker1\"));\n        workers.add(new Worker(countDownLatch, \"worker2\"));\n        workers.add(new Worker(countDownLatch, \"worker3\"));\n\n        Executor executor = Executors.newFixedThreadPool(workers.size());\n\n        for (Worker worker : workers) {\n            executor.execute(worker);\n        }\n\n        countDownLatch.await();\n\n        System.out.println(\"all workers finished\");\n    }\n}\n```\n\nWorker class. Using `TimeUnit.SECONDS.sleep` to simulate long running task.\n\n``` Java\npublic class Worker implements Runnable {\n    private CountDownLatch countDownLatch;\n    private String name;\n\n    public Worker(CountDownLatch countDownLatch, String name) {\n        this.countDownLatch = countDownLatch;\n        this.name = name;\n    }\n\n    @Override\n    public void run() {\n        try {\n            System.out.println(name + \"started!\");\n\n            TimeUnit.SECONDS.sleep(2);\n\n            System.out.println(name + \"finished!\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            if (countDownLatch != null) {\n                countDownLatch.countDown();\n            }\n        }\n    }\n}\n```\n\nOutput:\n\n```\nworker2started!\nworker3started!\nworker1started!\nworker1finished!\nworker3finished!\nworker2finished!\nall workers finished\n```\n\n## Principle of the implementation\n`CountDownLatch` implementation is mainly based on the java synchronizer `AQS`.\n\nIt maintains an `AQS` subclass internally and overrides related methods.\n\n``` Java\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n    private static final long serialVersionUID = 4982264981922014374L;\n\n    Sync(int count) {\n        setState(count);\n    }\n\n    int getCount() {\n        return getState();\n    }\n\n    protected int tryAcquireShared(int acquires) {\n        return (getState() == 0) ? 1 : -1;\n    }\n\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        for (;;) {\n            int c = getState();\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            if (compareAndSetState(c, nextc))\n                return nextc == 0;\n        }\n    }\n}\n```\n\n## Implementation of await\nThe main thread executes the `await` method. If the state is not equal to 0 in the `tryAcquireShared` method and returns -1, it is added to the waiting queue, and the main thread is suspended through `LockSupport.park(this)`.\n\n``` Java\nprivate void doAcquireSharedInterruptibly(int arg)\n    throws InterruptedException {\n    final Node node = addWaiter(Node.SHARED);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head) {\n                int r = tryAcquireShared(arg);\n                if (r >= 0) {\n                    setHeadAndPropagate(node, r);\n                    p.next = null; // help GC\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n## Implementation of countDown\nThe `countDown` method delegates `sync` to reduce the `state` by one, which is to set the `state` value through the `unsafe.compareAndSwapInt` method.\n\n``` java\npublic void countDown() {\n    sync.releaseShared(1);\n}\n```\n\nIf `state` is 0, then wake up the main thread suspended in the `await` method through `LockSupport.unpark`.\n\n``` Java\nprivate void doReleaseShared() {\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            // loop to recheck cases\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;                // loop on failed CAS\n        }\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n```\n\n## Difference from CyclicBarrier\n* `CyclicBarrier` allows a series of threads to wait for each other to reach a point. As the barrier indicates, this point is like a fence. The first arriving thread is blocked in front of the fence. It must wait until all threads have reached before it can pass the fence.\n* `CyclicBarrier` has a variable `parties`, which indicates the number of threads that need to be reached. The thread that arrives first calls the `barrier.await` method to wait. Once the number of threads reaches the number specified by the `parties` variable, the fence is opened and all threads can pass;\n* `CyclicBarrier` constructor accepts another `Runnable` parameter `barrierAction`, which indicates the action to be taken when the barrier is opened. `Null` indicates that no action is taken. Note that the action will be executed after the barrier is opened and before all other threads are run.\n* `CyclicBarrier` is reusable. When the last thread arrives, the fence is opened. After all threads pass, the fence is closed again to enter the next generation;\n* `CyclicBarrier.reset` method can reset the fence manually, and the waiting thread will receive a `BrokenBarrierException`\nabnormal.\n\n## Conclusion\nThrough the introduction of this article, I hope everyone can understand the application scenario and working mechanism of `CountDownLatch`.\n","categories":["Java"]},{"title":"Leetcode 47. Permutations II","url":"/Leetcode-47-Permutations-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nSimilar to {% post_link Leetcode-46-Permutations '46. Permutations' %}, the difference is that there will be duplicates in the input, so using the previous algorithm will produce duplicate sequences. For example, `[1 1]`, using the previous algorithm, the result must be `[[1 1], [1 1]]`. In other words, a repeated sequence is generated. But we can modify the solution to the previous question to solve this problem.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-31-Next-Permutation '31. Next Permutation' %}\n* Medium - {% post_link Leetcode-46-Permutations '46. Permutations' %}\n* Medium - {% post_link Leetcode-60-Permutation-Sequence '60. Permutation Sequence' %}\n* Hard - [996. Number of Squareful Arrays](https://leetcode.com/problems/number-of-squareful-arrays/)\n\n## Solution\nLook at the previous solution:\n\n``` Java\npublic List<List<Integer>> permute(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n\n    backtrack(result, new ArrayList<>(), nums);\n\n    return result;\n}\n\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums) {\n    // find a solution, add to result\n    if (tempList.size() == nums.length) {\n        result.add(new ArrayList<>(tempList));\n    }\n\n    for (int num : nums) {\n        // if already have the number, skip\n        if (tempList.contains(num)) {\n            continue;\n        }\n\n        tempList.add(num);\n\n        // continue adding next one\n        backtrack(result, tempList, nums);\n\n        // remove the last added one\n        tempList.remove(tempList.size() - 1);\n    }\n}\n```\n\nThe first thing to resolve is these lines of code\n\n``` Java\nif (tempList.contains(num)) {\n    continue;\n}\n```\n\nThere are no duplicate elements before, so we can directly determine whether there is a current element in `tempList` and skip it if there is one. But here, because there are duplicate elements, this method is obviously not possible.\n\nPut another way, we can use another list to save the index of the elements already in the current `tempList`, and then decide if index already exist when adding new elements.\n\nThe second problem is that when we have duplicate elements, the generated result may contain same list, which is unnecessary.\n\nThe solution is to sort the array first, and then determine whether the previously added element is equal to the current element. If they are equal, skip it and continue to the next element.\n\nCode:\n\n``` Java\npublic List<List<Integer>> permuteUnique(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n\n    Arrays.sort(nums);\n\n    backtrack(nums, new ArrayList<>(), new ArrayList<>(), result);\n\n    return result;\n}\n\nprivate void backtrack(int[] nums, List<Integer> tempList, List<Integer> indexList, List<List<Integer>> result) {\n    if (tempList.size() == nums.length) {\n        result.add(new ArrayList<>(tempList));\n    }\n\n    for (int i = 0; i < nums.length; i++) {\n        // already have the elements added\n        // solve the first problem\n        if (indexList.contains(i)) {\n            continue;\n        }\n\n        // remove duplicates\n        // solve the second problem\n        if (i > 0 && !indexList.contains(i - 1) && nums[i - 1] == nums[i]) {\n            continue;\n        }\n\n        indexList.add(i);\n        tempList.add(nums[i]);\n\n        backtrack(nums, tempList, indexList, result);\n\n        indexList.remove(indexList.size() - 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}\n```\n\nTo solve the second problem `!indexList.contains(i - 1)` is very important because the above `indexList.contains(i)` code will make some elements skipped and not added to the `tempList`, so we have to determine whether `nums[i-1]` is the skipped element, if `indexList.contains(i)` returns true, even if `nums[i-1] == nums[i]` cannot skip the current element. Because the previous element `nums[i-1]` was not added to the `tempList`.","tags":["Leetcode - Backtracking"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 12: Message bus","url":"/Spring-Cloud-12-Message-bus/","content":"Before we start talking about `Spring Cloud Bus`, let's look at another IT term: `ESB (Enterprise Service Bus)`. `ESB` is described in Wikipedia (https://en.wikipedia.org/wiki/Enterprise_service_bus):\n\n> An enterprise service bus (ESB) implements a communication system between mutually interacting software applications in a service-oriented architecture (SOA). It represents a software architecture for distributed computing, and is a special variant of the more general client-server model, wherein any application may behave as server or client. ESB promotes agility and flexibility with regard to high-level protocol communication between applications. Its primary use is in enterprise application integration (EAI) of heterogeneous and complex service landscapes.\n\n`Enterprise service bus` usually provides an abstraction layer on the enterprise message system, so that the integration architect can use the value of the message to complete the integration without coding. In simple terms, the `enterprise service bus` is another abstraction layer that is built on top of the message middleware, so that we can complete the processing of business logic without caring about message-related processing.\n\nAt this point, have you suddenly understood the relationship between `Spring Cloud Bus` and `Spring Cloud Stream`? When you first know these two components, most of you will be confused about what is the difference between the two? What is the connection between them? `Stream` abstracts and encapsulates the message middleware to provide a unified interface for us to send and listen to messages, while `Bus` is abstracted and encapsulated again on the basis of `Stream`, so that we can complete the processing of business logic without understanding the basics of message sending and listening.\n\nSo how does `Spring Cloud Bus` do it for us? In a word, it is the event mechanism.\n\n## Spring's event mechanism\nThere is an event mechanism in the `Spring` framework, which is an implementation of the observer pattern. Observer pattern establishes a kind of object-to-object relationship. When an object(called: `observation target`) changes, it will automatically notify other objects(called: `observer`), and these `observers` will make corresponding reaction. An `observation target` can correspond to multiple `observers`, and there is no mutual connection between these `observers`. You can add and delete `observers` as needed, making the system easier to expand. The following purposes can be achieved through the Spring event mechanism:\n\n* Decoupling between application modules;\n* You can define multiple processing methods for the same event according to your needs;\n* Not disturbing the main line application is an excellent `Open and Close Principle (OCP)` practice.\n\nWhen we introduce event mechanism in our application, we need to use the following interfaces or abstract classes in `Spring`:\n* **ApplicationEventPublisher**: This is an interface for publishing an event;\n* **ApplicationEvent**: This is an abstract class used to define an event;\n* **ApplicationListener &lt;E extends ApplicationEvent&gt;**: This is an interface that implements event listening.\n\nThe context of the Spring application, `ApplicationContext`, implements the `ApplicationEventPublisher` interface by default, so when publishing events, we can directly use the `ApplicationContext.publishEvent()` method.\n\nA typical `Spring` event sending and listening code is as follows:\n\n### Define event\nFor example, we define a user event:\n\n``` Java\npublic class UserEvent extends ApplicationEvent {\n    /** Message type */\n    public static final String ET_UPDATE = \"update\";\n\n    // ========================================================================\n    // fields =================================================================\n    private String action;\n    private User user;\n\n    // ========================================================================\n    // constructor ============================================================\n    public UserEvent(User user) {\n        super(user);\n        this.user = user;\n    }\n\n    public UserEvent(User user, String action) {\n        super(user);\n        this.action = action;\n        this.user = user;\n    }\n\n    @Override\n    public String toString() {\n        return MoreObjects.toStringHelper(this)\n                .add(\"action\", this.getAction())\n                .add(\"user\", this.getUser()).toString();\n    }\n\n    // ==================================================================\n    // setter/getter ====================================================\n    public String getAction() {\n        return action;\n    }\n    public void setAction(String action) {\n        this.action = action;\n    }\n\n    public User getUser() {\n        return user;\n    }\n    public void setUser(User user) {\n        this.user = user;\n    }\n}\n```\n\n### Define listener\nWe define a user event listener and handle the event when the user changes:\n\n``` java\n@Component\npublic class UserEventListener implements ApplicationListener<UserEvent> {\n    protected Logger logger = LoggerFactory.getLogger(this.getClass());\n    \n    @Override\n    public void onApplicationEvent(UserEvent userEvent) {\n        this.logger.debug(\"Received user event: {} \", userEvent);\n        // TODO: detail business logic\n    }\n}\n```\n\nEvent listening is relatively simple. You only need to implement the `ApplicationListener` interface and handle it accordingly.\n\n### Publish event\nWe can implement it directly in Event class. For example, we change the above `UserEvent` to the following:\n\n``` Java\npublic class UserEvent extends ApplicationEvent {\n    // ignore previous code\n\n    /**\n     * Pubblish event\n     */\n    public void fire() {\n        ApplicationContext context = ApplicationContextHolder.getApplicationContext();\n        if(null != context) {\n            logger.debug(\"Publish event：{}\", this);\n            context.publishEvent(this);            \n        }else{\n            logger.warn(\"Can't obtain application context\");\n        }\n    }\n}\n```\n\nThen we can publish events with the following code where needed:\n\n``` Java\nnew UserEvent(user, UserEvent.ET_UPDATE).fire();\n```\n\n## Spring Cloud Bus mechanism\nWe learned about `Spring`'s event mechanism above, so how does `Spring Cloud Bus` combine the event mechanism with `Stream`? In summary, the mechanism is as follows:\n1. Add the `@RemoteApplicationEventScan` annotation to the application that needs to publish or listen to events. With this annotation we can start the binding of the message channel mentioned in the `Stream`;\n2. For **event publishing**, you need to extend the `ApplicationEvent` extension class-`RemoteApplicationEvent`. When this type of event is published through `ApplicationContext.publishEvent()`, `Spring Cloud Bus` will wrap the event, form a message we are familiar with,  and then send it to the message broker through the default `springCloudBus` message channel;\n3. For **event listeners**, you don't need to make any changes, and you can still listen to messages in the same way as above. However, it should be noted that the events defined in step 2 must also be defined in the consumer microservices project, and the entire class names need to be consistent (if they are inconsistent, a little extra work is needed).\n\nWith `Spring Cloud Bus`, we can develop like writing a monolithic application without having to deal with a lot of concepts such as message broker, topics, messages, channels, and so on.\n\nLet's look at how we can modify the `Stream` demo to incooperate `Spring Cloud Bus`.\n\n## Refactor Spring Cloud Stream demo\n### Refactor Product-Service\n#### 1. Add bus dependency\n``` xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-bus-kafka</artifactId>\n</dependency>\n```\n\n#### 2. Create Product Event\nWe change the product message to an event with the following code:\n\n``` Java\npublic class ProductEvent extends RemoteApplicationEvent {\n    /** Message type：update, value: {@value} */\n    public static final String ET_UPDATE = \"update\";\n    /** Message type：delete, value: {@value} */\n    public static final String ET_DELETE = \"delete\";\n\n    // ========================================================================\n    // fields =================================================================\n    private String action;\n    private String itemCode;\n\n    public ProductEvent() {\n        super();\n    }\n\n    public ProductEvent(Object source, String originService, String destinationService, String action, String itemCode) {\n        super(source, originService, destinationService);\n        this.action = action;\n        this.itemCode = itemCode;\n    }\n\n    @Override\n    public String toString() {\n        return \"action: \" + this.action + \" itemCode: \" + this.itemCode;\n    }\n\n    public String getAction() {\n        return action;\n    }\n\n    public void setAction(String action) {\n        this.action = action;\n    }\n\n    public String getItemCode() {\n        return itemCode;\n    }\n\n    public void setItemCode(String itemCode) {\n        this.itemCode = itemCode;\n    }\n}\n```\n\nHere the difference in constructor is that you need to specify the `originService` and `destinationService` when constructing an event. For **event publishers**, `originService` is itself, and `destinationService` refers to those microservice instances that need to publish this event. The format of the `destinationService` configuration is: `{serviceId}: {appContextId}`. During configuration, `serviceId` and `appContextId` can use wildcards. If both variables use wildcards `(*:**)`, the event will be published to all microservice instances. If only the `appContextId` is omitted, the event will only be published to all instances of the specified microservice. For example: `userservice:**`, the event will only be published to the `userservice` microservice.\n\n#### 3. Implement event publishing\nWe change the code in ProductService as follows:\n\n``` Java\n@Service\npublic class ProductService {\n    private Logger logger = LoggerFactory.getLogger(ProductService.class);\n\n    private List<ProductDto> productList;\n\n    @Autowired\n    BusProperties busProperties;\n\n    @Autowired\n    public ProductService() {\n        this.productList = this.buildProducts();\n    }\n\n    /**\n     * Get product list\n     */\n    public List<ProductDto> findAll() {\n        return this.productList;\n    }\n\n    /**\n     * get product by item\n     */\n    public ProductDto findOne(String itemCode) {\n        for (ProductDto productDto : this.productList) {\n            if (productDto.getItemCode().equalsIgnoreCase(itemCode))\n                return productDto;\n        }\n\n        return null;\n    }\n\n    /**\n     * update or save product\n     */\n    public ProductDto save(ProductDto productDto) {\n        for (ProductDto sourceProductDto : this.productList) {\n            if (sourceProductDto.getItemCode().equalsIgnoreCase(productDto.getItemCode())) {\n                sourceProductDto.setName(sourceProductDto.getName() + \"-new\");\n                sourceProductDto.setPrice(sourceProductDto.getPrice() + 100);\n                productDto = sourceProductDto;\n                break;\n            }\n        }\n\n        // publish event\n        this.fireEvent(ProductEvent.ET_UPDATE, productDto);\n\n        return productDto;\n    }\n\n    /**\n     * Implement publish event\n     */\n    protected void fireEvent(String eventAction, ProductDto productDto) {\n        ProductEvent productEvent = new ProductEvent(productDto,\n                busProperties.getId(),\n                \"*:**\",\n                eventAction,\n                productDto.getItemCode());\n        this.logger.info(\"Publish event:{} \", productEvent);\n\n        // Publish\n        RemoteApplicationEventPublisher.publishEvent(productEvent);\n    }\n\n    protected List<ProductDto> buildProducts() {\n        List<ProductDto> products = new ArrayList<>();\n        products.add(new ProductDto(\"item-1\", \"test-1\", \"brand1\", 100));\n        products.add(new ProductDto(\"item-2\", \"test-2\", \"brand2\", 200));\n        products.add(new ProductDto(\"item-3\", \"test-3\", \"brand3\", 300));\n        products.add(new ProductDto(\"item-4\", \"test-4\", \"brand4\", 400));\n        products.add(new ProductDto(\"item-5\", \"test-5\", \"brand5\", 500));\n        products.add(new ProductDto(\"item-6\", \"test-6\", \"brand6\", 600));\n\n        return products;\n    }\n}\n```\n\nThe code of `RemoteApplicationEventPublisher`:\n\n``` Java\npublic class RemoteApplicationEventPublisher {\n    protected static Logger logger = LoggerFactory.getLogger(RemoteApplicationEventPublisher.class);\n\n    public static void publishEvent(RemoteApplicationEvent event){\n        ApplicationContext context = ApplicationContextHolder.getApplicationContext();\n        if(null != context) {\n            context.publishEvent(event);\n            logger.info(\"Publish:{}\", event);\n        }else{\n            logger.warn(\"Unable to get application context\");\n        }\n    }\n}\n```\n\n#### 4. Main application\nFinally, modify the main class and add the `@RemoteApplicationEventScan` annotation:\n\n``` Java\n@EnableDiscoveryClient\n@RemoteApplicationEventScan\n@SpringBootApplication\npublic class ProductServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ProductServiceApplication.class, args);\n    }\n}\n```\n\n> Note: the remote event must be defined in a subpackage of the class annotated by `@RemoteApplicationEventScan` annotation, otherwise remote event publishing cannot be achieved\n\n### Refactor Product-Service-Consumer\n#### 1. Add bus dependency\n``` xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-bus-kafka</artifactId>\n</dependency>\n```\n\n#### 2. Copy ProductEvent to this project\n\n#### 3. Implement event listening\n``` Java\n@Component\npublic class ProductEventListener implements ApplicationListener<ProductEvent> {\n    protected Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @Qualifier(\"productServiceFallback\")\n    @Autowired\n    protected ProductService productService;\n\n    @Override\n    public void onApplicationEvent(ProductEvent productEvent) {\n        if (ProductEvent.ET_UPDATE.equalsIgnoreCase(productEvent.getAction())) {\n            this.logger.debug(\"Received update event itemCode: {}\", productEvent.getItemCode());\n            // get new product info\n            Product productDto = this.productService.loadByItemCode(productEvent.getItemCode());\n            if (null != productDto)\n                this.logger.debug(\"Update product info:{}\", productDto);\n            else\n                this.logger.debug(\"itemCode:{} no exist\", productEvent.getItemCode());\n        } else if (ProductEvent.ET_DELETE.equalsIgnoreCase(productEvent.getAction())) {\n            this.logger.debug(\"Received delete event itemCode: {}\", productEvent.getItemCode());\n        } else {\n            this.logger.debug(\"Unknown product event: {}\", productEvent);\n        }\n    }\n}\n```\n\n#### 4. Main class\nAs with `Product-Service`, remote message scanning needs to be enabled for both event publishing and event monitoring. Add the `@RemoteApplicationEventScan` annotation directly to the main class\n\n``` Java\n@EnableFeignClients\n@EnableDiscoveryClient\n@EnableCircuitBreaker\n@RemoteApplicationEventScan\n@SpringBootApplication\npublic class ConsumerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsumerApplication.class, args);\n    }\n}\n```\n\n### Testing\nStart service in the following order:\n1. Kafka server;\n2. Service-discovery;\n3. Product-Service microservice;\n4. Product-Service-Consumer microservices.\n\nPOST a HTTP request to: http://localhost:2100/products/item-2. In the console of the `Product-Service` microservice, you can see output similar to the following:\n\n```\n2020-03-06 23:40:26.498 DEBUG             82437 --- [nio-2100-exec-1] o.s.web.servlet.DispatcherServlet        : POST \"/products/item-2\", parameters={}\n2020-03-06 23:40:26.517  INFO             82437 --- [nio-2100-exec-1] s.productservice.service.ProductService  : Publish event:action: update itemCode: item-2 \n```\n\nFrom the output log, you can see that the product event has been published. If at this time we look at the console of the `Product-Service-Consumer` microservice, we can see the output of the following:\n\n```\n2020-03-06 23:40:33.722  INFO             82441 --- [container-0-C-1] s.mall.event.ProductEventListener        : Received update event itemCode: item-2\n2020-03-06 23:40:33.723  INFO             82441 --- [container-0-C-1] s.mall.event.ProductEventListener        : Update product info:springclouddemo.mall.entity.Product@14a7134\n```\n\nFrom the log output, you can see that the `Product-Service-Consumer` microservice has been able to correctly receive the product change event and handle it accordingly.\n\n### Conclusion\nIt is indeed easier to understand and easier to use `Bus` from the refactored code. This is very good for simple applications, such as broadcasting. A typical application is configuration refresh in `Config`. When both `Config` and `Bus` are introduced into a project, configuration changes can be broadcasted via the `/bus/refresh` endpoint, allowing the corresponding microservice to reload configuration data.\n\nOf course, another layer of the simplicity of `Bus` is that it is not flexible enough, so whether you use `Bus` or directly use `Streams` in your project depends on your needs.\n\nCheck out the source code here: [Bus demo](https://github.com/nicklee1006/SpringCloudDemo/tree/master/bus)","categories":["Spring Cloud"]},{"title":"Leetcode 46. Permutations","url":"/Leetcode-46-Permutations/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven a few numbers, then output all possible permutations of them.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-31-Next-Permutation '31. Next Permutation' %}\n* Medium - {% post_link Leetcode-47-Permutations-II '47. Permutations II' %}\n* Medium - {% post_link Leetcode-60-Permutation-Sequence '60. Permutation Sequence' %}\n* Medium - {% post_link Leetcode-77-Combinations '77. Combinations' %}\n\n## Solution - Inserting\nFirst consider how to solve small problems, and then use small problems to solve large problems. That's right, the idea of recursion. For example:\n\nIf there is only 1 number `[1]`, then it is very simple, just returning `[[1]]`.\n\nWhat about `[1 2]` ? We just need to insert 2 in the gap of 1, which is 2 on the left and right. Result becomes `[[2 1], [1 2]]`.\n\nWhat about `[1 2 3]`? Similarly, we just need to insert the number 3 into the gap in all the cases above. For example, `[2 1]` inserts 3 on the left, middle, and right to become `3 2 1`, `2 3 1`, `2 1 3`. Similarly, `[1 2]` inserts 3 on the left, middle, and right to becomes `3 1 2`, `1 3 2`, `1 2 3`, so the final result is `[[3 2 1], [2 3 1], [2 1 3 ], [3 1 2], [1 3 2], [1 2 3]]`.\n\nIf you add more numbers, it is all the same. Just insert a new number in the space between the numbers.\n\nTime complexity should be O(n!)\n\nSpace complexity: O(1)\n\n## Solution - Backtracking\nTypical backtracking problem. Using recursion to add a number to temp list each time. When there are enough numbers then come back to backtrack and then add a new solution backwards.\n\nIt can be understood as adding layer by layer, each layer is a for loop.\n\nEach invocation of a layer enters a for loop, which is equivalent to listing all the solutions and then picking what we need. It's essentially a `depth-first` traversal.\n\n``` Java\npublic List<List<Integer>> permute(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n\n    backtrack(result, new ArrayList<>(), nums);\n\n    return result;\n}\n\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums) {\n    // find a solution, add to result\n    if (tempList.size() == nums.length) {\n        result.add(new ArrayList<>(tempList));\n    }\n\n    for (int num : nums) {\n        // if already have the number, skip\n        if (tempList.contains(num)) {\n            continue;\n        }\n\n        tempList.add(num);\n\n        // continue adding next one\n        backtrack(result, tempList, nums);\n\n        // remove the last added one\n        tempList.remove(tempList.size() - 1);\n    }\n}\n```","tags":["Leetcode - Backtracking"],"categories":["Data Structure and Algorithms"]},{"title":"Divide-and-conquer Algorithm","url":"/Divide-and-conquer-Algorithm/","content":"## Basic Concept\nIn computer science, `divide-and-conquer` is an important algorithm. The literal explanation is \"divide and conquer\", which is to divide a complex problem into two or more identical or similar subproblems, and then divide the subproblems into smaller subproblems, until the final subproblem can be directly solved. The solution of the original problem is the combination of the solutions of the subproblems. This technique is the basis of many efficient algorithms, such as sorting algorithms (quick sort, merge sort), Fourier transform(fast Fourier transform), etc.\n\nThe computational time required for any problem that can be solved by a computer depends on its size. The smaller the scale of the problem, the easier it can be solved directly, and the less calculation time required to solve the problem. For example, for the ordering problem of n elements, when n = 1, no calculation is needed. When n = 2, only one comparison is needed to sort the order. When n = 3, you only need to make 3 comparisons, ... When n is large, the problem is not so easy to deal with. Sometimes it is quite difficult to directly solve a large-scale problem.\n\n## Basic ideas and strategies\nThe idea of the `divide-and-conquer` method is to **<font color=\"orange\">divide a large problem that is difficult to solve directly into some smaller and identical problems, so that each one can be solved</font>**.\n\nThe `divide-and-conquer` strategy is: **<font color=\"orange\">for a problem of size n, if the problem can be easily solved (for example, the size of n is small), solve it directly, otherwise it is decomposed into k small-scale sub-problems, which are mutually independently and in the same form as the original problem, solve these sub-problems recursively, and then combine the solutions of the sub-problems to obtain the solution of the original problem</font>**. This algorithm design strategy is called divide-and-conquer.\n\nIf the original problem can be divided into k sub-problems, 1 < k ≤ n, and these sub-problems are solvable, and the solutions of these sub-problems can be used to obtain the solution of the original problem, then this `divide-and-conquer` method is feasible. The subproblems generated by the `divide-and-conquer` method are often smaller models of the original problem, which facilitates the use of recursive techniques. In this case, repeated application of `divide-and-conquer` means we can make the sub-problem consistent with the original problem but its size is constantly shrinking, and eventually the sub-problem is reduced to a very easy solution. This naturally leads to a recursive process. **<font color=\"orange\">Divide-and-conquer and recursion are like twin brothers, which are often applied in algorithm design at the same time**<font color=\"orange\">, and many efficient algorithms are generated from it.\n\n## Scope of application\nThe problems that can be solved by the `divide-and-conquer` method generally have the following characteristics:\n* The problem can be `easily solved` by `reducing` the scale to a certain extent;\n* The problem can be decomposed into several smaller and identical problems, that is, the problem has `the optimal substructure property`;\n* The solutions of the sub-problems decomposed by the problem can be `combined into the solution` of the problem;\n* The sub-problems decomposed by this problem are independent, that is, there is `no common sub-sub-problem` among the sub-problems.\n\nMost problems satisfy the first characteristic, because the computational complexity of the problem generally increases as the problem size increases;\n\nThe second characteristic is the premise of applying the divide-and-conquer method. It is also sufficient for most problems. This feature reflects the application of recursive thinking.\n\n**<font color=\"orange\">The third feature is the key. Whether the divide-and-conquer method can be used depends entirely on whether the problem has the third feature. If the first and second features are available, and the third feature is not available, then the greedy or dynamic programming can be considered.**<font color=\"orange\">.\n\nThe fourth characteristic relates to the efficiency of the `divide-and-conquer` method. If the sub-problems are not independent, the `divide-and-conquer` method has to do a lot of unnecessary work and repeatedly solve common sub-problems. Although the `divide-and-conquer` method is available at this time, the `dynamic programming` method is generally better.\n\n## Steps to solve problems using divide-and-conquer\nThe divide-and-conquer method has three steps at each level of recursion:\n1. **Decomposition**: Decompose the original problem into several smaller, independent sub-problems in the same form as the original problem;\n2. **Solution**: If the sub-problem is small and can be easily solved, then directly solve it, otherwise recursively solve each sub-problem\n3. **Merge**: Combine the solutions of each sub-problem into the solution of the original problem.\n\nIts general algorithm design pattern is as follows:\n\n```\nDivide-and-Conquer (P)\n\n    1. if |P| ≤ n0\n\n    2. then return (ADHOC (P))\n\n    3. Decompose P into smaller subproblems P1, P2, ..., Pk\n\n    4. for i ← 1 to k\n\n        // Recursively solve Pi\n        5. do yi ← Divide-and-Conquer (Pi)\n\n    // Merge solutions\n    6. T ← MERGE (y1, y2, ..., yk)\n\n    7. return (T)\n```\n\n`|P|` represents the scale of the problem `P`; `n0` is a threshold value, which means that when the scale of the problem `P` does not exceed `n0`, the problem is easily solved directly, and it is not necessary to continue to decompose. `ADHOC(P)` is the basic sub-algorithm in this `divide-and-conquer` method, which is used to directly solve small-scale problems `P`. Therefore, when the scale of `P` does not exceed `n0`, it is directly solved by the algorithm `ADHOC(P)`. The algorithm `MERGE(y1, y2, ..., yk)` is a merged sub-algorithm in this `divide-and-conquer` method, which is used to merge the corresponding solutions y1, y2, ... of `P`'s subproblems P1, P2, ..., Pk ., yk for probblem `P`.\n\n## Complexity analysis of divide-and-conquer\nA `divide-and-conquer` method divides a problem of size `n` into `k` sub-problems of size `n/m` to solve. It is assumed that the decomposition threshold `n0 = 1` and the adhoc solution scale of 1 take `1 unit time`. It is further assumed that `f(n)` unit time is required to decompose the original problem into `k` sub-problems and merge the solutions of the `k` sub-problems into solutions of the original problem. Using `T(n)` to represent the calculation time required for this `divide-and-conquer` method to solve a problem of scale `|P| = n`, then:\n\n```\nT(n）= k*T(n/m)+f(n)\n```\n\nFind the solution to the equation by iteration:\n\nThe recursive equation and its solution only give the value of `T(n)` when `n` is equal to the `power of m`, but if `T(n)` is considered smooth enough, then `T(n)`'s growth rate can be estimated by the value of `T(n)` when `n` is equal to the `power of m`. It is generally assumed that `T(n)` rises monotonically, so that when `mi <= n < mi + 1`, `T(mi) ≤ T(n) < T(mi + 1)`.\n\n## Some classic problems that can be solved using divide-and-conquer\n1. Binary search\n2. Large integer multiplication\n3. Strassen matrix multiplication\n4. Checkerboard coverage\n5. Merge and sort\n6. Quick sort\n7. Linear time selection\n8. Closest point pair problem\n9. Round robin schedule\n10. Hanoi Tower\n\n## Thinking process when designing procedures based on divide-and-conquer\nIn fact, it is similar to the `mathematical induction` method, find the solution equation formula to solve this problem, and then design the recursive program according to the equation formula.\n\n1. Must found the solution for the minimum problem size\n2. Then consider the solution as the problem size increases\n3. After finding the recursive function to solve (various scales or factors), design the recursive program.","categories":["Data Structure and Algorithms"]},{"title":"Leetcode 22. Generate Parentheses","url":"/Leetcode-22-Generate-Parentheses/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nGive a number `n` and return all valid parenthetical matches, exactly the opposite of [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/).\n\n### Similar Questions\n* Medium - {% post_link Leetcode-17-Letter-Combinations-of-a-Phone-Number '17 Letter Combinations of a Phone Number' %}\n* Easy - [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)\n\n## Soultion - Brute Force\nEnumerate all cases, each of which has left and right parenthesis, a total of `2n` digits, so a total of 2<sup>2n</sup> cases.\n\n``` Java\npublic List<String> generateParenthesis(int n) {\n    List<String> results = new ArrayList<>();\n\n    generateAll(results, new char[n * 2], 0);\n\n    return results;\n}\n\nprivate void generateAll(List<String> result, char[] current, int pos) {\n    if (pos == current.length) {\n        if (isValid(current)) {\n            result.add(new String(current));\n        }\n    } else {\n        // if n-th digit is '('\n        current[pos] = '(';\n        generateAll(result, current, pos + 1);\n        current[pos] = ')';\n        // if n-th digit is ')'\n        generateAll(result, current, pos + 1);\n    }\n}\n\nprivate boolean isValid(char[] current) {\n    int balance = 0;\n\n    for (char c : current) {\n        if (c == '(') {\n            balance++;\n        } else {\n            balance--;\n        }\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```\n\nTime complexity: O(n) is needed to judge whether each case is legal, so the time complexity is O(2<sup>2n</sup>n)\n\nSpace complexity: O(2<sup>2n</sup>n), multiply by `n` because the length of each string is `2n`. In addition, this is assuming that all conditions are met, but it is not possible to meet all of them, and more accurate situations will be given later.\n\n## Solution\nIn previous solution, we keep adding left parentheses. In fact, if the left parenthesis exceeds `n`, it is definitely not a legal case. Because the legal case must be `n` left parentheses and `n` right parentheses.\n\nAnother case is that if the total number of right parentheses is greater than the total number of left parentheses in the process of adding parentheses, no matter what is added later, it cannot be a legal case. Because each right parenthesis must match a previous left parenthesis, if there are more right parentheses than left parentheses, then there must be a right parenthesis that does not match the left parenthesis, no matter how many left parentheses are added later, it is useless. For example, `n = 3`, there will be 6 parentheses in total. When we add `())` to 3 parentheses, there are 1 left parenthesis and 2 right parentheses. At this moment, the 3 parentheses behind it are doomed. Will not be a legal case anymore.\n\nBased on the two points above, as long as we avoid them, we can guarantee that the brackets we generate must be legal.\n\n``` Java\npublic List<String> generateParenthesis(int n) {\n    List<String> results = new ArrayList<>();\n\n    generateAll(results, \"\", 0, 0, n);\n\n    return results;\n}\n\nprivate void generateAll(List<String> result, String current, int left, int right, int n) {\n    if (current.length() == n * 2) {\n        result.add(current);\n    } else {\n        // add left '(' as many as possible\n        if (left < n) {\n            generateAll(result, current + \"(\", left + 1, right, n);\n        }\n\n        // add right ')'\n        if (right < left) {\n            generateAll(result, current + \")\", left, right + 1, n);\n        }\n    }\n}\n```\n\nThe execution order of the recursion as follows:\n\n```\n( -> (( -> ((( -> ((() -> ((()) -> ((())) -> add to result\n\n(( -> (() -> (()( -> (()() -> (()()) -> add to result\n\n(( -> (() -> (()) -> (())( -> (())() -> add to result\n\n( -> () -> ()( -> ()(( -> ()(() -> ()(()) -> add to result\n\n( -> () -> ()( -> ()() -> ()()( -> ()()() -> add to result\n```","tags":["Leetcode - Backtracking","Leetcode - String"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 11: Message-driven development - Stream","url":"/Spring-Cloud-11-Message-driven-development-Stream/","content":"Message-driven development has become one of the essential development methods for microservices architecture. This is because, 1. interface call development in traditional monolithic architecture development does not exist under the microservices architecture; 2. the development of microservices architecture requires reducing the direct dependency coupling of each microservice. If one microservice directly calls another one, then the two microservices will have a strong coupling through dependencies; 3. microservice's autonomy principle also strongly requires that microservices cannot call each other. Therefore, message-driven development has become an inevitable trend in the development of microservice architectures.\n\nLet's look at a scenario in the example project:\n* `Product-Service-Consumer` microservices need to be able to achieve autonomy and minimize dependence on `Procuct-Service`;\n* `Product-Service-Consumer` microservices need to ensure the efficiency of the service, the development team decided to cache the product data, so that only when the first load the product microservice is required to be called. When the user requests the product next time, the cache can be retrieved, thereby improving the efficiency of the service (as for the use of memory or `Redis` to implement caching, this is up to you).\n\nIf it is implemented according to the above scenario, the system can work stably in most cases. What should we do once the product is modified, we will never call the `Product-Service-Consumer` microservice in the `Procuct-Service` microservice. Is this makes the coupling tighter? Well, yes, now we can let the messages go at this time.\n\nBy introducing the message, the system architecture of our example project will become as shown in the following figure:\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nSpring Cloud have provided a very good set of components for the message development-`Stream`.\n\n## Example project\nWe need to modify the example project, which includes the following three steps:\n1. Install `Kafka` server;\n2. Change `Product-Service` microservices to send product messages;\n3. Change `Product-Service-Consumer` microservice to subscribe product messages.\n\n### Install Kafka server\nOur example will use `Kafka` as the message broker. `Kafka` message broker is very light and efficient. If you don't want to use `Kafka` then you can complete the docking with `RabbitMQ` as well, and the specific implementation of the business code does not need to be changed.\n\nHow to install and run the `Kafka` server is not described in detail here, I will have another post describing it. There are also very good documents on the Internet and the official, for example, [the official documentation](https://kafka.apache.org/quickstart).\n\n### Product-Service\n#### 1. Add Stream dependency\n``` xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-stream-kafka</artifactId>\n</dependency>\n```\n\n#### 2. application.properties\n```\n# =====================================================================================================================\n# == stream / kafka                                                                                                  ==\n# =====================================================================================================================\nspring.cloud.stream.bindings.output.destination=product-topic\nspring.cloud.stream.bindings.output.content-type=application/json\nspring.cloud.stream.kafka.binder.brokers=localhost\nspring.cloud.stream.kafka.binder.defaultBrokerPort=9092\n```\n\nHere we mainly set the address of the `Kafka` server, and which `topic` to send product messages. Here it is set to `product-topic`. However, we do not need to configure these, if not configured, then `Stream` will connect to `Kafka` server and create the corresponding `topic` according to the default configuration. However, the prerequisite for not configuring is that you did not change the port when installing the `Kakfa` server, and that the `Kafka` server and the `Product-Service` microservice are on the same server.\n\n#### 3. Construct product message\nWhen the product configuration changes, such as: modification, deletion, etc., a product message needs to be constructed, and then the message can be sent to the corresponding listening microservice for processing through `Kafka`. Therefore, the product message code to be constructed is as follows:\n\n``` Java\npublic class ProductMessage {\n    /** Message type：update, value: {@value} */\n    public static final String MA_UPDATE = \"update\";\n    /** Message type：delete, value: {@value} */\n    public static final String MA_DELETE = \"delete\";\n\n    // ========================================================================\n    // fields =================================================================\n    private String action;\n    private String itemCode;\n\n    public ProductMessage() {\n    }\n\n    public ProductMessage(String action, String itemCode) {\n        this.action = action;\n        this.itemCode = itemCode;\n    }\n\n    @Override\n    public String toString() {\n        return \"action: \" + this.action + \" itemCode: \" + this.itemCode;\n    }\n\n    public String getAction() {\n        return action;\n    }\n\n    public void setAction(String action) {\n        this.action = action;\n    }\n\n    public String getItemCode() {\n        return itemCode;\n    }\n\n    public void setItemCode(String itemCode) {\n        this.itemCode = itemCode;\n    }\n}\n```\n\nThe product message is very simple and contains only two fields: `action` and `itemCode`. The meaning represented is as follows:\n* **action**: indicates what the message is, such as a product update message or a product delete message;\n* **itemCode**: the item number (or product ID) of the item that was changed or deleted.\n\nYou may be wondering here, why the product message only contains these two fields, is it enough? In general, these two fields are enough for the message, but in the formal production environment, we will add other fields, which will not be discussed here. In addition, when the listener listens to the message, it can perform related processing according to the message type and the item code of the product. For example, the `Product-Service-Consunmer` microservice will re-load the product information by remotely requesting the product microservice according to the product item code.\n\n#### 4. Implement message sending\nWhen the user changes or deletes the product in the `Product-Service` microservice, the above product message needs to be constructed and sent. The corresponding code is as follows:\n\n``` Java\n@Service\npublic class ProductService {\n    private Logger logger = LoggerFactory.getLogger(ProductService.class);\n\n    private Source source;\n    private List<ProductDto> productList;\n\n    @Autowired\n    public ProductService(Source source) {\n        this.source = source;\n        this.productList = this.buildProducts();\n    }\n\n    /**\n     * Get product list\n     */\n    public List<ProductDto> findAll() {\n        return this.productList;\n    }\n\n    /**\n     * get product by item\n     */\n    public ProductDto findOne(String itemCode) {\n        for (ProductDto productDto : this.productList) {\n            if (productDto.getItemCode().equalsIgnoreCase(itemCode))\n                return productDto;\n        }\n\n        return null;\n    }\n\n    /**\n     * update or save product\n     */\n    public ProductDto save(ProductDto productDto) {\n        for (ProductDto sourceProductDto : this.productList) {\n            if (sourceProductDto.getItemCode().equalsIgnoreCase(productDto.getItemCode())) {\n                sourceProductDto.setName(sourceProductDto.getName() + \"-new\");\n                sourceProductDto.setPrice(sourceProductDto.getPrice() + 100);\n                productDto = sourceProductDto;\n                break;\n            }\n        }\n\n        // send message\n        this.sendMsg(ProductMessage.MA_UPDATE, productDto.getItemCode());\n\n        return productDto;\n    }\n\n    /**\n     * Implement send message\n     */\n    protected void sendMsg(String msgAction, String itemCode) {\n        ProductMessage productMsg = new ProductMessage(msgAction, itemCode);\n        this.logger.debug(\"Send message:{} \", productMsg);\n\n        // 发送消息\n        this.source.output().send(MessageBuilder.withPayload(productMsg).build());\n    }\n\n    protected List<ProductDto> buildProducts() {\n        List<ProductDto> products = new ArrayList<>();\n        products.add(new ProductDto(\"item-1\", \"test-1\", \"brand1\", 100));\n        products.add(new ProductDto(\"item-2\", \"test-2\", \"brand2\", 200));\n        products.add(new ProductDto(\"item-3\", \"test-3\", \"brand3\", 300));\n        products.add(new ProductDto(\"item-4\", \"test-4\", \"brand4\", 400));\n        products.add(new ProductDto(\"item-5\", \"test-5\", \"brand5\", 500));\n        products.add(new ProductDto(\"item-6\", \"test-6\", \"brand6\", 600));\n\n        return products;\n    }\n}\n```\n\nSending a message is very simple, we just need to call the `source.output().send()` method to send the message. You may be a little confused here, what is the `source`, and where does it pop out. Don't worry, now you just need to understand that this is an abstract message sending interface provided by `Spring Cloud Stream`. You can get a message sending channel through `output()` in this interface, and then you can `send()` the message to that channel. We will talk about the specific principle later.\n\n#### 5. Add message sending endpoint\nWe need to add an endpoint to simulate user saving/updating product information. In the above code, we can know that when we save/update the product information, the product message will be sent, so the new endpoint only needs to call this method. The specific code is as follows:\n\n``` Java\n@RestController\n@RequestMapping(\"/products\")\npublic class ProductEndpoint {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ProductEndpoint.class);\n\n    @Autowired\n    ProductService productService;\n\n    @Value(\"${server.port}\")\n    private int serverPort = 0;\n\n    @RequestMapping(method = RequestMethod.GET)\n    public List<ProductDto> list() {\n        LOGGER.info(\"Server port {}\", serverPort);\n\n        return productService.findAll();\n    }\n\n    @RequestMapping(value = \"/{itemCode}\", method = RequestMethod.GET)\n    public ProductDto detail(@PathVariable String itemCode) {\n        LOGGER.info(\"Server port {}\", serverPort);\n\n        return productService.findOne(itemCode);\n    }\n\n    @RequestMapping(value = \"/{itemCode}\", method = RequestMethod.POST)\n    public ProductDto save(@PathVariable String itemCode) {\n        ProductDto productDto = this.productService.findOne(itemCode);\n\n        if (null != productDto) {\n            this.productService.save(productDto);\n        }\n        \n        return productDto;\n    }\n}\n```\n\n#### 6. Binding Message Channel\nLastly, we need to bind `Kafka` message broker when the microservice starts. The implementation code is as follows:\n\n``` Java\n@EnableDiscoveryClient\n@EnableBinding(Source.class)\n@SpringBootApplication\npublic class ProductServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ProductServiceApplication.class, args);\n    }\n}\n```\n\nJust add a `@EnableBinding(Source.class)` annotation to the application main class.\n\nOk, now we have implemented the message sending of the `Product-Service` microservice. Let's complete the message subscribbing in the `Product-Service-Consumer` microservice.\n\n### Product-Service-Consumer\n#### 1. Add Stream dependency\nThis is the same as `Product-Service`.\n\n#### 2. application.properties\n```\n# =====================================================================================================================\n# == stream / kafka                                                                                                  ==\n# =====================================================================================================================\nspring.cloud.stream.bindings.input.destination=product-topic\nspring.cloud.stream.bindings.input.content-type=application/json\nspring.cloud.stream.bindings.input.group=mallWebGroup\nspring.cloud.stream.kafka.binder.brokers=localhost\nspring.cloud.stream.kafka.binder.defaultBrokerPort=9092\n```\n\nThis configuration is similar to the `Product-Service` microservice, but we need to change the `output` to `input`, indicating that the message input channel is configured here.\n\nIn addition, we also added a group configuration attribute. The specific meaning of this attribute will be explained later.\n\n#### 3. Copy ProductMessage to this project\n\n#### 4. Implement message subscribbing\nUsing `Stream`, we only need to add the `@StreamListener` annotation to the corresponding listening method. The specific code is as follows:\n\n``` Java\n@EnableBinding(Sink.class)\npublic class ProductMessageListener {\n    protected Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @Qualifier(\"PRODUCT-SERVICE\")\n    @Autowired\n    protected ProductService productService;\n\n    @StreamListener(Sink.INPUT)\n    public void onProductMessage(ProductMessage productMsg) {\n        if (ProductMessage.MA_UPDATE.equalsIgnoreCase(productMsg.getAction())) {\n            this.logger.debug(\"Receive product update message, item code: {}\", productMsg.getItemCode());\n            // request new product info\n            Product productDto = this.productService.loadByItemCode(productMsg.getItemCode());\n            if (null != productDto)\n                this.logger.debug(\"Update product info:{}\", productDto);\n            else\n                this.logger.debug(\"Item code:{} doesn't exist\", productMsg.getItemCode());\n        } else if (ProductMessage.MA_DELETE.equalsIgnoreCase(productMsg.getAction())) {\n            this.logger.debug(\"Receive product delete message: {}\", productMsg.getItemCode());\n        } else {\n            this.logger.debug(\"Unknown product info: {}\", productMsg);\n        }\n    }\n}\n```\n\nThis code is very simple to implement a product message monitoring method `onProductMsg`, and in this method different processing according to the message type.\n\nSimilarly, for `Sink`, I won't go into details here. You just need to understand that this is an abstract message listening interface provided by `Spring Cloud Stream`. When the interface class is added the `@StreamListener` annotation, `Stream` will send `Kafka` to add a message subscription. The subscribed message topic is the `product-topic` that we specified in the configuration file. When there is a message in the topic, `Stream` will deserialize the message in the topic into `ProductMessage`, and then execute the specific message listening method.\n\n### Testing\nStart the service in order:\n1. Kafka\n2. Service-discovery\n3. Product-Service\n4. Product-Service-Consumer\n\nIn the console of the `Product-Service` microservice, you can see output similar to the following:\n\n```\n2020-03-01 13:46:07.599 DEBUG             44575 --- [nio-2100-exec-1] o.s.web.servlet.DispatcherServlet        : POST \"/products/item-2\", parameters={}\n2020-03-01 13:46:07.656  INFO             44575 --- [nio-2100-exec-1] s.productservice.service.ProductService  : Send message:action: update itemCode: item-2 \n```\n\nFrom the output log, you can see that the product message has been sent to the message broker. If we look at the console of the `Product-Service-Consumer` microservice, we can see the output of the following figure:\n\n```\n2020-03-01 13:46:08.005  INFO             44577 --- [container-0-C-1] istener$$EnhancerBySpringCGLIB$$cb550e3b : Receive product update message, item code: item-2\n2020-03-01 13:46:08.005  INFO             44577 --- [container-0-C-1] istener$$EnhancerBySpringCGLIB$$cb550e3b : Update product info:springclouddemo.mall.entity.Product@57708467\n```\n\nIt can be seen from the log output that the `Product-Service-Consumer` microservice has been able to correctly receive the product message, and then re-requested and obtained the latest information of the product.\n\n## Details of Spring Cloud Stream\nFrom the core principle of `Spring Cloud Stream`, `Stream` provides an abstraction layer for sending and receiving messages with message broker. Through this abstraction layer, the direct coupling between messaging in the business and the middleware actually used is stripped, so that we can easily interface with various message broker, and it is also very easy to replace the message broker. This is the same as using the `ORM` framework, which can smoothly switch between multiple databases.\n\n### Stream application model\nStream provides the following models\n\n{% asset_img 2.png %}\n<br/>\n<br/>\n\nThere are several core concepts on the model diagram:\n* **Source**: When you need to send a message, you need to go through the `Source`. The `Source` will serialize the message (POJO object) we want to send (the default is converted to a `JSON` format string), and then send these data to the `Channel`;\n* **Sink**: When we need to listen to the message, we need to use `Sink`. `Sink` is responsible for obtaining the message from the message `Channel`, deserializing the message into a message object (POJO object), and then handing it to the specific message monitoring process for processing;\n* **Channel**: message `Channel` is one of the abstractions of `Stream`. Usually we need to specify the `topic` queue name when sending or listening to the message broker, but once we need to change the topic name, we need to modify the code of message sending or message monitoring, but through `Channel` abstraction, our code only needs to use the `Channel`. The specific `Channel` corresponds to the `topic`, which can be specified in the configuration file, so that when the `topic` changes, we don't need to make any changes to the code, so as to achieve the decoupling.\n* **Binder**: Another abstraction layer in `Stream`. Integration with different message broker can be achieved through different `Binders`. For example, in the above example, we are using `Binder` for `Kafka`. `Binder` provides a unified messaging interface, so that we can deploy different message broker according to actual needs, or adjust our configuration based on the messaging broker deployed in actual production.\n\n### Stream application principle\nFrom the above, we understand the application model of `Stream`, and we are clear about the message sending logic and process. So how do we operate during the actual message sending and listening?\n\nIn use, Stream provides the following three annotations:\n* `@Input`: create a message input channel for message monitoring;\n* `@Output`: create a message output channel for message sending;\n* `@EnableBinding`: Establish a binding to the message channel.\n\nWhen using it, we can create multiple channels through `@Input` and `@Output`. Using these two annotations to create channels is very simple. You only need to annotate them to the corresponding method of the interface, and you don't need to implement the annotation specifically. . When the Stream framework is started, the corresponding implementation is generated through dynamic code generation technology based on these two annotations, and injected into the Spring application context, so that we can use it directly in the code.\n\n#### Output annotation\nFor the `@Output` annotation, the return value of the annotated method must be `MessageChannel`, and `MessageChannel` is the channel for sending specific messages. For example, the following code:\n\n``` Java\npublic interface ProductSource {\n    @Output\n    MessageChannel hotProducts();\n\n    @Output\n    MessageChannel selectedProducts();\n}\n```\n\nWe can send messages through the message channel created by `ProductSource`.\n\n#### Input annotation\nFor the `@Input` annotation, the return value of the annotated method must be a `SubscribableChannel`, and the `SubscribableChannel` is the channel for message monitoring. For example, the following code:\n\n``` Java\npublic interface ProductSink {\n    @Input\n    SubscribableChannel productOrders();\n}\n```\n\nWe can listen to messages through the message channel created by `ProductSink`.\n\n#### About Input, Output out of the box\nMaybe you are a bit confused. Before in the example, we used `Source` and `Sink` in the code. So what is the relationship between these two classes and the annotations above? Let's take a look at the source code of these two interfaces:\n\n``` Java\n// Source\npublic interface Source {\n\n  String OUTPUT = \"output\";\n\n  @Output(Source.OUTPUT)\n  MessageChannel output();\n}\n\n// Sink\npublic interface Sink {\n\n  String INPUT = \"input\";\n\n  @Input(Sink.INPUT)\n  SubscribableChannel input();\n}\n```\n\n`@Input` and `@Output` are annotations of the core application of `Stream`, while `Source` and `Sink` are just two interfaces provided by `Stream` for us out of the box. With or without these interfaces, we can use `Stream` normally.\n\nIn addition, `Stream` also provides an out-of-the-box interface `Processor`, the source code is as follows:\n\n``` Java\npublic interface Processor extends Source, Sink {\n}\n```\n\nThat is to say, `Processor` can be used as message sending and message listening at the same time. This interface will be very useful when we develop message pipeline type applications.\n\n#### Custom message channel name\nEarlier, we talk abbout message `Channel` is an abstraction of `Stream`. Through this abstraction, you can avoid coupling with the specific `topic` of message broker. So what is going on? From the `Source` and `Sink` source code, you can see that the annotated `@Output` and `@Input` annotations have a parameter, which is output and input respectively. At this time, you can observe our previous configuration:\n\n```\n# prodcut-service\nspring.cloud.stream.bindings.output.destination=product-topic\nspring.cloud.stream.bindings.output.content-type=application/json\n\n# prodcut-service-consumer\nspring.cloud.stream.bindings.input.destination=product-topic\nspring.cloud.stream.bindings.input.content-type=application/json\nspring.cloud.stream.bindings.input.group=mallWebGroup\n```\n\nFrom the configuration, you can see the configuration of the `destination` property, which specifies the output and inout, respectively, the name of the message channel used in the `Stream`. Therefore, we can set the name of the message channel through these two annotations, such as:\n\n``` Java\npublic interface ProductProcessor {\n    @Output(\"pmsoutput\")\n    MessageChannel productOutput();\n\n    @Input(\"pmsinput\")\n    SubscribableChannel input();\n}\n```\n\nIn this way, when we use the `ProductProcessor` interface to implement message sending and listening, we need to configure it in the configuration file as follows:\n\n```\n# Send\nspring.cloud.stream.bindings.pmsoutput.destination=product-topic\nspring.cloud.stream.bindings.pmsoutput.content-type=application/json\n\n# Subscribe\nspring.cloud.stream.bindings.pmsinput.destination=product-topic\nspring.cloud.stream.bindings.pmsinput.content-type=application/json\nspring.cloud.stream.bindings.pmsinput.group=mallWebGroup\n```\n\n#### Binding\nNow that both the message sending channel and the listening channel have been created, you can connect them to specific message broker to complete the sending and monitoring of messages, and the `@EnableBinding` annotation is used to implement this function. The specific usage is as follows:\n\n``` Java\n// Send binding\n@EnableBinding(Source.class)\npublic class Application {\n\n}\n\n// Listening\n@EnableBinding(Sink.class)\npublic class ProductMsgListener {\n\n}\n```\n\nIt should be noted that `@EnableBinding` can bind multiple interfaces at the same time, as follows:\n\n``` Java\n@EnableBinding(value={ProductSource.class, ProductSink.class})\n```\n\n#### Use channels directly\nThe code we sent message previously is as follows:\n\n``` Java\nprotected void sendMsg(String msgAction, String itemCode) {\n    ProductMessage productMsg = new ProductMessage(msgAction, itemCode);\n    this.logger.info(\"Send message:{} \", productMsg);\n\n    // Send\n    this.source.output().send(MessageBuilder.withPayload(productMsg).build());\n}\n```\n\nSince the `MessageChannel` provided by `@Output` is used when the message is sent, can we use it directly? Indeed, this is possible. We can change the above code to the following:\n\n``` Java\n@Service\npublic class ProductService {\n    protected Logger logger = LoggerFactory.getLogger(ProductService.class);\n\n    private MessageChannel output;\n    private List<ProductDto> productList;\n\n    @Autowired\n    public ProductService(MessageChannel output) {\n        this.output = output;\n        this.productList = this.buildProducts();\n    }\n    \n     // Ignore other code\n    protected void sendMsg(String msgAction, String itemCode) {\n        ProductMsg productMsg = new ProductMsg(msgAction, itemCode);\n        this.logger.debug(\"Send message:{} \", productMsg);\n\n        // 发送消息\n        this.output.send(MessageBuilder.withPayload(productMsg).build());\n    }\n}\n```\n\nBy default the `Id` of the `MessageChannelBean` created by `Stream` is the method name, but if we add a name definition to the `@Output` annotation:\n\n``` Java\npublic interface ProductSource {\n    @Output(\"pmsoutput\")\n    MessageChannel output();\n}\n```\n\nThen at this time `Stream` will use `pmsoutput` as the Bean's `Id`, and our code needs to be as follows:\n\n``` Java\n@Autowired\npublic ProductService(@Qualifier(\"pmsoutput\") MessageChannel output) {\n    this.output = output;\n    this.productList = this.buildProducts();\n}\n```\n\nCheck out the source code here: [Stream demo](https://github.com/nicklee1006/SpringCloudDemo/tree/master/stream)","categories":["Spring Cloud"]},{"title":"Leetcode 17. Letter Combinations of a Phone Number","url":"/Leetcode-17-Letter-Combinations-of-a-Phone-Number/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nGiven a string of numbers, each number can represent several letters under a number key. Return all possible composition of the letters under these numbers.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-22-Generate-Parentheses '22. Generate Parentheses' %}\n* Medium - {% post_link Leetcode-39-Combination-Sum '39. Combination Sum' %}\n* Easy - [401. Binary Watch](https://leetcode.com/problems/binary-watch/)\n\n## Soultion\nThink of the string `23` as `[\"a\", \"b\", c]` * `[\"d\", \"e\", \"f\"]`, and multiplication can be achieved with two for loops. See the code. Should be easy enough to understand.\n\n``` Java\npublic List<String> letterCombinations(String digits) {\n    if (digits.length() == 0) {\n        return new ArrayList<>();\n    }\n\n    char[] digitsChar = digits.toCharArray();\n\n    // define the mapping relationship between number and char\n    Map<Integer, List<String>> keyMap = new HashMap<>();\n    keyMap.put(2, Arrays.asList(\"a\", \"b\", \"c\"));\n    keyMap.put(3, Arrays.asList(\"d\", \"e\", \"f\"));\n    keyMap.put(4, Arrays.asList(\"g\", \"h\", \"i\"));\n    keyMap.put(5, Arrays.asList(\"j\", \"k\", \"l\"));\n    keyMap.put(6, Arrays.asList(\"m\", \"n\", \"o\"));\n    keyMap.put(7, Arrays.asList(\"p\", \"q\", \"r\", \"s\"));\n    keyMap.put(8, Arrays.asList(\"t\", \"u\", \"v\"));\n    keyMap.put(9, Arrays.asList(\"w\", \"x\", \"y\", \"z\"));\n\n    List<String> result = new ArrayList<>(keyMap.get(Character.getNumericValue(digitsChar[0])));\n\n    for (int i = 1; i < digitsChar.length; i++) {\n        int digit = Character.getNumericValue(digitsChar[i]);\n\n        result = multipleStrings(result, keyMap.get(digit));\n    }\n\n    return result;\n}\n\nprivate List<String> multipleStrings(List<String> a, List<String> b) {\n    List<String> result = new ArrayList<>();\n\n    for (String tempA : a) {\n        for (String tempB : b) {\n            result.add(tempA + tempB);\n        }\n    }\n\n    return result;\n}\n```\n\n## Solution - Iteration\nMainly used LinkedList\n\n``` Java\nLinkedList<String> result = new LinkedList<>();\n\nif (digits.length() == 0) {\n    return result;\n}\n\nString[] mapping = new String[]{\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n\nresult.add(\"\");\n\nfor (int i = 0; i < digits.length(); i++) {\n    int x = Character.getNumericValue(digits.charAt(i));\n\n    // check the length of elements at the head of the list\n    while (result.peek().length() == i) {\n        String temp = result.remove();\n\n        for (char c : mapping[x].toCharArray()) {\n            result.add(temp + c);\n        }\n    }\n}\n\nreturn result;\n```\n\nIf it is `23`, then:\n\n`result` becomes `a, b, c` after the first `for loop` ends;\n\nThe 1st `while loop` of the second `for loop` pop `a` out, adds `d`, `e`, `f` and joins with `a`. `result` becomes `b c ad ae af`\n\nThe 2nd `while loop` of the second `for loop` pop `b` out, adds `d`, `e`, `f` and joins with `b`. `result` becomes `c ad ae af bd be bf`\n\nThe 3rd `while loop` of the second `for loop` pop `c` out, adds `d`, `e`, `f` and joins with `c`, `result` becomes `ad ae af bd be bf cd ce cf`\n\nIn this case, the element length of the queue is no longer equal to 1, and the while loop is out.","tags":["Leetcode - Backtracking","Leetcode - String"],"categories":["Data Structure and Algorithms"]},{"title":"Greedy Algorithm","url":"/Greedy-Algorithm/","content":"## Basic Concept\nThe so-called `greedy algorithm` means that when solving a problem, always makes the best choice in the current view. In other words, without considering the global optimality. The choice is only **<font color=\"orange\">a local optimal solution</font>** in a certain sense.\n\nGreedy algorithms do not have a fixed algorithm framework. The key to algorithm design is the choice of greedy strategies. It must be noted that the greedy algorithm does not obtain the global optimal solution to all problems, and the greedy strategy chosen must have no aftereffect, that is, the process after a certain state does not affect the previous state, and is only related to the current state.\n\n**<font color=\"orange\">Therefore, we must carefully analyze whether the greedy strategy adopted has no aftereffects</font>**.\n\n## Basic idea of greedy algorithm\n1. Establish a mathematical model to describe the problem.\n2. Divide the problem into several sub-problems.\n3. Solve each sub-problem to get the local optimal solution.\n4. Combine the local optimal solution of the sub-problems into a solution of the original problem.\n\n## Scope of application\nThe prerequisite of greedy strategy is that a local optimal strategy can lead to a global optimal solution.\n\nIn practice, **<font color=\"orange\">greedy algorithms are rarely used</font>**. Generally, to analyze whether a problem is applicable to greedy algorithms, you can first select several example data of the problem to analyze and then make a judgment.\n\n## Implementation framework of greedy algorithm\n```\nStart with an initial solution to the problem\n\nwhile (can move forward to a given overall goal)\n{\n    Use feasible decision to find a local optimal solution;\n}\n\nCombining all local optimal solution and get a global optimal solution\n```\n\n## Choice of greedy strategies\nBecause the greedy algorithm can only achieve the global optimal solution through the strategy of get the local optimal solution, we must pay attention to determine whether the problem is suitable for the greedy algorithm, and whether the solution is the optimal solution of the problem.\n\n## Example\nThe following is a problem that can be solved by the greedy algorithm. The greedy solution is good, but it is not the optimal solution.\n\n### Knapsack problem\nThere is a backpack, and the capacity of the backpack is `M = 150`. There are `7` items, and the items can be divided into any size.\n\nIt is required to maximize the total value of the items in the backpack, but not exceed the total capacity.\n\n| Item   | A  | B  | C  | D  | E  | F  | G  |\n| ----   |:--:| --:| --:| --:| --:| --:| --:|\n| Weight | 35 | 30 | 60 | 50 | 40 | 10 | 25 |\n| Value  | 10 | 40 | 30 | 50 | 35 | 40 | 30 |\n\n### Analysis\nObjective function: maximize `Σpi`\n\nThe constraint is that the total weight of the loaded items does not exceed the capacity of the backpack: `∑wi <= M (M = 150)`\n\n1. According to the greedy strategy, every time you pick the item with the highest value and put it in the backpack, is the result the best?\n2. Can I get the optimal solution every time I load the smallest weighted item?\n3. Each time you select the item with the largest unit weight value, it becomes a strategy to solve this problem.\n\nIt is worth noting that the greedy algorithm is not completely unfeasible. Once the greedy strategy is proven, it is an efficient algorithm.\n\nThe greedy algorithm is still one of the most common algorithms, because it is simple and easy to implement, and it is not very difficult to construct a greedy strategy.\n\nUnfortunately, it needs to be proved before it can be applied to the problem.\n\nGenerally speaking, the proof of the greedy algorithm revolves around: **<font color=\"orange\">the optimal solution of the entire problem must be obtained from the optimal solution of the subproblems in the greedy strategy</font>**.\n\nFor the three greedy strategies in the example problem, none of them can be established (cannot be proven), and the explanation is as follows:\n\n**<font color=\"orange\">1. Greedy strategy: select the one with the highest value</font>**\n\nCounter example:\n\nW = 30\n\n| Item   | A  | B  | C  |\n| ----   |:--:| --:| --:|\n| Weight | 28 | 12 | 12 |\n| Value  | 30 | 20 | 20 |\n\nAccording to the strategy, the `item A` is selected first, and then it cannot be selected anymore. However, it is better to select `B` and `C`.\n\n**<font color=\"orange\">2. Greedy strategy: choose the smallest weight</font>**\n\nThe counter example is similar to that of the first strategy.\n\n**<font color=\"orange\">3. Greedy strategy: Select the item with the largest value per unit weight</font>** \n\nCounter example:\n\nW = 30\n\n| Item   | A  | B  | C  |\n| ----   |:--:| --:| --:|\n| Weight | 28 | 20 | 10 |\n| Value  | 28 | 20 | 10 |\n\nAccording to the strategy, the three items have the same unit weight value, and the program cannot make a judgment based on the existing strategy. If `A` is selected, the answer is wrong.","tags":["Leetcode - Greedy"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 86. Partition List","url":"/Leetcode-86-Partition-List/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nThe question is essentially the partition of quick-sort. The linked list is divided into two parts, one part is less than the partition point `x`, and the other part is greater than or equal to the partition point `x`.\n\n## Solution\nLooking at the quick-sort algorithm. In the quick-sort, we used two pointers for pivoting. One pointer indicates that the number before the pointer is less than the pivot point. The other pointer traverses the array.\n\n```\n1 4 3 2 5 2  x = 3\n  ^   ^\n  i   j\n\nelements before i are less than pivot point 3\nj means the current traverse point\nwhen j point to a number that is less than pivot point, then we exchange the value at i and j, and move forward i\n\n1 2 3 4 5 2  x = 3\n    ^   ^\n    i   j\n\nThen just continue traversing\n```\n\nThis question is just replacing array with linked list, and the question requires that the relative position of the numbers cannot be changed. So we must not use the exchange strategy, let alone the linked list exchange is more troublesome. In fact, we can just use the insert.\n\nSimilarly, a pointer is used to record the end of the linked list that is currently smaller than the pivot point, and another pointer is used to traverse the linked list. Each time we meet a number less than the pivot point, it is inserted into the end of the linked list and the end pointer is updated. We can use a dummy node to reduce the judgment of boundary conditions.\n\n``` Java\n// pivot node, first element that is >= x\nListNode pivot = head;\n\n// dummy node\nListNode dummyHead = new ListNode(0);\ndummyHead.next = head;\n\nListNode previousPivot = dummyHead;\n\n// find the pivot value\nwhile (pivot != null) {\n    if (pivot.val >= x) {\n        break;\n    } else {\n        previousPivot = pivot;\n        pivot = pivot.next;\n    }\n}\n\n// no value >= x or pivot is already the end, return list itself\n// no need to modify\nif (pivot == null || pivot.next == null) {\n    return head;\n}\n\n// start from pivot, move all smaller node before pivot\nListNode current = pivot.next;\nListNode previous = pivot;\n\nwhile (current != null) {\n    // >= x, move to next\n    if (current.val >= x) {\n        previous = current;\n        current = current.next;\n    } else {\n        final ListNode temp = current.next;\n\n        previousPivot.next = current;\n        current.next = pivot;\n        previousPivot = current;\n\n        previous.next = temp;\n        current = temp;\n    }\n}\n\nreturn dummyHead.next;\n```\n\nTime complexity: O(n).\n\nSpace complexity: O(1).","tags":["Leetcode - Linked List","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 10: Unified Configuration Center","url":"/Spring-Cloud-10-Unified-Configuration-Center/","content":"In monolithic applications, we often use a configuration file (application (*). Properties (yml)) to manage all the configuration of the application. These profiles are very good at their role in monolithic applications, and they don't make us feel a headache. However, with the introduction of the microservice framework, the number of microservices will continue to increase in our products. Previously, we focused on the scalability and extensibility of the system, but then the problems of configuration management were exposed. At first, the microservers managed their own configurations. There was no problem in the development stage, but in the production environment management, it will be a headache. If you want to update a configuration on a large scale, you can imagine the difficulties.\n\nTo this end, in a distributed system, Spring Cloud provides a Config sub-project. The core of this project is the configuration center, which implements configuration services through one server and multiple clients. We can use a configuration server to centrally manage various environment profiles for all services. The configuration service center uses `Git` for storage by default, so we can easily deploy and modify it, and we can version control the environment configuration.\n\n`Spring Cloud Config` has features such as centralization, version control, support for dynamic updates, and language independence. Its characteristics includes:\n* Provide server and client support (`Spring Cloud Config Server` and `Spring Cloud Config Client`);\n* Centralized management of application configuration in a distributed environment;\n* Based on the Spring environment, it achieves seamless integration with Spring applications;\n* Programs that can be used in any language development;\n* The default implementation is based on `Git` repositories (also supports `SVN`), so that version management can be performed;\n\nThe structure diagram of `Spring Cloud Config` is as follows:\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nWe can see that `Spring Cloud Config` has two roles (similar to `Eureka`): `Server` and `Client`. As the server of the configuration center, `Spring Cloud Config Server` assumes the following functions:\n* Update the `Git` repository copy when pulling the configuration to ensure that the configuration is up to date;\n* Support loading configuration from yml, json, properties and other files;\n* Service discovery can be implemented with `Eureke`, and configuration push updates can be implemented with `Cloud Bus` (which I will explain in detail later);\n* The default configuration store is based on a `Git` repository (can be switched to `SVN`), which supports configuration version management.\n\nFor the` Spring Cloud Config Client`, it is very convenient. We only need to add which configuration file on the Config Server to the startup configuration file.\n\n## Example project\n### Config-Server\n#### 1. Pom.xml\n`Config-Server` is a standard Spring Boot application\n\n``` Xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-config-server</artifactId>\n    </dependency>\n</dependencies>\n```\n\n#### 2. Main application\n``` Java\n@SpringBootApplication\n@EnableConfigServer\npublic class ConfigServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConfigServerApplication.class, args);\n    }\n}\n```\n\nAdd `@EnableConfigServer`, others are consistent with previous applications.\n\n#### 3. application.properties\n```\nserver.port=8280\n\nspring.application.name=config-server\n\nspring.cloud.config.server.git.uri=https://github.com/nicklee1006/SpringCloudDemoSampleConfig\nspring.cloud.config.server.git.username=your git username\nspring.cloud.config.server.git.password=your git password\n```\n\nThe most important thing here is to configure the Git repository address and login username and password.\n\n#### 4. Sample config file\nWe add a sample configuration file to the SpringCloudDemoSampleConfig repository.\n\nsample-service.properties\n```\nfoo = bar\n```\n\nsample-service-dev.properties\n```\nbar = 12345\n```\n\n#### 5. Test\nStart `service-discovery` and `config-server`. In the terminal we enter the following command:\n\n``` bash\ncurl localhost:8280/sample-service/dev\n```\n\nThe following will be output in the terminal:\n\n```\n{\"name\":\"sample-service\",\"profiles\":[\"dev\"],\"label\":null,\"version\":\"17ca16db404875d8b7ab57c9bfce33b45557114f\",\"state\":null,\"propertySources\":\n    [\n        {\"name\":\"https://github.com/nicklee1006/SpringCloudDemoSampleConfig/sample-service-dev.properties\",\"source\":{\"bar\":\"12345\"}},\n        {\"name\":\"https://github.com/nicklee1006/SpringCloudDemoSampleConfig/sample-service.properties\",\"source\":{\"foo\":\"bar\"}}\n    ]\n}\n```\n\nHere we can see that the configuration file we submitted to Git can be correctly read by `config-server`.\n\n#### config-server default configuration\nWhen we look at the source code, we find that there is a default configuration file `configserver.yml` in the `spring-cloud-config-server.jar` package, which means that when we set `spring.application.name = configserver`, the configuration will be loaded by default. The configuration file is as follows:\n\n``` yaml\ninfo:\n  component: Config Server\nspring:\n  application:\n    name: configserver\n  jmx:\n    default_domain: cloud.config.server\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://github.com/spring-cloud-samples/config-repo\n          repos:\n            - patterns: multi-repo-demo-*\n              uri: https://github.com/spring-cloud-samples/config-repo\n\nserver:\n  port: 8888\nmanagement:\n  context_path: /admin\n```\n\nPort `8888` is used by default, and the configuration file is found from the Git repository at h`ttps://github.com/spring-cloud-samples/config-repo`.\n\n### config-client\n`config-client` can be any application based on `Spring boot`. Here we build a very simple web project.\n\n#### 1. pom.xml\n``` xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-config</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n#### 2. Main application\n``` Java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class ConfigClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConfigClientApplication.class, args);\n    }\n}\n```\n\n#### 3. Controller\nThe main purpose of this controller is to verify that we can get the configuration content from the Git repository.\n\n``` Java\n@RestController\n@RequestMapping(\"/cfg\")\npublic class ConfigController {\n    @Value(\"${foo}\")\n    String foo;\n\n    @Value(\"${bar}\")\n    String bar;\n\n    @RequestMapping(value = \"/foo\")\n    public String foo(){\n        return foo + \"——\" + bar;\n    }\n}\n```\n\n#### 4. bootstrap.properties\n```\nserver.port=8080\n\nspring.application.name=sample-service\nspring.cloud.config.profile=dev\nspring.cloud.config.uri= http://localhost:8280/\n```\n\nDefines the name and profile of the microservice and the address of the configuration server.\n\n> Note: These configurations cannot be configured in the `application.properties` file, because there is a boot context and application context when Spring Boot is started. Only when the configuration server information is defined in the boot context can the configuration information be obtained from the configuration server. Otherwise, when the service starts, it will report an error that the foo variable definition cannot be found.\n\n#### 5. Test\nStart `config-client` and visit: http://localhost:8080/cfg/foo:\n{% asset_img 2.png %}\n<br/>\n<br/>\n\nIt indicates that our `config-client` has successfully obtained the configuration data from the `config-server`.\n\n### Spring project configuration load order\n* Command line arguments\n* `SPRING_APPLICATION_JSON` parameter\n* Load JNDI properties from `java:comp/env`\n* Java system properties (`System.getProperties()`)\n* Operating system environment variables\n* If configured using random.* Properties, use `RandomValuePropertySource` to generate\n* External application-specific configuration files, such as `application-{profile}.properties` or YAML variants\n* Internal application-specific profile files such as: `application-{profile}.properties` or YAML variants\n* External application configuration files, such as `application.properties` or YAML variants\n* Internal application configuration files such as: `application.properties` or YAML variants\n* Load the configuration file pointed to by `@PropertySource` or `@ConfigurationProperties` of the `@Configuration` class\n* Default configuration, set by `SpringApplication.setDefaultProperties`\n\n## Detailed configuration rules\nTake a look at how `config-client` obtaining configuration data from `config-server`:\n\n1. When the `config-client` starts, it requests the `config-server` for configuration data according to the application, profile, and label configured in bootstrap.properties;\n2. The `config-server` searches for a matching configuration file from a Git repository (here Git is taken as an example) according to the request and configuration of the `config-client`;\n3. The `config-server` pulls the matched Git repository to local and establishes a local cache;\n4. The `config-server` creates a Spring `ApplicationContext` instance, populates the configuration information according to the pulled configuration file, and then returns the configuration information to the `config-client`;\n5. After the `config-client` obtains the configuration data returned by the `config-server`, it loads these configuration data into its own context. At the same time, because the priority of these configuration data is higher than the configuration in the local Jar package, the local configuration will no longer be loaded.\n\nSo, how does the `config-server` match the configuration files in the Git repository? Usually, we will create a configuration file similar to the following for a project:\n\n* service.properties: basic configuration file;\n* service-dev.properties: configuration file for development;\n* service-test.properties: configuration file used for testing;\n* service-prod.properties: configuration file used by the production environment;\n\nWhen we visit the endpoint of `config-server`, we will match the corresponding configuration file according to the following mapping relationship:\n\n1. /{application}/{profile}[/{label}]\n2. /{application}-{profile}.yml\n3. /{label}/{application}-{profile}.yml\n4. /{application}-{profile}.properties\n5. /{label}/{application}-{profile}.properties\n\nThe above Url will be mapped to a profile with the format: `{application}-{profile}.properties(yml)`. In addition, label corresponds to the branch name on Git and is an optional parameter. If not, it is the default master branch.\n\nThe `bootstrap.properties` of `config-client` corresponds to the following:\n\n* `spring.application.name` <==> `application`;\n* `spring.cloud.config.profile` <==> `profile`;\n* `spring.cloud.config.label` <==> `label`.\n\n### Git repository config\nThe `config-server` uses Git by default, so the configuration is very simple, such as the configuration(application.properties) above:\n\n```\nspring.cloud.config.server.git.uri=http://\nspring.cloud.config.server.git.username=username\nspring.cloud.config.server.git.password=password\n```\n\n#### 1. Using placeholders\nWe can also use `{application}`, `{profile}` and `{label}` placeholders in the server configuration, as follows:\n\n```\nspring.cloud.config.server.git.uri = http://github.com/cd826/{application}\nspring.cloud.config.server.git.username = username\nspring.cloud.config.server.git.password = password\n```\n\nIn this way, we can create a separate repository for each application client.\n\nIt should be noted here that if a branch or label in Git contains \"/\", you need to use \"(_)\" instead in the {label} parameter. This is mainly to avoid conflicts with Http URL escape character processing.\n\n#### 2. Use pattern matching\nWe can also use `{application}/{profile}` for pattern matching in order to get the corresponding profile. An example configuration is as follows:\n\n```\nspring.cloud.config.server.git.uri = https://github.com/spring-cloud-samples/config-repo\n\nspring.cloud.config.server.git.repos.simple = https://github.com/simple/config-repo\n\nspring.cloud.config.server.git.repos.special.pattern = special */dev*, *special*/dev*\nspring.cloud.config.server.git.repos.special.uri = https://github.com/special/config-repo\n\nspring.cloud.config.server.git.repos.local.pattern = local*\nspring.cloud.config.server.git.repos.local.uri = file:/home/configsvc/config-repo\n```\n\nIf multiple values ​​need to be configured in the pattern, they can be separated by commas.\n\nIf `{application}/{profile}` does not match any resources, the default URI configured by `spring.cloud.config.server.git.uri` is used.\n\nWhen we use a yml type file for configuration, if the schema attribute is a YAML array, it can also be defined using a YAML array format. This can be set to multiple configuration files, such as:\n\n``` yaml\nspring:\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://github.com/spring-cloud-samples/config-repo\n          repos:\n            development:\n              pattern:\n                - */development\n                - */staging\n              uri: https://github.com/development/config-repo\n            staging:\n              pattern:\n                - */qa\n                - */production\n              uri: https://github.com/staging/config-repo\n```\n\n#### 3. Search directory\nWhen we store the configuration file in a subdirectory in the Git repository, we can specify the directory by setting `search-path`. Similarly, `search-path` also supports the above placeholders. Examples are as follows:\n\n```\nspring.cloud.config.server.git.uri = https://github.com/spring-cloud-samples/config-repo\nspring.cloud.config.server.git.searchPaths = foo, bar*\n```\n\nIn this way, the system will automatically search the subdirectories of foo and the subdirectories in the folders starting with bar.\n\n#### 4. SSH configuration\nIf you do not want to use HTTPS and user authentication, you can also use SSH directly. At this time, we only need to store the keys required by ssh in the `~/.ssh` directory, and point the configured URI to the SSH address, such as: `git@github.com:nicklee1006/SpringCloudDemoSampleConfig`.\n\nIf you know your `~/.git` directory clearly, then you can use `git config --global` to configure it. Otherwise, you can use global configuration, such as: `git config --global http.sslVerify false`.\n\n#### 5. Proxy\n`config-server` uses JGit to access the configuration repository, so we can configure the proxy used by HTTPS under `~/.git/config`, or use the JVM system properties `-Dhttps.proxyHost` and `-Dhttps.proxyPort` to configure.\n\n#### 6. Local cache\nWhen `config-server` obtains the configuration information from Git (or SVN), it will store a copy in the local file system. By default, it will be stored in the system temporary directory, and it starts with `config-repo-`. On Linux systems, the default directory is `/tmp/config-repo-<randomid>`. `config-server` storing configuration information locally can effectively prevent the problem that the Git repository fails and cannot be accessed. When `config-server` cannot access the Git repository, it will read the configuration stored in the local file before, and then The configuration information is returned to `config-server`.\n\nThe official Spring Cloud documentation suggests that we specify a local file path in `config-server` to avoid unpredictable errors. You can use the following property configuration to specify the local file path:\n\n```\n## Git\nspring.cloud.config.server.git.basedir=tmp/\n\n## SVN\nspring.cloud.config.server.svn.basedir=tmp/\n```\n\n### SVN configuration\nIf using SVN instead of Git, only need to make the following changes in `config-server` to support SVN repositories.\n\n#### pom.xml\nAdd the following dependencies to the pom file:\n\n``` xml\n<dependency>\n     <groupId>org.tmatesoft.svnkit</groupId>\n     <artifactId>svnkit</artifactId>\n</dependency>\n```\n\n#### appliaction.properties\n```\nspring.cloud.config.server.svn.uri = {your svn server}\nspring.cloud.config.server.svn.username = username\nspring.cloud.config.server.svn.password = password\n```\n\n### File system\nIf don't want to use Git or SVN in your `config-server`, then we can also load the corresponding configuration file directly from the current classpath or file system, just set in the configuration file as follows:\n\n```\nspring.profiles.active = native\n```\n\nNote that `config-server` is loaded from the classpath by default. We can use the `spring.cloud.config.server.native.searchLocations` property to set the directory of the configuration file. For the file path, our configuration must start with `file:`. If it is a Windows system, we must escape `/` for the absolute path. For example, under Windows we need to configure the following: `file:///${user.home}/config-repo`.\n\nIn addition, when we use the file system as a configuration file repository, the configuration of `spring.cloud.config.server.native.searchLocations` also supports `{application}`, `{profile}`, and `{label}` placeholders.\n\n> Spring Cloud officially recommends that you can use the file system during testing and development, but in the formal environment, try to use Git or SVN.\n\n> In addition, `Spring Cloud Config` also supports another configuration file method: `Vault Server`.\n\n## Security\n### config-server access security\nFor some of the configuration content that we store in the configuration center, there will always be some sensitive information, such as the user name and password for the database connection. You ca n’t run naked, so we still need to do some security control on `config-server`. Of course, there are many types of security controls for `config-server`, such as physical network restrictions, OAuth2 authorization, and so on. However, because we are using SpringBoot here, using `Spring Security` will be easier and simpler. At this time, we only need to add the following dependencies to `config-server`\n\n``` xml\n<dependency>\n     <groupId>org.springframework.boot</ groupId>\n     <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n```\n\nWhen we start `config-server`, `Spring Security` will generate an access password for us by default. This method is often not what we need, so generally we need to configure the username and password in the configuration file, such as:\n\n```\nspring.security.user.name=username\nspring.security.user.password=pwd\n```\n\n When we need to access `config-server`, a user authentication dialog will pop up. At this time, for `config-client` we need to add user and access password configuration in the configuration file, as follows:\n\n ```\nspring.cloud.config.username=username\nspring.cloud.config.password=pwd\n ```\n\n ### Encryption and decryption\nAccess security is the overall control. In most cases, we also need to encrypt the sensitive content and store it, such as the user name and login password for database access. Fortunately, `Spring Cloud Config` provides us with corresponding support.\n\n`Spring Cloud Config` provides two encryption and decryption methods: \n* symmetric encryption;\n* asymmetric encryption. \n\nBefore describing how to use it, let's look at some prerequisites.\n\n#### Install JCE (Java Cryptography Extension)\nThe encryption and decryption provided by `Spring Cloud Config` depends on `JCE`. \n\nFor `JDK 9` and later, JCE is already included\n\nFor earlier releases, we need to install `JCE` first. The installation method is also relatively simple, that is, download the corresponding Jar packages, and then replace these packages with the files corresponding to `$JDK_HOME/jar/lib/security`. For JDK8, the download address is: [JCE](https://www.oracle.com/java/technologies/javase-jce-all-downloads.html).\n\n#### Encryption and decryption endpoint\nIn addition, `Spring Cloud Config` also provides two endpoints for encryption and decryption, as follows:\n\n* **/encrypt:** Encrypt endpoint, use the format: `curl $CONFIG_SERVER/encrypt -d The content to be encrypted`\n* **/decrypt:** The decryption endpoint, using the format: `curl $CONFIG_SERVER/decrypt -d The content to be decrypted`\n\n> Note: When your test contains special characters in encryption and decryption, URL encoding is required. At this time, you need to use `--data-urlencode` instead of `-d`.\n\n#### Symmetric encryption\nThe configuration of symmetric encryption and decryption is very simple. We just need to add the key used for encryption and decryption in the configuration file, such as:\n\n```\nencrypt.key = key\n```\n\nAfter configuration, you can start `config-server` and use the endpoint mentioned above for encryption and decryption testing.\n\nFor the configuration file, we need to add a `{cipher}` leader to the encrypted content. Such as:\n\n```\nspring.datasource.username = dbuser\nspring.datasource.password = {cipher}FKSAJDFGYOS8F7GLHAKERGFHLSAJ\n```\n\nHowever, if the configuration file you use is in yml format, you need to use single quotes to enclose the encrypted content, as follows:\n\n``` yaml\nspring:\n     datasource:\n         username: dbuser\n         password: '{cipher}FKSAJDFGYOS8F7GLHAKERGFHLSAJ'\n```\n\n#### Asymmetric encryption\nAsymmetric encryption is a bit more complicated than symmetric encryption. First, we need to use Java's `keytool` to generate a key pair, and then create a `Key Store` and copy it to the server directory.\n\n1. Use `keytool` to generate `Key Store`, the command is as follows:\n``` bbash\n$keytool -genkeypair -alias tsfjckey -keyalg RSA \\\n   -dname \"CN = Mall Web, OU = TwoStepsFromJava, O = Organization, L = city, S = province, C = china\" \\\n   -keypass javatwostepsfrom -keystore server.jks -storepass twostepsfromjava\n```\n\n2. Copy the generated `server.jks` to the resources directory of the project `config-server`.\n\n3. Modify the configuration file:\n\n```\nencrypt.key-store.location = server.jks\nencrypt.key-store.alias = tsfjckey\nencrypt.key-store.password = pwd\nencrypt.key-store.secret = pwd\n```\n\nAsymmetric encryption is also more complicated to configure than symmetric encryption, but its security is also much higher.\n\n#### Use multiple encryption keys\nMaybe we need to use different encryption keys for different sensitive information. For this, our configuration file only needs to be written as follows:\n\n```\nfoo.bar = (cipher) {key: testkey} ...\n```\n\nWhen `config-server` decrypts, it will try to obtain testkey from the configuration file as the key.\n\n## High availability configuration\n### Integrate Eureka\nWe used the specific address when configuring `config.uri` in `config-server`, so can I use `Eureka`? The answer is yes, we can use `config-server` as a basic unit of services just like other microservices. We just need to make the following modifications.\n\n#### Config-Server\nAdd following dependency to pom.xml\n\n``` xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\nConfigure the name of our service in the configuration file and the address of the Eureka server:\n\n```\nspring.application.name=config-server\n\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n```\n\nAdded `@EnableDiscoveryClient` annotation to main class.\n\n``` Java\n@SpringBootApplication\n@EnableConfigServer\n@EnableDiscoveryClient\npublic class ConfigServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConfigServerApplication.class, args);\n    }\n}\n```\n\nIf we start `config-server`, we will see the corresponding service registration on the `Eureka` server.\n\n#### Config-Client\nAdd following dependency to pom.xml\n\n``` xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\nModify `bootstrap.properties`:\n\n```\nserver.port=8080\n\nspring.application.name=sample-service\nspring.cloud.config.profile=dev\n\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n\nspring.cloud.config.discovery.enabled=true\nspring.cloud.config.discovery.service-id=config-server\n```\n\nThe most important thing here is to add: `spring.cloud.config.discovery.enabled = true` in the configuration, and change the `spring.cloud.config.uri` configured to s`pring.cloud.config.discovery.service-id`.\n\nModify main class.\n\n``` Java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class ConfigClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConfigClientApplication.class, args);\n    }\n}\n```\n\n### Fast failure and response\n#### Start Config-Server to start loading\nBy default, the server will load from the configured Git repository only when the client requests it. We can set `clone-on-start` to make the server load at startup.\n\n```\nspring.cloud.config.server.git.uri = https://git/common/config-repo.git\n\nspring.cloud.config.server.git.repos.team-a.pattern = team-a- *\nspring.cloud.config.server.git.repos.team-a.clone-on-start = true\nspring.cloud.config.server.git.repos.team-a.uri = http://git/team-a/config-repo.git\n\nspring.cloud.config.server.git.repos.team-b.pattern = team-b- *\nspring.cloud.config.server.git.repos.team-b.clone-on-start = false\nspring.cloud.config.server.git.repos.team-b.uri = http://git/team-b/config-repo.git\n\nspring.cloud.config.server.git.repos.team-c.pattern = team-c- *\nspring.cloud.config.server.git.repos.team-c.uri = http://git/team-a/config-repo.git\n```\n\nThe above configuration, for `team-a`, will load the corresponding configuration when `config-server` starts, but not for others. Of course, we can do global configuration by setting the value of `spring.cloud.config.server.git.clone-on-start`.\n\n#### Enable Config-Client Fast failure\nIn some cases, we want to fast failure a service when it is unable to connect to the server. We can achieve it by set:\n\n```\nspring.cloud.config.fail-fast = true\n```\n\n#### Set Config-Client to retry\nIf `config-server` happens to be unavailable at startup and you want to retry later, then we start to enable `config-client`s retry mechanism. First, we need to configure:\n\n```\nspring.cloud.config.fail-fast = true\n```\n\nThen we need to add to our dependencies:\n\n``` xml\n<dependency>\n    <groupId>org.springframework.retry</groupId>\n    <artifactId>spring-retry</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\nIn this way, we can enable the retry mechanism for the `config-client`. When the connection to the `config-server` fails, the `config-client` will continue to try to connect to the `config-server`. By default, it will try to connect 6 times. The time interval is initially `1000 milliseconds`. Each connection attempt will increase the interval between connection attempts by a factor of `1.1`. An error will only be returned if the connection cannot be connected to `config-server` at the end. We can do this by overriding `spring.cloud.config.retry.*` In the configuration file.\n\n> If you want full control over the retry mechanism, you can implement the class: `RetryOperationsInterceptor` and set the bean id to: `configServerRetryInterceptor`.\n\n### Dynamic refresh configuration\nTHe `config-client` provides a refresh endpoint to refresh the configuration file. To use this feature, we need to add the following dependencies to the pom.xml file of `config-client`:\n\n``` xml\n<dependency>\n     <groupId>org.springframework.boot</groupId>\n     <artifactId> spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\nIn this way, when the configuration file is modified and submitted to the Git repository, you can use: `http://localhost: 8080/refresh` to refresh the local configuration data.\n\n> However, the best way is to integrate with `Spring Cloud Bus` so that the automatic distribution of the configuration can be achieved instead of manually refreshing the configuration.\n\nCheck out the source code here: [Config demo](https://github.com/nicklee1006/SpringCloudDemo/tree/master/config)","categories":["Spring Cloud"]},{"title":"Java TreeMap","url":"/Java-TreeMap/","content":"## TreeMap\nIn the `Map` collection framework, in addition to `HashMap`, `TreeMap` is also one of the collection objects commonly used in work.\n\nCompared with `HashMap`, `TreeMap` is a `Map` collection that can compare elements, and sorts the key value. For comparasion, you can use the natural order of the elements, or you can use a custom comparator in the collection to sort;\n\nUnlike `HashMap`'s hash mapping, the underlying structure of the `TreeMap` is a tree structure. As for the specific form, you can simply understand it as an inverted tree --- roots up, leaves down. In computer terms, `TreeMap` implements the structure of a `red-black tree`, forming a binary tree.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\n`TreeMap` inherits `AbstractMap` and implements `Map`, `Cloneable`, `NavigableMap`, and `Serializable` interfaces.\n\n1. `TreeMap` inherits `AbstractMap`, and `AbstractMap` implements the `Map` interface and implements the methods defined in the `Map` interface, reducing the complexity of subclass inheritance;\n\n2. `TreeMap` implements the `Map` interface and becomes a member of the `Map` framework, which can store elements in the form of `key-value`;\n\n3. `TreeMap` implements the `NavigableMap` interface, which means that it has stronger element searching capabilities;\n\n4. `TreeMap` implements the `Cloneable` interface and implements the `clone()` method, so it can be cloned;\n\n5. `TreeMap` implements the `Java.io.Serializable` interface, supports serialization operations, and can be transmitted through the `Hessian` protocol;\n\nFor `Cloneable`, `Serializable`, we are familiar with it. Basically, every class in the Java collection framework will implement these 2 interfaces. But what does the `NavigableMap` interface do and what functions does it define? Next, let's take a look at the source code of `NavigableMap`!\n\n{% asset_img 2.png %}\n<br/>\n<br/>\n\nLet's first introduce the `SortedMap` interface in the `NavigableMap` system:\n\nFor `SortedMap`, this class is the parent interface in the `TreeMap`, and it is also the most critical interface different from the `HashMap` system.\n\nThe main reason is the first method defined in the `SortedMap` interface: `Comparator<?Super K> comparator()`;\n\nWith the comparator, the inserted elements can be sorted.\n\n``` Java\npublic interface SortedMap<K,V> extends Map<K,V> {\n    \n    //Returns the element comparator. If the order is natural, return null;\n    Comparator<? super K> comparator();\n    \n    //Returns the collection from `fromKey` to `toKey`: with head but no tail\n    java.util.SortedMap<K,V> subMap(K fromKey, K toKey);\n\n    //Returns the collection from head to `toKey`: without 'toKey'\n    java.util.SortedMap<K,V> headMap(K toKey);\n\n    //Returns the collection from `fromKey` to tail: with 'fromKey'\n    java.util.SortedMap<K,V> tailMap(K fromKey);\n    \n    //Returns the first element in the collection\n    K firstKey();\n   \n    //Returns the last element in the collection\n    K lastKey();\n    \n    //Returns all keys in the collection\n    Set<K> keySet();\n    \n    //Returns all values in the collection:\n    Collection<V> values();\n    \n    //Returns key-value map of elements\n    Set<Map.Entry<K, V>> entrySet();\n}\n```\n\nThe `NavigableMap` interface is a further extension of `SortedMap`: it mainly adds search and retrieval operations for elements in the collection, such as returning elements in a range in the collection, returning elements less than a certain value, and so on.\n\n``` Java\npublic interface NavigableMap<K,V> extends SortedMap<K,V> {\n\n    //Returns the first element less than the key\n    Map.Entry<K,V> lowerEntry(K key);\n\n    //Returns the first key less than the key:\n    K lowerKey(K key);\n\n    //Returns the first element less than or equal to the key\n    Map.Entry<K,V> floorEntry(K key);\n\n    //Returns the first key less than or equal to the key\n    K floorKey(K key);\n\n    //Returns the first element greater than or equal to the key\n    Map.Entry<K,V> ceilingEntry(K key);\n\n    //Returns the first key greater than or equal to the key\n    K ceilingKey(K key);\n\n    //Returns the first element greater than the key\n    Map.Entry<K,V> higherEntry(K key);\n\n    //Returns the first key greater than the key:\n    K higherKey(K key);\n\n    //Returns the first element\n    Map.Entry<K,V> firstEntry();\n\n    //Returns the last element\n    Map.Entry<K,V> lastEntry();\n\n    //Returns the first element, and delete it from the collection\n    Map.Entry<K,V> pollFirstEntry();\n\n    //Returns the last element, and delete it from the collection\n    Map.Entry<K,V> pollLastEntry();\n\n    //Returns the Map collection in reverse order\n    java.util.NavigableMap<K,V> descendingMap();\n\n    NavigableSet<K> navigableKeySet();\n\n    //Returns keys in reverse order in the collection:\n    NavigableSet<K> descendingKeySet();\n\n    java.util.NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive,\n                                       K toKey, boolean toInclusive);\n\n    java.util.NavigableMap<K,V> headMap(K toKey, boolean inclusive);\n\n    java.util.NavigableMap<K,V> tailMap(K fromKey, boolean inclusive);\n\n    SortedMap<K,V> subMap(K fromKey, K toKey);\n\n    SortedMap<K,V> headMap(K toKey);\n\n    SortedMap<K,V> tailMap(K fromKey);\n}\n```\n\nIn fact, the purpose of `NavigableMap` is very simple and straightforward, which is to enhance the search and retrieval functions for the elements in the collection. When the subclass `TreeMap` is implemented, the above functions are naturally obtained;\n\n`TreeMap` has the following characteristics:\n* Duplicate keys are not allowed;\n* Can insert null key, null value;\n* Can sort elements;\n* Unordered collection (insertion and traversal order are inconsistent);\n\n## TreeMap basic operations\n``` Java\npublic class TreeMapOperations {\n    public static void main(String[] agrs){\n        //Create TreeMap：\n        TreeMap<String,Integer> treeMap = new TreeMap<String,Integer>();\n\n        //Add elements\n        treeMap.put(\"hello\",1);\n        treeMap.put(\"world\",2);\n        treeMap.put(\"i\",3);\n        treeMap.put(\"am\",4);\n        treeMap.put(\"a\",4);\n        treeMap.put(\"developer\",4);\n\n        //Traverse elements\n        Set<Map.Entry<String,Integer>> entrySet = treeMap.entrySet();\n        for(Map.Entry<String,Integer> entry : entrySet){\n            String key = entry.getKey();\n            Integer value = entry.getValue();\n            System.out.println(\"key:\" + key + \",value:\" + value);\n        }\n\n        //get all keys\n        Set<String> keySet = treeMap.keySet();\n        for(String strKey : keySet){\n            System.out.println(\"key:\" + strKey);\n        }\n\n        //get all values:\n        Collection<Integer> valueList = treeMap.values();\n        for(Integer intValue:valueList){\n            System.out.println(\"values\" + intValue);\n        }\n\n        //get elements\n        //get element whose key is \"developer\"\n        Integer getValue = treeMap.get(\"developer\");\n        //get first key\n        String firstKey = treeMap.firstKey();\n        //get last key\n        String lastKey =treeMap.lastKey();\n        //get first element whose key is less than \"developer\"\n        String lowerKey =treeMap.lowerKey(\"developer\");\n        //get first element whose key is greater than \"developer\"\n        String ceilingKey =treeMap.ceilingKey(\"developer\");\n        //get collections whose key is from \"i\"到\"a\"的元素\n        SortedMap<String,Integer> sortedMap =treeMap.subMap(\"i\",\"a\");\n\n        //delete elemetns\n        //delete element whose key is \"developer\"\n        Integer removeValue = treeMap.remove(\"developer\");\n        // clear collection\n        treeMap.clear(); \n\n        // if collection is empty\n        boolean isEmpty = treeMap.isEmpty();\n        //if collection contains element whose key is \"developer\"\n        boolean isContain = treeMap.containsKey(\"developer\");\n    }\n}\n```\n\n## TreeMap sorting\nIn the previous section, the code showed the simple use of `TreeMap`. In the first section, I mentioned that `TreeMap` is a collection that can sort elements. So how to sort it?\n\n### Use natural order of elements\nWhen using natural order sorting, there are two cases: one is the object defined by Jdk, and the other is the object we define.\n\n``` Java\npublic class SortedObject implements Comparable<SortedObject> {\n    private int age;\n\n    public SortedObject(int age){\n        this.age = age;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    //implement compareTo(T o) method：\n    public int compareTo(SortedObject sortedObject) {\n        int num = this.age - sortedObject.getAge();\n        if(num==0){\n            return 0;\n        }else if(num>0){\n            return 1;\n        }else{\n            return -1;\n        }\n    }\n}\n\npublic class TreeMapTest {\n    public static void main(String[] agrs){\n        //Natural order\n        naturalSort();\n    }\n    \n    public static void naturalSort(){\n        //First case: Integer object\n        TreeMap<Integer,String> treeMapFirst = new TreeMap<Integer, String>();\n        treeMapFirst.put(1,\"developer\");\n        treeMapFirst.put(6,\"developer\");\n        treeMapFirst.put(3,\"developer\");\n        treeMapFirst.put(10,\"developer\");\n        treeMapFirst.put(7,\"developer\");\n        treeMapFirst.put(13,\"developer\");\n        System.out.println(treeMapFirst.toString());\n\n        //Second case: SortedObject object\n        TreeMap<SortedObject,String> treeMapSecond = new TreeMap<SortedObject, String>();\n        treeMapSecond.put(new SortedObject(10),\"developer\");\n        treeMapSecond.put(new SortedObject(1),\"developer\");\n        treeMapSecond.put(new SortedObject(13),\"developer\");\n        treeMapSecond.put(new SortedObject(4),\"developer\");\n        treeMapSecond.put(new SortedObject(0),\"developer\");\n        treeMapSecond.put(new SortedObject(9),\"developer\");\n        System.out.println(treeMapSecond.toString());\n    }\n}\n```\n\nIn the natural order comparison, the elements being compared need to implement the `Comparable` interface, otherwise when adding an element to the collection will have \"java.lang.ClassCastException: com.jiaboyan.collection.map.SortedObject cannot be cast to java.lang.Comparable \" exception;\n\nThis is because when the `put()` method is called, the element will be converted into a `Comparable` type object, so when the element passed in does not implement the `Comparable` interface, it cannot be converted and an exception will be reported;\n\n### Use custom comparator\nTo use a custom comparator for sorting, you need to pass the custom comparator object to the `TreeMap` constructor when you create the `TreeMap` object;\n\nA custom comparator object needs to implement the `Comparator` interface and implement the compare method `compare(T o1, T o2)`;\n\nIt is worth noting that if you use a custom comparator to sort, the compared objects no longer need to implement the `Comparable` interface;\n\n``` Java\npublic class SortedObject {\n    private int age;\n\n    public SortedObject(int age){\n        this.age = age;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n\npublic class SortedObjectComparator implements Comparator<SortedObject> {\n    public int compare(SortedObject sortedTest1, SortedObject sortedTest2) {\n        int num = sortedTest1.getAge() - sortedTest2.getAge();\n\n        if(num==0){\n            return 0;\n        }else if(num>0){\n            return 1;\n        }else{\n            return -1;\n        }\n    }\n}\n\npublic class TreeMapTest {\n    public static void main(String[] agrs){\n        //custom comparator\n        customSort();\n    }\n\n    public static void customSort(){\n        TreeMap<SortedObject,String> treeMap = new TreeMap<SortedObject, String>(new SortedObjectComparator());\n\n        treeMap.put(new SortedObject(10),\"hello\");\n        treeMap.put(new SortedObject(21),\"my\");\n        treeMap.put(new SortedObject(15),\"name\");\n        treeMap.put(new SortedObject(2),\"is\");\n        treeMap.put(new SortedObject(1),\"nick\");\n        treeMap.put(new SortedObject(7),\"li\");\n        System.out.println(treeMap.toString());\n    }\n}\n```\n\nThis is the basic operation and usage of `TreeMap`. I will post another blog to look at `TreeMap`'s source code in Java.","tags":["Java Collections"],"categories":["Java"]},{"title":"Leetcode 61. Rotate List","url":"/Leetcode-61-Rotate-List/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nMove the last linked list node to the front and repeat the process `k` times.\n\n### Similar Questions\n* Easy - [189. Rotate Array](https://leetcode.com/problems/rotate-array/)\n* Medium - [725. Split Linked List in Parts](https://leetcode.com/problems/split-linked-list-in-parts/)\n\n## Solution\nObviously we don't really need to move nodes one by one. If the length of the linked list is `len` and `n = k % len`, we only need to move the last `n` nodes to the front. We only need to find the pointer of the inverse `n + 1` node and point it to null, and the pointer at the end to the head node. Finding the last `n` nodes reminds me of {% post_link Leetcode-19-Remove-Nth-Node-From-End-of-List '19. Remove Nth Node From End of List' %}, using the fast and slow pointers.\n\n``` Java\npublic static ListNode rotateRight(ListNode head, int k) {\n    // length of the list\n    int length = 1;\n    ListNode node = head;\n\n    if (head == null) {\n        return null;\n    }\n\n    // get length of the list\n    while (node.next != null) {\n        node = node.next;\n        length++;\n    }\n\n    ListNode tail;\n\n    // now 'node' is the last node in the last\n    // connect tail to head\n    node.next = head;\n    tail = node;\n\n    // Move right k place = moving head to right by (length - k % length) places\n    int steps = length - k % length;\n\n    while (steps > 0) {\n        head = head.next;\n        tail = tail.next;\n\n        steps--;\n    }\n\n    tail.next = null;\n\n    return head;\n}\n```\n\nTime complexity O(n).\n\nSpace complexity O(1).","tags":["Leetcode - Linked List","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 19. Remove Nth Node From End of List","url":"/Leetcode-19-Remove-Nth-Node-From-End-of-List/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven a linked list, delete the nth node from the end.\n\n## Solution - 2 Pass\nDeleting a node is nothing more than traversing the linked list and find the node in front of the node to be deleted. However because it is a linked list, we don't know its length. So we have to traverse the list first to get its length, then subtract `n` from the length to find the position of the node to be deleted.\n\n``` Java\npublic ListNode removeNthFromEnd(ListNode head, int n) {\n    int length = 0;\n    ListNode node = head;\n\n    while (node != null) {\n        length++;\n        node = node.next;\n    }\n\n    // only 1 node in the list\n    if (length == 1) {\n        return null;\n    }\n\n    // index to remove, start from 0\n    int indexToRemove = length - n;\n\n    node = head;\n    // move to the previous node\n    for (int i = 0; i < indexToRemove - 1; i++) {\n        node = node.next;\n    }\n\n    node.next = node.next.next;\n\n    return head;\n}\n```\n\nTime complexity: assuming the length of the linked list is `L`, then the first loop is `L` times, and the second loop is `L-n` times, for a total of `2L-n` times, so the time complexity is O (L).\n\nSpace complexity: O (1).\n\n## Solution - 1 Pass\nSo how can we traverse the list only once?\n\nWe set two pointers, let the first pointer traverse forward `n` steps, and then let them both traverse at the same time. In this case, when the first pointer reaches the end, the second pointer is `n` steps from the head. So the position of the second pointer is exactly the nth node from the head.\n\n``` Java\npublic  ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode dummyNode = new ListNode(0);\n    dummyNode.next = head;\n\n    ListNode pointer1 = dummyNode;\n    ListNode pointer2 = dummyNode;\n\n    // move first pointer ahead n steps\n    for (int i = 0; i <= n; i++) {\n        pointer1 = pointer1.next;\n    }\n\n    while (pointer1 != null) {\n        pointer1 = pointer1.next;\n        pointer2 = pointer2.next;\n    }\n\n    // now pointer2 is the node before the node to be delete\n    pointer2.next = pointer2.next.next;\n\n    return dummyNode.next;\n}\n```\n\nTime complexity:\n\nThe first pointer goes from 0 to n, then \"the first pointer goes from n to the end\" and \"the second pointer goes from 0 to the position of the n-th node down\" simultaneously.\n\nThe previous solution is nothing more than going from 0 to the end, and then going from 0 to the position of the n-th node.\n\nSo in fact, the number of times their statements are executed is the same. The position of the n-th node from 0 to the penultimate point is traversed twice, so the total is `2L-n` times. It's just that this solution combines the two loops of solution one, so that the second pointer seems to traverse by the way, the idea is very nice.\n\nSo in essence, they are actually the same, and the time complexity is still O(n).\n\nSpace complexity: O (1).","tags":["Leetcode - Linked List","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 9: Distributed Tracing Solution - Sleuth","url":"/Spring-Cloud-9-Distributed-Tracing-Solution-Sleuth/","content":"When we develop microservice application, we usually divide microservices according to business logic, and call each business through REST. A user operation may require the cooperation of many microservices to complete. If any microservice has problems or the network times out, it will cause the function to fail. With more and more services, the analysis of the call chain between microservices will become more and more complicated.\n\n`Spring Cloud Sleuth` provides link tracking for calls between services. Through `Sleuth`, you can clearly understand which services a request has passed, and how long each service process takes, so that we can easily sort out the calling relationship between microservices. In addition `Sleuth` can help us:\n\n* Time-consuming analysis: with `Sleuth` we can easily understand the time-consuming of each sampling request, so as to analyze which service calls are time-consuming;\n* Errors visualization: for exceptions not caught by the program, you can see them through the integrated `Zipkin` service interface;\n* Link optimization: For services that are called frequently, some optimization measures can be implemented for these services.\n\n## Sleuth+Log Example\nWe first integrate `Sleuth` in the simplest way and output the information tracked by `Sleuth` to the log.\n\n### Modify Product-Service-Consumer\n#### Add bootstrap.properties file\nIn order to enable the log file to obtain the service name, we need to move part of the original configuration in `application.properties` into the `bootstrap.properties` configuration file. This is because Spring Boot will preferentially scan the bootstrap configuration source when starting, so that the log can get the service name.\n\n``` Xml\nserver.port=9090\n\nspring.application.name=PRODUCT-SERVICE-CONSUMER\n```\n\n#### Modify application.properties\n``` Xml\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n\nfeign.hystrix.enabled=true\n\nmanagement.endpoints.web.exposure.include=hystrix.stream\n\nlogging.level.org.springframework=INFO\nlogging.level.org.springframework.web.servlet.DispatcherServlet=DEBUG\n```\n\nNote here to modify the log level of `DispatcherServlet` to `DEBUG`.\n\n#### Modify Logback configuration file\nAdd a file named `logback-spring.xml` to the `resources` directory with the following content:\n``` Xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<configuration>\n    <include resource=\"org/springframework/boot/logging/logback/defaults.xml\"/>\n    ​\n    <springProperty scope=\"context\" name=\"springAppName\" source=\"spring.application.name\"/>\n\n    <!-- Example for logging into the build folder of your project -->\n    <property name=\"LOG_FILE\" value=\"${BUILD_FOLDER:-build}/${springAppName}\"/>​\n\n    <property name=\"CONSOLE_LOG_PATTERN\"\n              value=\"%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p})\n            %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}\"/>\n\n    <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <layout class=\"ch.qos.logback.classic.PatternLayout\">\n            <Pattern>\n                %d{yyyy-MM-dd HH:mm:ss SSS} [%thread] %-5level %logger{36} - %msg%n\n            </Pattern>\n        </layout>\n    </appender>\n\n    <!-- Appender to log to console -->\n    <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\">\n            <!-- Minimum logging level to be presented in the console logs-->\n            <level>DEBUG</level>\n        </filter>\n        <encoder>\n            <pattern>${CONSOLE_LOG_PATTERN}</pattern>\n            <charset>utf8</charset>\n        </encoder>\n    </appender>\n\n    <!-- Appender to log to file -->​\n    <appender name=\"flatfile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <file>${LOG_FILE}</file>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            <fileNamePattern>${LOG_FILE}.%d{yyyy-MM-dd}.gz</fileNamePattern>\n            <maxHistory>7</maxHistory>\n        </rollingPolicy>\n        <encoder>\n            <pattern>${CONSOLE_LOG_PATTERN}</pattern>\n            <charset>utf8</charset>\n        </encoder>\n    </appender>\n    ​    ​\n    <root level=\"INFO\">\n        <appender-ref ref=\"console\"/>\n        <!-- uncomment this to have also JSON logs -->\n        <!--<appender-ref ref=\"logstash\"/>-->\n        <!--<appender-ref ref=\"flatfile\"/>-->\n    </root>\n</configuration>\n```\n\n#### Add dependency\n``` Xml\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-sleuth</artifactId>\n</dependency>\n```\n\n> As mentioned in the SpringCloud reference manual: `SLF4J MDC` is always set automatically, and if logback is used, the trace/span id is immediately displayed in the log. Other log systems need to be configured to achieve this effect. The default `logging.pattern.level` is set to%clr(% 5p)%clr([${spring.application.name:},%X{X-B3-TraceId:-},%X{X-B3-SpanId: -},% X {X-Span-Export:-}]) {yellow} (This is also a feature of `Spring Boot` when integrating logback). This means that if you do not need to manually configure the format when using SLF4J, other log systems must be manually configured, otherwise they will not be output.\n\n### Modify Product-Service\nSame as above\n\n### Test\nStart the `Service-discovery`, `Product-Service`, and `Product-Service-Consumer` in order. Visit: http://localhost:9090/products. Then we observe the log output in the `Product-Service-Consumer` and `Product-Service` consoles, and we can see output similar to the following:\n\n```\n2020-02-16 22:14:14.937 DEBUG [PRODUCT-SERVICE,71fb907c61436aff,d572b78867aa38a1,false]             3422 --- [nio-2100-exec-2] o.s.web.servlet.DispatcherServlet        : GET \"/products\", parameters={}\n```\n\n```\n2020-02-16 22:14:15.012 DEBUG [PRODUCT-SERVICE-CONSUMER,71fb907c61436aff,71fb907c61436aff,false]             3428 --- [nio-9090-exec-1] o.s.web.servlet.DispatcherServlet        : Completed 200 OK\n```\n\nThe format of the log content is: [appname, traceId, spanId, exportable], which is `Sleuth`'s trace data. among them:\n* **appname**: the service name of the microservice;\n* **traceId/spanId**: Two terms for Sleuth link tracking. We will introduce them in detail later.\n* **whether exportable is sent to Zipkin**.\n\n## Sleuth Terminology\nBecause Sleuth is based on Google’s [Dapper](https://research.google/pubs/pub36356/)’s paper, it also borrows Dapper in terminology.\n\n* **Span**: The most basic unit of work. For example: Sending an RPC is a new `span`, and so is an RPC response. `Span` uses a unique 64-bit ID for identification. In addition, a 64-bit ID is used for service call tracking. `Span` can also carry other data, such as: description, timestamp, tag of key-value pair, ID of starting `Span`, and processing ID (usually using IP address), etc. `Span` has start and end, they are used to track time information. `Span` should appear in pairs, beginning and ending, so once a `span` is created, it must be ended at some point in the future.\n\n> Note: The starting span is usually called the: `root span`. Its id is usually used as the id of a track record.\n\n* **Trace**: A tree-structured `Span` collection. For example: In a distributed big data store, each request may be a tracked record.\n\n* **Annotation**: Used to record the time information of an event. Some basic core annotations are used to record the start and end time of the request, for example:\n\n    * **cs**: short for `Client Sent`. This annotation indicates the start of a span;\n    * **sr**: short for `Server Received`. Indicates that the server receives the request and starts processing. The network transmission time can be calculated by subtracted the `cs` \n    * **ss**: the server completes the request processing, and the response information is sent back to the client (abbreviation of `Server Sent`). If you subtract the `sr` timestamp, you can calculate the time it takes for the server to process the request.\n    * **cr**: short for `Client Received`. Marks the end of `Span`. The client successfully received the response from the server. The response time of the request can be calculated by subtract the `cs`.\n\nThe following figure(https://cloud.spring.io/spring-cloud-sleuth/reference/html/) describes the concepts of `Span` and `Trace` in a visual way:\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nEach color in the picture represents a `span` (a total of 7 spans, from A to G). They all have the following data information:\n```\nTrace Id = X\nSpan Id = D\nClient Sent\n```\n\nWhich means he `Trace-Id` of the Span is `X`, and `Span-Id` of the Span is `D`, The corresponding event is `Client Sent`.\n\nThe subordinate relationships of these spans can be represented by the following figure (https://cloud.spring.io/spring-cloud-sleuth/reference/html/):\n{% asset_img 2.png %}\n<br/>\n<br/>\n\n## Integrate Zipkin services\n`Zipkin` is a distributed tracking system dedicated to collecting time data for distributed services. It mainly involves the following four components:\n* **collector**: data collection;\n* **storage**: data storage;\n* **search**: data query;\n* **UI**: Data display.\n\n`Zipkin` provides pluggable data storage methods: `In-Memory`, `MySql`, `Cassandra`, and `Elasticsearch`. The next test is to conveniently use the `In-Memory` method for storage. I personally recommend `Elasticsearch`, especially when we need to integrate `ELK` in the future.\n\n`Zipkin`'s source code on Github is: https://github.com/openzipkin/zipkin.\n\n> `Zipkin` requires JDK8 support.\n\nIn this article, we only provide tracking data to `Zipkin` through Http. I will explain it later when we talk about `Spring Cloud Bus` using the stream method.\n\n### 1. Zipkin-Server\nNote that now custom `zipkin` server is no longer supported. Refer to [Quick-start](https://github.com/openzipkin/zipkin) for starting the `zipkin` server instance.\n\n```\ncurl -sSL https://zipkin.io/quickstart.sh | bash -s\njava -jar zipkin.jar\n```\n\nThe default address is: http://localhost:9411/zipkin/.\n\n### 2. Modify Product-Service-Consumer\n#### Modify pom.xml\n\nAdd dependency:\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-zipkin</artifactId>\n</dependency>\n```\n\nAnd remove:\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-sleuth</artifactId>\n</dependency>\n```\n\nThis is because `spring-cloud-starter-sleuth` dependency is already included in `spring-cloud-starter-zipkin`.\n\n#### Modify application.properties\nAdd the following to application.properties:\n```\nspring.zipkin.base-url=http://localhost:9411\nspring.sleuth.sampler.percentage=1.0\n```\n\n`spring.zipkin.base-url` specifies the address of the `Zipkin` server, `spring.sleuth.sampler.percentage` sets the sampling ratio to 1.0, which is all required. About sampling can refer to the later description.\n\n### Modify Product-Service\nSame as above\n\n### Test\nStart the `Service-discovery`, `Zipkin-Server`, `Product-Service`, and `Product-Service-Consumer` projects in order.\n\n#### Check Zipkin server\nVisit: http://localhost:9411, can see the following:\n{% asset_img 3.png %}\n<br/>\n<br/>\n\n#### Visit Product-Service-Consumer to generate service calls\nWe visit the service provided by Mall-Web several times in the browser, and then go to the Zipkin server, you can see the following interface:\n{% asset_img 4.png %}\n<br/>\n<br/>\n\nWe can see that `Zipkin` has obtained several service call tracking information. We can click on one of these requests and see the following interface:\n{% asset_img 5.png %}\n<br/>\n<br/>\n\nThis interface presents the request in more detail. Similarly, we can click again to view more detailed data, we can see the following interface:\n{% asset_img 6.png %}\n<br/>\n<br/>\n\nIn this interface we can see the various time tracking information mentioned earlier.\n\nIn the Zipkin interface, we can also click `Dependencies` to view the dependencies between services, as shown below:\n{% asset_img 7.png %}\n<br/>\n<br/>\n\n#### Error message\n`Zipkin` can display error messages in trace records. When the exception is thrown and not caught, `Zipkin` will automatically change colors. In the list of trace records, when you see the red record, it means that an exception was thrown. As shown in the first figure above, the error message is displayed based on the data. We can also click into it for more detailed error information.\n\nCheck out the source code here: [Sleuth demo](https://github.com/nicklee1006/SpringCloudDemo/tree/master/sleuth)","categories":["Spring Cloud"]},{"title":"Leetcode 49. Group Anagrams","url":"/Leetcode-49-Group-Anagrams/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven multiple strings, categorize them. As long as the strings contain exactly the same characters, they are counted as the same class, regardless of order.\n\n### Similar Questions\n* Easy - [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)\n\n## Solution \nWe can sort each string alphabetically, then we can map `eat`, `tea`, `ate` to `aet`. Others are similar.\n\n``` Java\nHashMap<String, List<String>> map = new HashMap<>();\n\n// loop all strings\nfor (String str : strs) {\n    char[] charArray = str.toCharArray();\n\n    // sort\n    Arrays.sort(charArray);\n\n    String key = new String(charArray);\n\n    if (map.containsKey(key)) {\n        map.get(key).add(str);\n    } else {\n        List<String> tempList = new ArrayList<>();\n        tempList.add(str);\n\n        map.put(key, tempList);\n    }\n}\n\nreturn new ArrayList<>(map.values());\n```","tags":["Leetcode - Hash Table","Leetcode - String"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 98. Validate Binary Search Tree","url":"/Leetcode-98-Validate-Binary-Search-Tree/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven a tree, determine if the tree is a valid binary search tree. The binary search tree is defined as follows:\n\n* If the left subtree of any node is not empty, the values of all nodes on the left subtree are less than the value of its root node;\n* If the right subtree of any node is not empty, the value of all nodes on the right subtree is greater than the value of its root node;\n* The left and right subtrees of any node are also binary search trees;\n* There are no nodes with equal key values.\n\n### Similar Question\n* Medium - {% post_link Leetcode-94-Binary-Tree-Inorder-Traversal '94. Binary Tree Inorder Traversal' %}\n* Easy - [501. Find Mode in Binary Search Tree](https://leetcode.com/problems/find-mode-in-binary-search-tree/)\n\n## Solution - Recursion\nThe idea is that the left subtree is a legal binary search tree, the right subtree is a legal binary search tree, and the root node is larger than the largest number in the left subtree and smaller than the smallest number in the right subtree, then the current tree is a legal binary search tree\n\n## Solution - DFS\nIn previous solution, we are judging whether the root node is legal and found the largest number in the left subtree and the smallest number in the right subtree. The left and right subtrees determine whether the current root node is valid.\n\nBut normally, the root node comes first, it is reasonable to say that the root node could be any number rather than limited by the left and right subtrees. On the contrary, the root node determines the legal value range of the left and right subtree.\n\nTherefore, we can do DFS from the root node, then calculate the value range that each node should take, and return false if the current node does not match.\n\n```\n      10\n    /    \\\n   5     15\n  / \\    /  \n 3   6  7 \n\nConsider 10's range\n    10(-inf,+inf)\n\nConsider 5's range\n    10(-inf,+inf)\n    /\n5(-inf,10)\n\nConsider 3's range\n    10(-inf,+inf)\n     /\n   5(-inf,10)\n    /\n  3(-inf,5)  \n\nConsider 6's range\n    10(-inf,+inf)\n     /\n   5(-inf,10)\n    /       \\\n3(-inf,5)  6(5,10)\n\nConsider 15's range\n    10(-inf,+inf)\n    /          \\\n   5(-inf,10) 15(10,+inf）\n    /       \\\n3(-inf,5)  6(5,10)  \n\nConsider 7's range, if not match return false\n        10(-inf,+inf)\n         /           \\\n    5(-inf,10)     15(10,+inf）\n  /       \\           /\n3(-inf,5)  6(5,10)  7（10,15）\n```\n\nIt can be observed that the range of the left child is (left boundary of the parent node, the value of the parent node), and the range of the right child is (value of the parent node, the right boundary of the parent node).\n\nWe can pass Integer object, then null means negative infinity and positive infinity. Then use JAVA's auto boxing and unboxing, the value comparison can be directly used inequality sign.\n\n``` Java\npublic boolean isValidBST(TreeNode root) {\n    return isValid(root, null, null);\n}\n\n// every number has a valid range\n// For node on left tree: (min of parent node, value of parent node)\n// For node on right tree: (value of parent node, max of parent node)\nprivate boolean isValid(TreeNode node, Integer min, Integer max) {\n    if (node == null) {\n        return true;\n    }\n\n    if (min != null && node.val <= min) {\n        return false;\n    }\n\n    if (max != null && node.val >= max) {\n        return false;\n    }\n\n    return isValid(node.left, min, node.val) && isValid(node.right, node.val, max);\n}\n```","tags":["Leetcode - Tree","Leetcode - Depth First Search"],"categories":["Data Structure and Algorithms"]},{"title":"Java Bit Operations","url":"/Java-Bit-Operations/","content":"All data is stored in binary form in the computer. Bit operations are actually operations on the binary data in memory, so the data processing speed is very fast.\n\n## Bit operation basics\nThere are 6 basic bit operators: `And`, `Or`, `XOR`, `Complement`, `Left Shift`, and `Right Shift`. Their operation rules are as follows:\n\n<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle}\n.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n</style>\n<table class=\"tg\">\n  <tr>\n    <th class=\"tg-c3ow\">Symbol</th>\n    <th class=\"tg-c3ow\">Description</th>\n    <th class=\"tg-c3ow\">Rule</th>\n  </tr>\n  <tr>\n    <td class=\"tg-9wq8\">&amp;</td>\n    <td class=\"tg-9wq8\">And</td>\n    <td class=\"tg-0pky\">The result is 1 when both bits are 1</td>\n  </tr>\n  <tr>\n    <td class=\"tg-9wq8\">|</td>\n    <td class=\"tg-9wq8\">Or</td>\n    <td class=\"tg-0pky\">The result is 0 when both bits are 0</td>\n  </tr>\n  <tr>\n    <td class=\"tg-9wq8\">^</td>\n    <td class=\"tg-9wq8\">Xor</td>\n    <td class=\"tg-0pky\">0 if both bits are the same, 1 if they are different</td>\n  </tr>\n  <tr>\n    <td class=\"tg-9wq8\">~</td>\n    <td class=\"tg-9wq8\">Complement</td>\n    <td class=\"tg-0pky\">0 becomes 1, 1 becomes 0</td>\n  </tr>\n  <tr>\n    <td class=\"tg-9wq8\">&lt;&lt;</td>\n    <td class=\"tg-9wq8\">Left shift</td>\n    <td class=\"tg-0pky\">Each binary is shifted to the left by several bits, the high bits are discarded, and the low bits are padded with 0.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-9wq8\">&gt;&gt;</td>\n    <td class=\"tg-9wq8\">Right shift</td>\n    <td class=\"tg-0pky\">Each binary bit is shifted to the right by several bits. <br>Unsigned numbers, high-order bits are complemented with 0, and signed numbers. <br>Each compiler handles the method differently. <br>Some complement bits (arithmetic right shift), and some complement 0 (logical right shift).</td>\n  </tr>\n</table>\n\nNote:\n* Of these 6 operators, only `~` complement is a monocular operator, and the other 5 are binocular operators.\n* Bit operations can only be used for integer data. Bit operations on float and double types will be reported by the compiler as errors.\n* The bit operator has a lower precedence, so try to use parentheses to ensure the order of operations, otherwise you may get some inexplicable results. For example, to get `2^i + 1` numbers like 1, 3, 5, and 9. It is wrong to write `int a = 1 << i + 1`; Should be written as `int a = (1 << i) + 1`;\n\n### And (&)\n``` Java\nSystem.out.println(5 & 3);\n\n// Output: 1\n```\n\n5 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0101\n3 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0011\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------------------------\n1 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0001\n\n### Or (|)\n``` Java\nSystem.out.println(5 | 3);\n\n// Output: 7\n```\n\n5 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0101\n3 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0011\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------------------------\n7 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0111\n\n### Xor(^)\n``` Java\nSystem.out.println(5 ^ 3);\n\n// Output: 6\n```\n\n5 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0101\n3 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0011\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------------------------\n6 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0110\n\n### Complement (~)\n``` Java\nSystem.out.println(~5);\n\n// Output: -6\n```\n\n5 convert to binary: &nbsp;&nbsp;0000 0000 0000 0000 0000 0000 0000 0101\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------------------------\n-6 convert to binary: 1111 1111 1111 1111 1111 1111 1111 1010\n\n### Left shift (<<)\n``` Java\nSystem.out.println(5<<2);\n\n// Output: 20\n```\n\n5 convert to binary: &nbsp;&nbsp;0000 0000 0000 0000 0000 0000 0000 0101\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------------------------\n20 convert to binary: 0000 0000 0000 0000 0000 0000 0001 0100\n\n### Right shift (>>)\n``` Java\nSystem.out.println(5>>2);\n\n// Output: 1\n```\n\n5 convert to binary: &nbsp;&nbsp;0000 0000 0000 0000 0000 0000 0000 0101\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------------------------\n1 convert to binary: `00`00 0000 0000 0000 0000 0000 0000 0001\n\n## Common bit manipulation tips\n### Judging parity\nJust need to check the least significant bit is 0 or 1, 0 is even and 1 is odd. So we can use `if((a & 1) == 0)` instead of `if(a% 2 == 0)` to determine whether `a` is even. The following program will output all even numbers between 0 and 100:\n``` Java\nfor (int i = 0; i < 100; i ++) {\n    if ((i & 1) == 0) {\n        System.out.println(i);\n    }\n}\n```\n\n### Exchange two numbers\n``` Java\nint a = 1, b = 2;\na ^= b;\nb ^= a;\na ^= b;\n\nSystem.out.println(\"a  = \" + a);\nSystem.out.println(\"b = \" + b);\n\n// output\n// a = 2\n// b = 1\n```\n\n1. The first step `a^ = b` is `a = (a^b)`;\n2. The second step `b^ = a` is `b = b^(a^b)`. Since the OR operation satisfies the commutative law, `b^(a^b)` = `b^b^a`. Since the result of OR of a number and itself is 0 and the OR of any number and 0 is unchanged, `b` is assigned the value of `a`\n3. The third step `a^ = b` is `a = a^b`. Since the previous two steps show that `a = (a^b)` and `b = a`, `a = a^b` is `a = (a^b)^a`. So `a` is assigned the value of `b`.\n\n### Changing the sign\nChanging the sign means that positive numbers become negative numbers, and negative numbers become positive numbers. For -11 and 11, you can use the following transformation method to change -11 to 11\n\n```\n/ 11\n[0000 1011] Complement(~)-> [1111 0100]-> Add 1-> [1111 0101] (-11)\n\n// -11\n[1111 0101] Complement(~)-> [0000 1010]-> Add 1-> [0000 1011] (11)\n```\n\nSo we only need to complement the number and add 1.\n\n``` Java\nint a = -15, b = 15;\nSystem.out.println(~a + 1);\nSystem.out.println(~b + 1);\n```\n\n### Bit manipulation tips\n``` Java\n// 1. Get int max\nSystem.out.println((1 << 31) - 1); \nSystem.out.println(~(1 << 31));\n\n// 2. Get int min\nSystem.out.println(1 << 31);\nSystem.out.println(1 << -1);\n\n// 3. Get long max\nSystem.out.println(((long)1 << 127) - 1);\n\n// 4. times 2 operation\nSystem.out.println(10<<1);\n\n// 5. Divide by 2 (negative and odd operations are not available)\nSystem.out.println(10>>1);\n\n// 6. Multiplied by 2 to the power of m\nSystem.out.println(10<<2);\n\n// 7. Divide by 2 to the power of m\nSystem.out.println(16>>2);\n\n// 8. Determine the parity of a number\nSystem.out.println((10 & 1) == 1);\nSystem.out.println((9 & 1) == 1);\n\n// 9. Exchange two variables without temporary variables (interview quiz)\na ^= b;\nb ^= a;\na ^= b;\n\n// 10. Take the absolute value (on some machines, the efficiency is higher than n > 0? n: -n)\nint n = -1;\nSystem.out.println((n ^ (n >> 31)) - (n >> 31));\n/* \nn >> 31 gets the sign of n, if n is positive, n >> 31 is equal to 0, if n is negative, n >> 31 is equal to -1\nIf n is a positive number, n ^ 0-0 is unchanged. If n is a negative number n ^ -1, the complement of n and -1 needs to be calculated.\nResult n changes sign and subtracts 1 from the absolute value, minus -1 is the absolute value \n*/\n\n// 11. Take the maximum of two numbers (on some machines, the efficiency is higher than a > b? a : b)\nSystem.out.println(b&((a-b)>>31) | a&(~(a-b)>>31));\n\n// 12. Take the minimum of two numbers (on some machines, the efficiency is higher than a > b? b : a)\nSystem.out.println(a&((a-b)>>31) | b&(~(a-b)>>31));\n\n// 13. Determines whether the signs are the same (true means x and y have the same sign, false means x, y have the opposite sign.)\nSystem.out.println((a ^ b) > 0);\n\n// 14. Calculate the nth power of 2> 0\nSystem.out.println(2<<(n-1));\n\n// 15. Determine whether a number n is a power of two\nSystem.out.println((n & (n - 1)) == 0);\n/* If it is a power of 2, n must be 100 ... n-1 is 1111 ....So the result of the AND operation is 0 */\n\n// 16. Average two integers\nSystem.out.println((a+b) >> 1);\n\n// 17. From low to high, take the mth bit of n\nint m = 2;\nSystem.out.println((n >> (m-1)) & 1);\n\n// 18. From low to high. Set the mth bit of n to 1.\nSystem.out.println(n | (1<<(m-1)));\n/*\nShift 1 to the left by m-1 bits to find the mth bit, and get 000 ... 1 ... 000\nOr n with this number\n*/\n\n// 19. From low to high, set the mth bit of n to 0\nSystem.out.println(n & ~(0<<(m-1)));\n/* \nShift 1 to the left by m-1 bits to find the m-th bit, and invert it to 111 ... 0 ... 1111\nAND n and the number again\n*/\n```\n","categories":["Java"]},{"title":"Leetcode 94. Binary Tree Inorder Traversal","url":"/Leetcode-94-Binary-Tree-Inorder-Traversal/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nIn-order traversal of a binary tree.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-98-Validate-Binary-Search-Tree '98. Validate Binary Search Tree' %}\n* Medium - [144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\n* Medium - [145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)\n* Medium - [173. Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)\n* Medium - [230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)\n* Medium - [783. Minimum Distance Between BST Nodes](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)\n\n## Solution - Recursive\nUsing recursion to traverse a binary tree. This is one of the standard approach.\n\n``` Java\npublic List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n\n    getAnswer(root, result);\n\n    return result;\n}\n\n// standard way to traverse tree inorder. Recursive\nprivate static void getAnswer(TreeNode node, List<Integer> result) {\n    if (node == null) {\n        return;\n    }\n\n    getAnswer(node.left, result);\n    result.add(node.val);\n    getAnswer(node.right, result);\n}\n```\n\nTime complexity: O(n), traverse each node.\n\nSpace complexity: O(h), stack consumption, h is the height of the binary tree.\n\n## Solution - Stack\nUse the stack to simulate recursion.\n\nLet's look at an example:\n```\n        1\n      /   \\\n     2     3\n    / \\   /\n   4   5 6\n\n push   push   push   pop     pop    push     pop     pop \n|   |  |   |  |_4_|  |   |   |   |  |   |    |   |   |   |  \n|   |  |_2_|  |_2_|  |_2_|   |   |  |_5_|    |   |   |   |\n|_1_|  |_1_|  |_1_|  |_1_|   |_1_|  |_1_|    |_1_|   |   |\nans                  add 4   add 2           add 5   add 1\n[]                   [4]     [4 2]           [4 2 5] [4 2 5 1]\n \n push   push   pop          pop \n|   |  |   |  |   |        |   |  \n|   |  |_6_|  |   |        |   |  \n|_3_|  |_3_|  |_3_|        |   |\n              add 6        add 3\n              [4 2 5 1 6]  [4 2 5 1 6 3]\n```\n\nCode:\n``` Java\nList<Integer> result = new ArrayList<>();\nStack<TreeNode> stack = new Stack<>();\n\nTreeNode current = root;\nwhile (current != null || !stack.isEmpty()) {\n    // node is not null, push to stack\n    // push left first\n    while (current != null) {\n        stack.push(current);\n\n        current = current.left;\n    }\n\n    // node is null, pop\n    current = stack.pop();\n\n    // add to result\n    result.add(current.val);\n\n    // consider right tree\n    current = current.right;\n}\n\nreturn result;\n```\n\nTime complexity: O(n), traverse each node.\n\nSpace complexity: O(h), stack consumption, h is the height of the binary tree.\n\n## Solution - Morris traversal\n[Morris traversal](https://www.geeksforgeeks.org/morris-traversal-for-preorder/)","tags":["Leetcode - Tree","Leetcode - Hash Table","Leetcode - Stack"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 8: API Gateway - Zuul Part 2","url":"/Spring-Cloud-8-API-Gateway-Zuul-Part-2/","content":"The first impression of `Zuul` is usually like this: it includes two functions: `routing` and `filtering` requests. The routing function is responsible for forwarding external requests to specific microservice instances, which is the basis for achieving a unified entrance to external access. The filter function is responsible for intervening in the processing of requests, and is the basis for implementing functions such as request verification and service aggregation. However, in reality, when the routing function is running, its routing mapping and request forwarding are completed by several different filters. Among them, the route mapping is mainly completed by a `PRE` type filter, which matches the request path with the configured routing rule to find the destination address that needs to be forwarded. The part of the request forwarding is completed by the `Route` type filter, which forwards the routing address obtained by the `PRE` type filter. Therefore, the filter can be said to be the most important core component of `Zuul`'s API gateway. Every request entering `Zuul` will go through a series of filter processing chains to get the request response and return it to the client.\n\n## Filter Introduction\n### 1. Filter characteristics\nThe key features of `Zuul` filters are:\n\n* **Type**: Defines when to be executed during request execution;\n* **Execution Order**: When there are multiple filters, it is used to indicate the order of execution. The smaller the value, the earlier the execution;\n* **Criteria**: the conditions under which the filter will be triggered;\n* **Action**: The specific action.\n\nFilters do not communicate directly, but share information through `RequestContext`, which is `thread-safe`.\n\nCorresponding to the characteristics of the `Zuul` filter above, the methods we need to implement when implementing a custom filter are:\n\n``` Java\npublic class PreTypeZuulFilter extends ZuulFilter {\n    @Override\n    public String filterType() {\n        return PRE_TYPE;\n    }\n\n    @Override\n    public int filterOrder() {\n        return PRE_DECORATION_FILTER_ORDER - 1;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    @Override\n    public Object run() {\n        this.logger.info(\"This is pre-type zuul filter.\");\n        return null;\n    }\n}\n```\n\namong them:\n\n* The **filterType()** method is the type of the filter;\n* The **filterOrder()** method returns the execution order;\n* The **shouldFilter()** method is to determine whether the filter needs to be executed;\n* **run()** is the specific filtering action to be performed.\n\n### 2. Filter type\n`Zuul` defines four standard filter types, which correspond to the typical life cycle of a request.\n\n* **PRE filter**: called before the request is routed, it can be used to implement authentication, select the requested microservice in the cluster, record debugging information, etc;\n* **ROUTING filter**: called when routing requests;\n* **POST filter**: It is executed after routing to the microservice, and can be used to add standard HTTP headers to the response, collect statistics and indicators, send the response from the microservice to the client, etc;\n* **ERROR filter**: Called when an error occurs while processing the request.\n\nThe types of `Zuul` filters are actually the life cycle of `Zuul` filters. Use the following diagram to understand their execution process.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nIn addition to the 4 default filter types given above, `Zuul` allows us to create custom filter types. For example, we can customize a STATIC type filter to generate a response directly in `Zuul` without forwarding the request to the microservices on the backend.\n\n### 3. Custom filter example code\nTake a look at a few examples given by the official：\n\n#### PRE type example\n\n[QueryParamServiceIdPreFilter](https://github.com/spring-cloud-samples/sample-zuul-filters/blob/master/src/main/java/org/springframework/cloud/samplezuulfilters/QueryParamServiceIdPreFilter.java)\n\n``` Java\npublic class QueryParamPreFilter extends ZuulFilter { \n    public int filterOrder() {\n\t\t// run before PreDecorationFilter\n\t\treturn PRE_DECORATION_FILTER_ORDER - 1;\n\t}\n\n\tpublic String filterType() {\n\t\treturn \"pre\";\n\t}\n\n\t@Override\n\tpublic boolean shouldFilter() {\n\t\tRequestContext ctx = getCurrentContext();\n\t\treturn ctx.getRequest().getParameter(\"service\") != null;\n\t}\n\n\tpublic Object run() {\n\t\tRequestContext ctx = getCurrentContext();\n\t\tHttpServletRequest request = ctx.getRequest();\n\t\t// put the serviceId in `RequestContext`\n\t\tctx.put(\"serviceId\", request.getParameter(\"service\"));\n\t\treturn null;\n\t}\n}\n```\n\nThis example obtains the `serviceID` to be forwarded from the request parameter `service`. Of course, it's not recommended, here is just an example.\n\n#### ROUTE type example\n\n[OkHttpRoutingFilter](https://cloud.spring.io/spring-cloud-static/Dalston.SR5/multi/multi__router_and_filter_zuul.html)\n\n``` Java\npublic class OkHttpRoutingFilter extends ZuulFilter {\n    @Autowired\n    private ProxyRequestHelper helper;\n\n    @Override\n    public String filterType() {\n        return ROUTE_TYPE; \n    }\n\n    @Override\n    public int filterOrder() {\n        return SIMPLE_HOST_ROUTING_FILTER_ORDER - 1; \n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return RequestContext.getCurrentContext().getRouteHost() != null && RequestContext.getCurrentContext().sendZuulResponse();\n    }\n    \n    @Override\n    public Object run() {\n        OkHttpClient httpClient = new OkHttpClient.Builder() \n            // customize\n            .build();\n\n        RequestContext context = RequestContext.getCurrentContext(); \n        HttpServletRequest request = context.getRequest();\n        \n        String method = request.getMethod();\n\n        String uri = this.helper.buildZuulRequestURI(request);\n\n        Headers.Builder headers = new Headers.Builder(); \n        Enumeration<String> headerNames = request.getHeaderNames(); \n        while (headerNames.hasMoreElements()) {\n            String name = headerNames.nextElement(); \n            Enumeration<String> values = request.getHeaders(name);\n\n            while (values.hasMoreElements()) { \n                String value = values.nextElement(); \n                headers.add(name, value);\n            }\n        }\n\n        InputStream inputStream = request.getInputStream();\n\n        RequestBody requestBody = null;\n        if (inputStream != null && HttpMethod.permitsRequestBody(method)) {\n            MediaType mediaType = null;\n            if (headers.get(\"Content-Type\") != null) {\n                mediaType = MediaType.parse(headers.get(\"Content-Type\")); \n            }\n            requestBody = RequestBody.create(mediaType, StreamUtils.copyToByteArray(inputStream)); \n        }\n\n        Request.Builder builder = new Request.Builder()\n            .headers(headers.build())\n            .url(uri)\n            .method(method, requestBody);\n\n        Response response = httpClient.newCall(builder.build()).execute();\n\n        LinkedMultiValueMap<String, String> responseHeaders = new LinkedMultiValueMap<>();\n        for (Map.Entry<String, List<String>> entry : response.headers().toMultimap().entrySet()) { \n            responseHeaders.put(entry.getKey(), entry.getValue());\n        }\n\n        this.helper.setResponse(response.code(), response.body().byteStream(), responseHeaders);\n        context.setRouteHost(null); // prevent SimpleHostRoutingFilter from running\n        return null; \n    }\n}\n```\n\nThis example converts an HTTP request to an OkHttp3 request, and converts the server's return into a servlet's response.\n\n#### POST type example\n\n[AddResponseHeaderFilter](https://github.com/spring-cloud-samples/sample-zuul-filters/blob/master/src/main/java/org/springframework/cloud/samplezuulfilters/AddResponseHeaderFilter.java)\n\n``` Java\npublic class AddResponseHeaderFilter extends ZuulFilter {\n\tpublic String filterType() {\n\t\treturn \"post\";\n\t}\n\n\tpublic int filterOrder() {\n\t\treturn 999;\n\t}\n\n\tpublic boolean shouldFilter() {\n\t\treturn true;\n\t}\n\n\tpublic Object run() {\n\t\tRequestContext context = RequestContext.getCurrentContext();\n\t\tHttpServletResponse servletResponse = context.getResponse();\n\t\tservletResponse.addHeader(\"X-Foo\", UUID.randomUUID().toString());\n\t\treturn null;\n\t}\n}\n```\n\nThis example is just adding a randomly generated X-Foo to the returned header.\n\n### 4. Disable filter\nOnly need to configure the filter to be disabled in `application.properties`(or yml), the format is: \n```\nzuul. [Filter-name]. [Filter-type] .disable = true\n```\n\nSuch as:\n```\nzuul.FormBodyWrapperFilter.pre.disable=true\n```\n\n### 5. A little supplement about Zuul filter Error\nWhen `Zuul` throws an exception during execution, the error filter is executed. `SendErrorFilter` will only execute if `RequestContext.getThrowable()` is not empty. It sets the error information into the requested `javax.servlet.error.*` properties and forwards to Spring Boot's error page.\n\nThe specific class implemented by `Zuul` filters is `ZuulServletFilter`, whose core code is as follows:\n``` Java\n@Override\npublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n    try {\n        init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);\n        try {\n            preRouting();\n        } catch (ZuulException e) {\n            error(e);\n            postRouting();\n            return;\n        }\n        \n        // Only forward onto to the chain if a zuul response is not being sent\n        if (!RequestContext.getCurrentContext().sendZuulResponse()) {\n            filterChain.doFilter(servletRequest, servletResponse);\n            return;\n        }\n        \n        try {\n            routing();\n        } catch (ZuulException e) {\n            error(e);\n            postRouting();\n            return;\n        }\n        try {\n            postRouting();\n        } catch (ZuulException e) {\n            error(e);\n            return;\n        }\n    } catch (Throwable e) {\n        error(new ZuulException(e, 500, \"UNCAUGHT_EXCEPTION_FROM_FILTER_\" + e.getClass().getName()));\n    } finally {\n        RequestContext.getCurrentContext().unset();\n    }\n}\n```\n\nIt can be seen from this code that error can be executed after catching exceptions in all stages, but if an exception occurs in the post stage and is handled by error, it will not be returned to the post stage for execution, which means that there should be no exceptions in the post stage. Because once there is an exception, other post filters behind this filter will no longer be executed.\n\nA simple method for global exception handling is: Add a filter of type error and write the error information to the `RequestContext` so that `SendErrorFilter` can get the error information. Code show as below:\n``` Java\npublic class GlobalErrorFilter extends ZuulFilter { \n    @Override\n    public String filterType() { \n        return ERROR_TYPE;\n    }\n    \n    @Override\n    public int filterOrder() {\n        return 10; \n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true; \n    }\n\n    @Override\n    public Object run() {\n        RequestContext context = RequestContext.getCurrentContext();\n        Throwable throwable = context.getThrowable();\n        this.logger.error(\"[ErrorFilter] error message: {}\", throwable.getCause().getMessage());\n        context.set(\"error.status_code\", HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        context.set(\"error.exception\", throwable.getCause());\n        return null;\n    }\n}\n```\n\n## @EnableZuulServer VS @EnableZuulProxy\n`Zuul` provides us with two main application annotations: `@EnableZuulServer` and `@EnableZuulProxy`, where `@EnableZuulProxy` contains the functionality of `@EnableZuulServer`, and `@EnableCircuitBreaker` and `@EnableDiscoveryClient` are also added. When we need to run a `Zuul` service without proxy function, or selectively switch some proxy functions, then we need to use `@EnableZuulServer` instead of `@EnableZuulProxy`. At this time we can add any `ZuulFilter` type entity class. They will be automatically loaded, which is the same as the previous article using `@EnableZuulProxy`, but it will not automatically load any proxy filters.\n\n### 1 @EnableZuulServer's default filter\nWhen we use `@EnableZuulServer`, the filters loaded by default are:\n\n#### PRE type filter\n* ServletDetectionFilter\nThis filter is executed first. It is mainly used to check whether the current request is processed through Spring's `DispatcherServlet` or processed through `ZuulServlet`. The result is stored in `isDispatcherServletRequest`, and the value type is Boolean.\n\n* FormBodyWrapperFilter\nThe purpose of this filter is to wrap the request body that meets the requirements into a `FormBodyRequestWrapper` object for subsequent processing.\n\n* DebugFilter\nPRE type filter. When the debug parameter is set in the request parameter, this filter will set `RequestContext.setDebugRouting()` and `RequestContext.setDebugRequest()` to true in the current request context, so that subsequent filters can define some debug information based on these two parameters. When there is a problem in the production environment, we can add the parameter to print debugging information in the background to help us analyze the problem. For the name of the debug parameter in the request, we can customize it through `zuul.debug.parameter`.\n\n#### Route type filter\n* SendForwardFilter\nThis filter only processes requests with the `forward.to`(FilterConstants.FORWARD_TO_KEY) parameter in the request context. That is, the local forward of the forward in our routing rule is processed.\n\n#### POST type filter\n* SendResponseFilter\nThe filter is to encapsulate the response returned by the proxy request, and then send it back to the requester as the corresponding request.\n\n#### ERROR type filter\n* SendErrorFilter\nThe filter is to determine if there is any exception information in the current request context (`RequestContext.getThrowable ()` is not empty), and if there is, it is forwarded to the `/error` page by default. We can also customize the error page by setting `error.path`.\n\n### 2 @EnableZuulProxy's default filter\n`@EnableZuulProxy` adds the following filters to the above:\n\n#### PRE type filter\n* PreDecorationFilter\nThis filter determines the route to the route and how to route based on the provided `RouteLocator`. The router can also set various proxy-related headers for back-end requests.\n\n#### ROUTE type filter\n* RibbonRoutingFilter\nThis filter will process the request with `serviceId` (can be obtained through `RequestContext.getCurrentContext().Get (\"serviceId\"))` in the context, use `Ribbon`, `Hystrix` and pluggable HTTP client to send the request, and return the result of the request. That is to say that `Ribbon` and `Hystrix` only take effect when we use the `serviceId` to configure routing rules.\n\n* SimpleHostRoutingFilter\nWhen this filter detects that the `routeHost` parameter (available through `RequestContext.getRouteHost()`) is set, it will send a request to the specified URL through Apache HttpClient. At this point, the request is not wrapped with `Hystrix` commands, so this type of request does not have thread isolation and circuit breaker protection.","categories":["Spring Cloud"]},{"title":"Leetcode 93. Restore IP Addresses","url":"/Leetcode-93-Restore-IP-Addresses/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nGive a string and output all possible IP addresses. Note that results like 01.1.001.1 which starts with 0 is an illegal string.\n\n## Solution - Brute Force\nBecause we know that the string needs to be divided into 4 parts, we directly use three loops to force the string into four parts, traverse all the divisions, and then choose a valid solution.\n\n``` Java\npublic List<String> restoreIpAddresses(String s) {\n    List<String> results = new ArrayList<>();\n\n    if (s.length() > 12 || s.length() < 4) {\n        return results;\n    }\n\n    // first field 1,2,3 digit\n    for (int i = 0; i < 4 && i < s.length() - 2; i++) {\n        // second field 1,2,3 digit\n        for (int j = i + 1; j < i + 4 && j < s.length() - 1; j++) {\n            // third field 1,2,3 digit\n            for (int k = j + 1; k < j + 4 && k < s.length(); k++) {\n                String s1 = s.substring(0, i);\n                String s2 = s.substring(i, j);\n                String s3 = s.substring(j, k);\n                String s4 = s.substring(k);\n\n                if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\n                    results.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\n                }\n            }\n        }\n    }\n\n    return results;\n}\n\n// 1 <= length <= 3\n// between 0 - 255\n// or 0\nprivate boolean isValid(String subString) {\n    return subString.length() != 0 && subString.length() <= 3 && Integer.parseInt(subString) <= 255 && (subString.charAt(0) != '0' || subString.length() <= 1);\n}\n```\n\n## Solution - Backtracking\nThis question is actually dividing a string, and the number of divisions has been determined, which is 4 parts. So we can use the idea of backtracking directly. The first part may be 1 digit, and then enter the recursion. The first part may be 2 digits and then go into recursion. The first part might be 3 digits and then go into recursion.\n\n``` Java\npublic List<String> restoreIpAddresses(String s) {\n    List<String> results = new ArrayList<>();\n\n    getResults(s, 0, new StringBuilder(), results, 0);\n\n    return results;\n}\n\n/**\n * @param:  start start of string\n * @param:  temp already partitioned part\n * @param:  ans results\n * @param:  count how many parts\n */\nprivate void getResults(String s, int start, StringBuilder temp, List<String> result, int count) {\n    // If remaining length >= remaining part * 3\n    // e.g. s = 121231312312, length = 12\n    // current start = 1，count = 1\n    // remaining length 11，remaining part 4 - count = 3，at most 3 * 3 = 9\n    // so it's impossible\n    if ((s.length() - start) > (3 * (4 - count))) {\n        return;\n    }\n\n    // reaching the end\n    if (start == s.length()) {\n        // already formed 4 parts\n        if (count == 4) {\n            result.add(temp.substring(0, temp.length() - 1));\n        }\n\n        return;\n    }\n\n    if (start > s.length() || count == 4) {\n        return;\n    }\n\n    // save current\n    StringBuilder before = new StringBuilder(temp);\n\n    // add 1 digit\n    temp.append(s.charAt(start) + \"\" + '.');\n    getResults(s, start + 1, temp, result, count + 1);\n\n    // if start with 0\n    if (s.charAt(start) == '0') {\n        return;\n    }\n\n    // add 2 digit\n    if (start + 1 < s.length()) {\n        // restore to before\n        temp = new StringBuilder(before);\n\n        temp.append(s.substring(start, start + 2) + \"\" + '.');\n\n        getResults(s, start + 2, temp, result, count + 1);\n    }\n\n    // add 3 digit\n    if (start + 2 < s.length()) {\n        // restore to before\n        temp = new StringBuilder(before);\n\n        int num = Integer.parseInt(s.substring(start, start + 3));\n\n        // check if numbber is valid\n        if (num >= 0 && num <= 255) {\n            temp.append(s.substring(start, start + 3) + \"\" + '.');\n            getResults(s, start + 3, temp, result, count + 1);\n        }\n    }\n}\n```","tags":["Leetcode - Backtracking","Leetcode - String"],"categories":["Data Structure and Algorithms"]},{"title":"Java PriorityQueue","url":"/Java-PriorityQueue/","content":"## PriorityQueue\nThe `PriorityQueue` class was introduced in `Java 1.5`.\n\n`PriorityQueue` is an unbounded queue based on the `priority heap`. Elements in the priority queue can be sorted naturally by default or provided `Comparator` when the queue is instantiated. When `Comparator` is not specified, it is default to a `minimum` heap.\n\n`PriorityQueue` does not allow `null` values and does not support non-comparable objects, such as user-defined classes. Priority queues require Java `Comparable` and `Comparator` interfaces to sort objects, and the elements in them are processed according to priority when sorting.\n\nThe size of the `PriorityQueue` is unlimited, but you can specify an initial size when you create it. When we add elements to the priority queue, the queue size will automatically increase.\n\n`PriorityQueue` is **not thread-safe**, so Java provides `PriorityBlockingQueue` (implements the `BlockingQueue` interface) for Java multi-threaded environments.\n\nExample:\n\n``` Java\npublic class PriorityQueueExample {\n    public static void main(String[] args) {\n        Queue<Integer> priorityQueue = new PriorityQueue<Integer>();\n        priorityQueue.add(2);\n        priorityQueue.add(1);\n        priorityQueue.add(3);\n\n        while (!priorityQueue.isEmpty()) {\n            Integer i = priorityQueue.poll();\n            System.out.println(i);\n        }\n\n        Comparator<Item> comparator = new Comparator<Item>() {\n            @Override\n            public int compare(Item o1, StuItemdent o2) {\n                return (o1.price - o2.price);\n            }\n        };\n\n        Queue<Item> priorityQueue2 = new PriorityQueue<Item>(comparator);\n        priorityQueue2.add(new Item(\"B\", 2));\n        priorityQueue2.add(new Item(\"A\", 1));\n        priorityQueue2.add(new Item(\"C\", 3));\n\n        while (!priorityQueue2.isEmpty()) {\n            Item s = priorityQueue2.poll();\n            System.out.println(s.toString());\n        }\n    }\n\n    public static class Item {\n        private String name;\n        private double price\n\n        public Item(String name, double price) {\n            this.name = name;\n            this.price = price;\n        }\n\n        public String toString() {\n            return name + \"-\" + price;\n        }\n    }\n}\n```\n\nOutput:\n```\n1\n2\n3\nA-1\nB-2\nC-3\n```\n\n## How PriorityQueue is implemented\n> Implemented through the heap, specifically a small top heap implemented through a complete binary tree (the weight of any non-leaf node is not greater than the weight of its left and right child nodes), which means that array can be used as the underlying implementation of `PriorityQueue`.\n\n``` Java\n/**\n * Priority queue represented as a balanced binary heap: the two\n * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The\n * priority queue is ordered by comparator, or by the elements'\n * natural ordering, if comparator is null: For each node n in the\n * heap and each descendant d of n, n <= d.  The element with the\n * lowest value is in queue[0], assuming the queue is nonempty.\n */\ntransient Object[] queue; // non-private to simplify nested class access\n\n/**\n * The number of elements in the priority queue.\n */\nint size;\n```\n\nThe relationship between the index of parent and child nodes is as follows:\n* leftNo   = parentNo * 2 + 1\n* rightNo  = parentNo * 2 + 2\n* parentNo = (nodeNo-1) / 2\n\nThe time complexity of the `add(E e)` and `offer(E e)` operations is log(N):\n``` Java\npublic boolean add(E e) {\n    return offer(e);\n}\n    \npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n        \n    modCount++;\n    int i = size;\n\n    if (i >= queue.length)\n        grow(i + 1);\n\n    siftUp(i, e);\n    size = i + 1;\n\n    return true;\n}\n```\n\nThe time complexity of the `poll()` operation is log (N):\n\n``` Java\npublic E poll() {\n    final Object[] es;\n    final E result;\n\n    if ((result = (E) ((es = queue)[0])) != null) {\n        modCount++;\n        final int n;\n        final E x = (E) es[(n = --size)];\n        es[n] = null;\n        if (n > 0) {\n            final Comparator<? super E> cmp;\n            if ((cmp = comparator) == null)\n                siftDownComparable(0, x, es, n);\n            else\n                siftDownUsingComparator(0, x, es, n, cmp);\n        }\n    }\n    return result;\n}\n```","tags":["Java Collections"],"categories":["Java"]},{"title":"Leetcode 3. Longest Substring Without Repeating Characters","url":"/Leetcode-3-Longest-Substring-Without-Repeating-Characters/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven a string, find the longest substring without repeated characters and return its length.\n\n### Similar Questions\n* Hard - [992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/)\n\n## Solution - Brute Force\nThe most straightforward method. We use two loops to exhaust all substrings, and then use a function to determine whether there are duplicate characters in the substring.\n\nTime complexity: two loops, plus the loop in the function that determines whether the substring satisfies the conditions, O(n<sup>3</sup>).\n\nSpace complexity: A set is used to determine whether there are duplicate characters in the substring. Since there are no repeated characters in the set, the longest possible one is the entire character set. Assuming the size of the character set is `m`, then the longest length of the set is `m`. On the other hand, if the length of the string is less than `m`, it is `n`. Then the longest set is `n`. In summary, the space complexity is O(min(m, n)).\n\n## Solution - Sliding Window\nIn the above solution, we assume that when `i` takes 0,\n\n`j` is set to `1`, to determine whether there are duplicate characters in the string `str[0,1)`.\n\n`j` is set to `2` to determine whether there are duplicate characters in the string `str[0,2)`.\n\n`j` is set to `3` to determine if there are any duplicate characters in the string `str[0,3)`.\n\n`j` is set to `4` to determine whether there are duplicate characters in the string `str[0,4)`.\n\nThere are a lot of repetitive work, because if there are no repeated characters in `str[0,3)`, we don't need to determine whether there are repeated characters in the entire string `str[0,4)`, but only need to determine whether `str[3]` is in `str[0,3)` or not. \n\nIf it's not, it means that there are no duplicate characters in `str[0,4)`.\n\nIf it is, then `str[0,5)`, `str[0,6)`, `str[0,7)` must have duplicate characters. So at this time, there is not need to continue loop with `j`, just `i++` to enter the next loop.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nWe can see the process as the orange window moving to the right.\n\nTo determine whether a character is in the string, we can put the char in the `map`. The char is the key and it's index is the value. So that we know the last occurance of a char in the string.\n\nWe can further optimize it. Let's look at the example.\n\n{% asset_img 2.png %}\n<br/>\n<br/>\n\nWhen the `c` pointed to by `j` exists in the preceding substring `abcd`, `i` is moved forward to `b` at this time, and the substring still contains `c`, and `i` must continue to move, so it can be optimized here. We can move `i` directly to the next position of `c`!\n\n``` Java\nint result = 0;\n\nMap<Character, Integer> tempMap = new HashMap<>();\n\nfor (int i = 0, j = 0; j < s.length(); j++) {\n    // find repeat, skip i - j'\n    if (tempMap.containsKey(s.charAt(j))) {\n        i = Math.max(tempMap.get(s.charAt(j)), i);\n    }\n\n    result = Math.max(result, j - i + 1);\n    // j + 1 means next time i will be move directly to here\n    tempMap.put(s.charAt(j), j + 1);\n}\n\nreturn result;\n```\n\nBecause `i` is jumping, the characters stored before map are not removed, so `Math.max(map.get(s.charAt(j)), i)` is used to make sure that the obtained index is not in front of `i`.\n\n`j` is incremented by 1 for each loop, because the jump of `i` already guarantees that there are no duplicate in `str[i, j]`.","tags":["Leetcode - Two Pointers","Leetcode - Hash Table","Leetcode - String","Leetcode - Sliding Window"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 60. Permutation Sequence","url":"/Leetcode-60-Permutation-Sequence/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven an n, not to output its full permutation, but to arrange all combinations from small to large, and output the kth.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-31-Next-Permutation '31. Next Permutation' %}\n* Medium - {% post_link Leetcode-46-Permutations '46. Permutations' %}\n\n## Solution\nTake `n = 4` as an example. Because it is arranged from small to large, the highest digit must be from 1 to 4. Then it can be seen as a group, we only need to look for the group number to know what the highest digit is. And the number of each group is the `(n-1)!`.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nWhen calculating the `group number`, 1 to 5 divided by 6 is 0, 6 divided by 6 is 1, and 6 belongs to group 0, so we need to subtract 1 from k. By doing this, the division results are all 0.\n\n``` Java\nint perGroupNum = factorial(n - 1); \nint groupNum = (k - 1) / perGroupNum;\n```\n\nOf course, there is also the question of what `k` is next time. Divide the group number, and the remainder is the next `k`. Because `k` is counted from 1, if `k` is exactly equal to a multiple of `perGroupNum`, the remainder obtained at this time is 0. In fact, since we subtract 1 when we ask for `groupNum`, `k` should be updated to `perGroupNum` at this time.\n\n``` Java\nk = k % perGroupNum; \nk = k == 0 ? perGroupNum : k;\n```\n\nFor example, if `k = 6`, then `groupNum = (k-1) / 6 = 0`, `k % perGroupNum = 6% 6 = 0`, and the next `k` can be seen from the above figure, it is obviously `perGroupNum`, which is still 6.\n\nAfter determining that the highest digit belongs to `group 0`, then the next is the same as the above process. The only difference is that the highest digit is `2 3 4` and there is no `1`. How to get the highest digit of `groupNum` needs to be considered.\n\nWe can use a list to save 1 to n from small to large, and remove one digit each time, so that we can get the number corresponding to `groupNum`.\n\nCombine then together, we get the following solution.\n\n``` Java\n// record `n!`, keep it here to speed up\nprivate Map<Integer, Integer> factorialTable = new HashMap<>();\n\npublic String getPermutation(int n, int k) {\n    List<Integer> nums = new ArrayList<>();\n\n    // put 1 - n to a list\n    for (int i = 1; i <= n; i++) {\n        nums.add(i);\n    }\n\n    return getResult(nums, n, k);\n}\n\n// nums initially is '1,2,3,4,5,....n'\nprivate String getResult(List<Integer> nums, int n, int k) {\n    StringBuilder stringBuilder = new StringBuilder();\n\n    while (n > 1) {\n        // permutation starting with the same number is a group\n        // how many number in each group? n!\n        // e.g. if n = 3, each group has 2 numbers\n        int numPerGroup = factorial(n - 1);\n        // which group is our target number in\n        int groupNum = (k - 1) / numPerGroup;\n\n        stringBuilder.append(nums.get(groupNum));\n\n        k = k % numPerGroup;\n        k = k == 0 ? numPerGroup : k;\n\n        nums.remove(groupNum);\n        n--;\n    }\n\n    stringBuilder.append(nums.get(0));\n\n    return stringBuilder.toString();\n}\n\nprivate int factorial(int n) {\n    if (n == 1) {\n        factorialTable.put(n, 1);\n        return 1;\n    } else {\n        if (factorialTable.containsKey(n - 1)) {\n            int result = n * factorialTable.get(n - 1);\n            factorialTable.put(n, result);\n            return result;\n        } else {\n            int result = n * factorial(n - 1);\n            factorialTable.put(n, result);\n            return result;\n        }\n    }\n}\n```","tags":["Leetcode - Backtracking","Leetcode - Math"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 7: API Gateway - Zuul Part 1","url":"/Spring-Cloud-7-API-Gateway-Zuul-Part-1/","content":"With microservices architecture, each microservice exposes a set of fine-grained services to the outside. The client's request may involve a series of service calls. If all these microservices are exposed to the client, the client needs to request different microservices multiple times to complete a business process, increasing the code complexity at the client side. In addition, for microservices, we may also need unified authentication and verification of service calls and so on. Although the microservice architecture can divide our development unit into smaller pieces and reduce the development difficulty, if we cannot effectively deal with the problems mentioned above, it may cause the implementation of the microservice architecture to fail.\n\n`Zuul` refers to the `Facade pattern` in the GOF design pattern, and combines fine-grained services to provide a coarse-grained service. All requests are imported into a unified entrance. Then the entire service only needs to expose an API, which shields the server-side implementation details. It also reduces the number of client-server network calls. This is the `API Gateway` service. We can think of the `API Gateway` as an intermediate layer between the client and the server. All external requests will first pass through the `API Gateway`. Therefore, the `API Gateway` has almost become a must choice when implementing a microservice architecture.\n\nThe `Zuul` component of `Spring Cloud Netflix` can be used as `a reverse proxy`, forwarding requests to coarse-grained services on the back end through `routing addressing`, and doing some general logic processing.\n\nWith `Zuul` we can complete the following functions:\n* **Dynamic routing**\n* **Monitoring and review**\n* **Authentication and security**\n* **Stress test**: gradually increase the traffic of a service cluster to understand the service performance;\n* **Canary test**\n* **Service migration**\n* **Load tailoring**: Allocate the corresponding capacity for each load type and discard requests that exceed the limit;\n* **Static response processing**\n\n# *Why we need API Gateway*\n\n## Simplify client call complexity\nUnder microservice architecture, the number of instances of the backend service is generally dynamic, and it is difficult for the client to find the address information of the dynamically changed service instance. Therefore, in order to simplify the front-end call logic in microservice-based projects, `API Gateway` is usually introduced as a lightweight gateway. At the same time, `API Gateway` will also implement related authentication logic to simplify the complexity of mutual calls between internal services.\n\n## Data clipping and aggregation\nGenerally speaking, different clients have inconsistent requirements for data during display, such as mobile phones or Web terminals, or in low-latency network environments or high-latency network environments.\n\nTherefore, in order to optimize the client's experience, `API Gateway` can tailor the general response data to meet the needs of different clients. At the same time, multiple API calls can be aggregated to reduce the number of client requests and optimize the client user experience.\n\n## Multi-channel support\nOf course, we can also provide different `API Gateways` for different channels and clients. The use of this mode is another well-known method called `Backend for front-end`. In `Backend for front-end` mode, we can target different client to create its `BFF` separately. For more information about `BFF`, please refer to this article: [Pattern: Backends For Frontends](https://samnewman.io/patterns/architectural/bff/)\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\n# *Example Project*\n## Zuul-Server\n### 1. pom.xml\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-zuul</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\n</dependency>\n```\n\n### 2. Main class\n``` Java\n@EnableZuulProxy\n@SpringBootApplication\npublic class ZuulServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ZuulServerApplication.class, args);\n    }\n}\n```\n\nAdded `@EnableZuulProxy` annotation to the main application class to start Zuul's routing service.\n\n### 3. application.properties\n``` Java\nserver.port=8280\n\nspring.application.name=ZUUL-PROXY\n\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n\nmanagement.endpoints.web.exposure.include=hystrix.stream\n```\n\n## User-Service\nWe add another service: `User-Service` here.\n\n### 1. pom.xml\n``` Xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n### 2. Main class\n``` Java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class UserServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(UserServiceApplication.class, args);\n    }\n}\n```\n\nThis is the same as `Product-Service`.\n\n### 3. User entity\n``` Java\npublic class User {\n    private String loginName;\n    private String name;\n    private String avatar;\n    private String memos;\n\n    public User(String loginName, String name, String avatar, String memos) {\n        this.loginName = loginName;\n        this.name = name;\n        this.avatar = avatar;\n        this.memos = memos;\n    }\n\n    public String getLoginName() {\n        return loginName;\n    }\n\n    public void setLoginName(String loginName) {\n        this.loginName = loginName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAvatar() {\n        return avatar;\n    }\n\n    public void setAvatar(String avatar) {\n        this.avatar = avatar;\n    }\n\n    public String getMemos() {\n        return memos;\n    }\n\n    public void setMemos(String memos) {\n        this.memos = memos;\n    }\n}\n```\n\n### 4. User service\n``` Java\n@RestController\n@RequestMapping(\"/users\")\npublic class UserEndpoint {\n    private static final Logger LOGGER = LoggerFactory.getLogger(UserEndpoint.class);\n\n    @Value(\"${server.port:2200}\")\n    private int serverPort = 2200;\n\n    @RequestMapping(value = \"/{loginName}\", method = RequestMethod.GET)\n    public User detail(@PathVariable String loginName) {\n        String memos = \"I come form \" + this.serverPort;\n        return new User(loginName, loginName, \"/avatar/default.png\", memos);\n    }\n}\n```\n\nThe interface is very simple, just  query a user's information based on the given login name.\n\n### 5. application.properties\n``` Java\nserver.port=2200\n\nspring.application.name=USER-SERVICE\n\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n```\n\n## Testing\n### 1. Launch services\nStart each server in the following order:\n1. Service-discovery\n2. User-Service(2200)\n3. User-Service(2300): `java -jar user-service-1.0.0-SNAPSHOT.jar --server.port=2300`\n4. Zuul-Server\n\nWe can see the eureka admin page:\n{% asset_img 2.png %}\n<br/>\n<br/>\n\n### 2. Test routing\nVisit: http://localhost:8280/user-service/users/admin\n{% asset_img 4.png %}\n<br/>\n<br/>\n\nNote that here we used service name to retrieve the relevant servicie.\n\n### 3. Load balance testing\nLet's test if load balancing works. Earlier we have started two `User-Service` microservices, the ports are: 2200 and 2300. Try visit: http://localhost:8280/user-service/users/admin to make a request, we will see that the following information will be output alternately on the screen:\n\n{% asset_img 4.png %}\n<br/>\n<br/>\n\n{% asset_img 3.png %}\n<br/>\n<br/>\n\n### 4. Hystrix fault tolerance and monitoring test\nWe have integrated `Hystrix` monitoring in `Zuul-Server`. Visit: http://localhost:8280/hystrix/ and enter: http://localhost:8280/actuator/hystrix.stream to start monitor.\n\n{% asset_img 5.png %}\n<br/>\n<br/>\n\nThis means that `Zuul` has integrated `Hystrix`.\n\n> `Spring-cloud-starter-netflix-zuul` itself has integrated `hystrix` and `ribbon`, so `Zuul` is inherently equipped with `thread isolation` and `circuit breaker` self-protection capabilities, as well as `client load balancing` for service calls. However, we need to note that when using the mapping relationship between `path` and `url` to configure routing rules, requests for routing will not be wrapped with `HystrixCommand`, so this type of routing request has no thread isolation and circuit breaker protection functions, and also there will be no load balancing capabilities. Therefore, when using `Zuul`, we try to use a combination of `path` and `serviceId` to configure. This not only can ensure the robustness and stability of the API gateway, but also can use `Ribbon`'s client load balancing function.\n\n# *Zuul Configuration*\n## Routing configuration\nMaybe you think it’s strange that we didn’t configure anything, but can access service through http://localhost:8280/user-service/users/admin. This is the default route mapping function of `Zuul`, so let's take a look at how to configure routing in `Zuul`.\n\n### 1. Service routing default rules\nWhen we used `Eureka` to built the `API gateway`, `Zuul` will automatically create a default routing rule for each service: the access path is prefixed with the service name configured by `serviceId`, which is why we were able to use:\n```\nhttp://localhost:8280/user-service/users\n```\n\nto access the `users` endpoint provided in `User-Service`.\n\n### 2. Customized microservice access path\nThe configuration format is: `zuul.routes.Microservice Id = specified path`, such as:\n```\nzuul.routes.user-service = /user/**\n```\n\nIn this way, we can access the services provided by `user-service` through `/user/`. For example, the previous access can be changed to: http://localhost:8280/user/users/admin.\n\nThe path to be configured can specify a regular expression to match the path. Therefore, `/user/*` can only match the first-level path, but `/user/**` can match all paths starting with `/user/`.\n\n### 3. Ignore specified microservices\nFormat: `zuul.ignored-services = Micro service Id1, Micro service Id2 ...`, multiple micro services are separated by commas. Such as:\n```\nzuul.ignored-services=user-service,product-service\n```\n\n### 4. Specify the microservice Id and the corresponding path at the same time\n```\nzuul.routes.api-a.path=/api-a/**\nzuul.routes.api-a.serviceId=service-A\n\nzuul.routes.api-b.path=/api-b/**\nzuul.routes.api-b.serviceId=service-B\n```\n\n### 5. Specify microservice URL and corresponding path at the same time\n```\nzuul.routes.api-a.path=/api-a/**\nzuul.routes.api-a.url=http://localhost:8080/api-a\n```\n\nAs mentioned before, the routing configured through the URL will not be executed by `HystrixCommand`. As a result, `Ribbon`'s `load balancing`, `downgrading`, and `circuit breaker` functions will not be obtained. Therefore, try to use `serviceId` for configuration, you can also use the following configuration.\n\n### 6. Specify multiple service instances and load balancing\nIf multiple service instances need to be configured, the configuration is as follows:\n```\nzuul.routes.user.path: /user/**\nzuul.routes.user.serviceId: user\n\nribbon.eureka.enabled=false\nuser.ribbon.listOfServers: http://192.168.1.10:8081, http://192.168.1.11:8081\n```\n\n### 7. Forward to local url\n```\nzuul.routes.user.path=/user/**\nzuul.routes.user.url=forward:/user\n```\n\n### 8. Route prefix\nYou can add a uniform prefix to all mappings through `zuul.prefix`. For example: /api. By default, the proxy will automatically strip this prefix before forwarding. If you need to prefix with forwarding, you can configure: `zuul.stripPrefix = false` to turn off this default behavior. E.g:\n```\nzuul.routes.users.path=/myusers/**\nzuul.routes.users.stripPrefix=false\n```\n\n> Note: `zuul.stripPrefix` only works on the prefix of `zuul.prefix`. Does not work for prefix specified by path.\n\n### 9. Routing configuration order\nIf you want to control the routing rules according to the configured order, you need to use `YAML`. If you use the property file, the order will be lost. E.g:\n```\nzuul:\n  routes:\n    users:\n      path: /myusers/**\n    legacy:\n      path: /**\n```\n\nIf the above example is configured using a properties file, the `legacy` may be effective, so the users have no effect.\n\n### 10. Custom transformation\nWe can also have a converter that uses a regular expression between the `serviceId` and the `route` to automatically match. E.g:\n``` Java\n@Bean\npublic PatternServiceRouteMapper serviceRouteMapper() {\n    return new PatternServiceRouteMapper(\n        \"(?<name>^.+)-(?<version>v.+$)\",\n        \"${version}/${name}\");\n}\n```\n\nIn this way, the service whose serviceId is `users-v1` will be mapped to the route of `/v1/users/`. Any regular expression is fine, but all named groups must include `servicePattern` and `routePattern`. If `servicePattern` does not match a `serviceId`, then the default is used. In the above example, a service with serviceId `users` will be mapped to the route `/users/ `(without version information). This feature is off by default and only applies to services that have been discovered.\n\n## Zuul Header Settings\n### Sensitive header settings\nIt is not a problem to share information through headers between services in the same system, but if you don't want some sensitive information in headers to leak out with HTTP forwarding, you need to specify a list of headers to be ignored in the routing configuration.\n\nBy default, when `Zuul` requests routing, it will filter some sensitive information in the HTTP request header information. The default sensitive header information is defined through `zuul.sensitiveHeaders`, including `Cookie`, `Set-Cookie`, and `Authorization`. The configured sensitiveHeaders can be separated by commas.\n\nThe specified routes can be configured with:\n```\nzuul.routes.[route].customSensitiveHeaders=true \nzuul.routes.[route].sensitiveHeaders=[set headers here]\n```\n\nSet global:\n```\nzuul.sensitiveHeaders=[set headers here]\n```\n\n### Ignore Header settings\nIf you need to configure some additional sensitive headers for each route, you can use `zuul.ignoredHeaders` to uniformly set the headers to be ignored. Such as:\n```\nzuul.ignoredHeaders=[set Header to ignore]\n```\n\nThere is no such configuration by default. If `Spring Security` is introduced in the project, then `Spring Security` will automatically add this configuration. The default values are: `Pragma`, `Cache-Control`, `X-Frame-Options`, `X-Content-Type- Options`, `X-XSS-Protection`, `Expries`.\n\nIf you also need to use the `Spring Security Header` of the downstream microservice, you can add the following settings:\n```\nzuul.ignoreSecurityHeaders=false\n```\n\n## Zuul Http Client\n`Zuul`'s Http client supports `Apache Http`, Ribbon's `RestClient`, and `OkHttpClient`. By default, the `Apache HTTP` client is used. The corresponding clients can be enabled in the following ways:\n```\n# Enable Ribbon'RestClient\nribbon.restclient.enabled=true\n\n# Enable OkHttpClient\nribbon.okhttp.enabled=true\n```\n\n> If you need to use `OkHttpClient`, please note that `com.squareup.okhttp3` related packages are already included in your project.\n\n# *Zuul fault tolerance and fallback*\nLet's take a look at the previous monitoring interface of Hystrix:\n\n{% asset_img 5.png %}\n<br/>\n<br/>\n\nPlease note that the granularity of `Zuul`'s `Hystrix monitoring` is microservices, not an API, that is, all requests passing `Zuul` will be protected by `Hystrix`. If we shut down the `User-Service` service now, what will happen when we visit it again?\n\n{% asset_img 6.png %}\n<br/>\n<br/>\n\nSo how do we implement fault tolerance and fallback for `Zuul`? `Zuul` provides a `ZuulFallbackProvider` interface. By implementing this interface, we can implement fallback functions for `Zuul`. So let's transform `Zuul-Server` before.\n``` Java\n\n```\n\nNote that:\n* The `getRoute` method returns that we want to provide a fallback for that microservice. Note that the returned value is the name of the route, not the name of the service, and cannot be written as: `USER-SERVICE`, otherwise the fallback will not work;\n* The `fallbackResponse` method returns a `ClientHttpResponse` object as our fallback response.\n\nNow do a test, stop `User-Service` and visit:http://localhost:8280/user-service/users/admin\n{% asset_img 7.png %}\n<br/>\n<br/>\n\nNote that the fallback method has worked. If it doesn't work, double check that `getRoute` returns correctly.\n\nCheck out the source code here: [zuul part 1 demo](https://github.com/nicklee1006/SpringCloudDemo/tree/master/zuul)","categories":["Spring Cloud"]},{"title":"Dynamic Programming","url":"/Dynamic-Programming/","content":"## Basic Concept\nThe process of dynamic programming is: each decision depends on the current state, and then causes a state transition. A decision sequence is generated in a changing state. Therefore, this multi-stage optimization decision-making process is called dynamic programming.\n\n> Initial state → │Decision 1│ → │Decision 2│ →… → │Decision n│ → End state\n\n## Scope of application\nThe problems that can be solved by dynamic programming generally have three properties:\n\n1. **<font color=\"orange\">Optimization principle</font>**: If the solution of the sub-problem contained in the optimal solution of the problem is also optimal, the problem is said to have an optimal sub-structure, that is, to satisfy the optimization principle.\n\n2. **<font color=\"orange\">No aftereffect</font>**: once the state of a certain stage is determined, it will not be affected by the future decisions. In other words, the process after a certain state will not affect the previous state, only the current state.\n\n3. There are **<font color=\"orange\">overlapping sub-problems</font>**: that is, the sub-problems are not independent, and a sub-problem may be used multiple times in the next stage of decision-making. **<font color=\"orange\">(This property is not a necessary condition for dynamic programming, but without this property, dynamic programming algorithms have no advantage over other algorithms)</font>**\n\n## Basic ideas and strategies\nThe basic idea is similar to the divide-and-conquer method, which decomposes the problem into several sub-problems (stages), and solves the sub-problems in order. The solution of the former sub-problem provides useful information for the solution of the latter sub-problem. When solving any sub-problem, list all possible local solutions, retain those that are likely to reach the optimal local solution through decision-making, and discard other local solutions. Solve each sub-problem in turn. The last sub-problem is the solution of the initial problem.\n\nSince most of the problems solved by dynamic programming have overlapping sub-problems, in order to reduce repeated calculations, each sub-problem is solved only once, and different states at different stages are stored in a two-dimensional array.\n\nThe biggest difference from the divide-and-conquer method is that for problems that are suitable for dynamic programming, **<font color=\"orange\">the sub-problems obtained after decomposition are often not independent of each other (that is, the solution of the next sub-stage is based on the solution of the previous sub-stage)</font>**.\n\n## Steps to solve problems using dynamic programming\nThe problems dealt with by dynamic programming is **<font color=\"orange\">a multi-stage decision-making problem</font>**, which generally starts from the initial state and reaches the end state through the selection of intermediate-stage decisions. These decisions form a sequence of decisions, and determine an activity route (usually the optimal activity route) to complete the entire process. \n\n> Initial state → │Decision 1│ → │Decision 2│ →… → │Decision n│ → End state\n\nThere are certain patterns in the design of dynamic programming solution. Generally, the following steps are required.\n\n1. **<font color=\"orange\">Division</font>**: According to the time or space characteristics of the problem, the problem is divided into several stages. In the division stage, pay attention that **<font color=\"orange\">the order of the stages must be ordered or sortable</font>**, otherwise the problem cannot be solved.\n\n2. **<font color=\"orange\">Determining the state and state variables</font>**: The various situations in which the problem develops into various stages are represented by different states. Of course, the choice of state must satisfy no aftereffect.\n\n3. **<font color=\"orange\">Determine the decision and write the state transition equation</font>**: Because decision and state transition have a connection, **<font color=\"orange\">state transition is to derive the state of this stage according to the state of previous stage and the decision</font>**. So if a decision is made, the state transition equation can be written. But in reality, it is often done the other way around, and the decision-making method and state transition equation are **<font color=\"orange\">determined according to the relationship between the states of two adjacent stages</font>**.\n\n4. **<font color=\"orange\">Finding the boundary conditions</font>**: The given state transition equation is a recursive formula, which requires a recursive termination condition or boundary condition.\n\nIn general, as long as the problem's **<font color=\"orange\">stage</font>**, **<font color=\"orange\">state</font>**, and **<font color=\"orange\">state transition decision</font>** are determined, the state transition equation (including boundary conditions) can be written.\n\nIn practical applications, you can design according to the following simplified steps:\n1. Analyze the nature of the optimal solution and characterize its structure.\n2. Recursive definition of optimal solution.\n3. Calculate the optimal value by bottom-up or top-down memorization method (memorandum method)\n4. Construct the optimal solution of the problem based on the information obtained when calculating the optimal value\n\n## Algorithm design\nThe main difficulty of dynamic programming is the theoretical design, which is the determination of the above 4 steps. Once the design is completed, the implementation part will be very simple.\n\nUsing dynamic programming to solve problems, the most important thing is to determine the **<font color=\"orange\">three elements of dynamic programming</font>**:\n1. Problem stage\n2. State of each stage\n3. Recursive relationship from the previous stage to the later stage.\n\nThe recursive relationship must be a conversion from the smaller problem to the larger one. From this perspective, dynamic programming can often be implemented using recursion, but because dynamic programming can make use of the previously saved sub-problems solution to reduce repeated calculations. So for large-scale problems, dynamic programming have advantages compared with recursion, which is the core of dynamic programming algorithms.\n\nAfter determining these three elements of dynamic programming, **<font color=\"orange\">the entire solution process can be described by an optimal decision table. The optimal decision table is a two-dimensional table, where the rows represent the stages of decision-making, and the columns represent the problem state</font>**. Generally speaking, **<font color=\"orange\">the cell value corresponds to the optimal value (such as the shortest path, longest common subsequence, maximum value, etc.) at a certain stage and state</font>**. The process of filling the form is based on the recursive relationship, starting from Row 1 and Column 1, in the order of row or column first, and finally obtain the optimal solution of the problem by simple rounding or calculation based on the data of the entire form.\n\n```\nf(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}\n```\n\n## Algorithm basic framework\n``` Java\n// Initial stage\nfor(j = 1; j <= m; j++) {\n   xn[j] = initial value;\n}\n\n// Other n-1 stage\nfor(i = n-1; i >= 1; i--) {\n    // f(i) is expression related to i\n    for(j = 1; j >= f(i); j--) {\n        xi[j]=j=max（or min）{g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])};\n    }\n}\n\n// Get optimal solution to the problem from the optimal to the sub-problems\nt = g(x1[j1:j2]); \n\nprint(x1[j1]);\n\nfor(i = 2; i <= n-1; i++）{  \n     t = t-xi-1[ji];\n\n     for(j=1; j>=f(i); j=j+1) {\n        if(t=xi[ji]) {\n            break;\n        }\n     }\n}\n```","tags":["Leetcode - Dynamic Programming"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 96. Unique Binary Search Trees","url":"/Leetcode-96-Unique-Binary-Search-Trees/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nSimilar to {% post_link Leetcode-95-Unique-Binary-Search-Trees-II '95. Unique Binary Search Trees II' %}. This time just need to count the number of unique binary search tree.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-95-Unique-Binary-Search-Trees-II '95. Unique Binary Search Trees II' %}\n\n## Solution\nThe following is the analysis for {% post_link Leetcode-95-Unique-Binary-Search-Trees-II '95. Unique Binary Search Trees II' %}:\n>Example: `1....n`\nTake `1` as the root node, `[]` as the left subtree, and all of `[2 ... n]` as the right subtree.\nTake `2` as the root node, `[1]` as the left subtree, `[3 ... n]` as the right subtree.\nTake `3` as the root node, `[1 2]` as the left subtree, `[4 ... n]` as the right subtree. Then pair the left and right subtrees.\nTake `4` as the root node, `[1 2 3]` as the left subtree, `[5 ... n]` as the right subtree. Then pair the left and right subtrees.\n...\nTake `n` as the root node, `[1 ... n]` as the left subtree, `[]` as the right subtree.\nIf there is only one number, then there is only 1 case, using that number as a tree. If it is [], it returns null.\n\nFor this problem, it will be simpler, we only need to return the number of trees. To find the number of subtrees of current roots, just multiply the number of left subtrees by the right subtree.\n\nAs there are many repeated calculations, we can save the results obtained during the recursion, and it can be taken directly when needed for the second time.\n\n``` Java\n// dynamic programming values, map n -> number of valid trees\nMap<Integer, Integer> map = new HashMap<>();\n\npublic int numTrees(int n) {\n    // initialize values\n    map.put(0, 1);\n    map.put(1, 1);\n    map.put(2, 2);\n\n    return getAnswer(n);\n}\n\nprivate int getAnswer(int n) {\n    if (n == 0 || n == 1) {\n        return 1;\n    }\n\n    if (n == 2) {\n        return 2;\n    }\n\n    int result = 0;\n\n    for (int i = 1; i <= n; i++) {\n        // root element is i, \n        // number of left node = i - i\n        // number of right node = n - i\n        int left;\n        if (map.containsKey(i - 1)) {\n            left = map.get(i - 1);\n        } else {\n            left = getAnswer(i - 1);\n            map.put(i - 1, left);\n        }\n\n        int right;\n        if (map.containsKey(n - i)) {\n            right = map.get(n - i);\n        } else {\n            right = getAnswer(n - i);\n            map.put(n - i, right);\n        }\n\n        result += left * right;\n    }\n\n    map.put(n, result);\n    return result;\n}\n```","tags":["Leetcode - Dynamic Programming","Leetcode - Tree"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 95. Unique Binary Search Trees II","url":"/Leetcode-95-Unique-Binary-Search-Trees-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven n, use these numbers 1 ... n to generate all possible binary search trees.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-96-Unique-Binary-Search-Trees '96. Unique Binary Search Trees' %}\n* Medium - [241. Different Ways to Add Parentheses](https://leetcode.com/problems/different-ways-to-add-parentheses/)\n\n## Solution\nOne of the most important property of binary tree: all values of the left subtree are smaller than the root node, and all values of the right subtree are larger than the root node. We could use it to solve this problem\n\nExample: `1....n`\n\nTake `1` as the root node, `[]` as the left subtree, and all of `[2 ... n]` as the right subtree.\n\nTake `2` as the root node, `[1]` as the left subtree, `[3 ... n]` as the right subtree.\n\nTake `3` as the root node, `[1 2]` as the left subtree, `[4 ... n]` as the right subtree. Then pair the left and right subtrees.\n\nTake `4` as the root node, `[1 2 3]` as the left subtree, `[5 ... n]` as the right subtree. Then pair the left and right subtrees.\n\n...\n\nTake `n` as the root node, `[1 ... n]` as the left subtree, `[]` as the right subtree.\n\nIf there is only one number, then there is only 1 case, using that number as a tree. If it is [], it returns null.\n\n``` Java\npublic List<TreeNode> generateTrees(int n) {\n    if (n == 0) {\n        return Collections.emptyList();\n    }\n\n    return getResults(1, n);\n}\n\n// recursive\nprivate static List<TreeNode> getResults(int start, int end) {\n    List<TreeNode> results = new ArrayList<>();\n\n    if (start > end) {\n        results.add(null);\n\n        return results;\n    }\n\n    // only 1 node\n    if (start == end) {\n        TreeNode node = new TreeNode(start);\n        results.add(node);\n\n        return results;\n    }\n\n    for (int i = start; i <= end; i++) {\n        // i is the root node\n        List<TreeNode> leftNodes = getResults(start, i - 1);\n        List<TreeNode> rightNodes = getResults(i + 1, end);\n\n        // combine all possible left and right tree\n        for (TreeNode leftNode : leftNodes) {\n            for (TreeNode rightNode : rightNodes) {\n                TreeNode root = new TreeNode(i);\n\n                root.left = leftNode;\n                root.right = rightNode;\n\n                results.add(root);\n            }\n        }\n    }\n\n    return results;\n}\n```","tags":["Leetcode - Dynamic Programming","Leetcode - Tree"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 91. Decode Ways","url":"/Leetcode-91-Decode-Ways/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nEach number corresponds to a letter. Given a string of numbers, need to know how many decoding methods. For example, 226 can have three decode ways, 2|2|6, 22|6, 2|26.\n\n### Similar Questions\n* Hard - [639. Decode Ways II](https://leetcode.com/problems/decode-ways-ii/)\n\n## Solution 1 - Recursion\nIt is easy to think of using recursion, turning big problems into smaller problems.\n\nFor example, `232232323232`.\n\nFor the first letter we have two divisions.\n\n`2|32232323232` and `23|2232323232`\n\nTherefore, if we know that the decoding result of the right part `32232323232` is `ans1` and that of `2232323232` is `ans2`, then the overall `232232323232` decoding result is `ans1` + `ans2`.\n\nIf it is too hard to understand, think about this analogy. \n\nIf there are two roads from Melbourne to Brisbane, via Sydney and Canberra. There are 8 roads from Sydney to Brisbane, and 6 roads from Canberra to Brisbane. So there are 8 + 6 = 14 routes from Melbourne to Brisbane.\n\n``` Java\npublic int numDecodings(String s) {\n    return getResult(s, 0);\n}\n\n// start is the index of the char in 's'\nprivate int getResult(String s, int start) {\n    // reaching the end\n    if (start == s.length()) {\n        return 1;\n    }\n\n    if (s.charAt(start) == '0') {\n        return 0;\n    }\n\n    // answer if divide the first index\n    // e.g. if input （123）\n    // answer1 is 1 + answer(2,3)\n    // answer2 is 12 + answer(3)\n    int answer1 = getResult(s, start + 1);\n    int answer2 = 0;\n\n    // only have answer2 if first 2 digit <= 26\n    if (start < s.length() - 1) {\n        int ten = (s.charAt(start) - '0') * 10;\n        int one = s.charAt(start + 1) - '0';\n\n        if (ten + one <= 26) {\n            answer2 = getResult(s, start + 2);\n        }\n    }\n\n    return answer1 + answer2;\n}\n```\n\n## Solution 2 - Recursion + Dynamic Programming\nIn solution 1, after calculating `ans1` and then calculate `ans2`, some already calculated results will be recalculated, so we can use the memoization technique to calculate a result and save it.\n\n``` Java\npublic int numDecodings(String s) {\n    // map startIndex -> result\n    HashMap<Integer, Integer> cache = new HashMap<>();\n    return getResult(s, 0, cache);\n}\n\n// start is the index of the char in 's'\nprivate int getResult(String s, int start, HashMap<Integer, Integer> cache) {\n    // reaching the end\n    if (start == s.length()) {\n        return 1;\n    }\n\n    if (s.charAt(start) == '0') {\n        return 0;\n    }\n\n    // check if calculated before\n    int tempResult = cache.getOrDefault(start, -1);\n    if (tempResult != -1) {\n        return tempResult;\n    }\n\n    // answer if divide the first index\n    // e.g. if input （123）\n    // answer1 is 1 + answer(2,3)\n    // answer2 is 12 + answer(3)\n    int answer1 = getResult(s, start + 1, cache);\n    int answer2 = 0;\n\n    // only have answer2 if first 2 digit <= 26\n    if (start < s.length() - 1) {\n        int ten = (s.charAt(start) - '0') * 10;\n        int one = s.charAt(start + 1) - '0';\n\n        if (ten + one <= 26) {\n            answer2 = getResult(s, start + 2, cache);\n        }\n    }\n\n    // cache the result\n    cache.put(start, ans1 + ans2);\n\n    return answer1 + answer2;\n}\n```","tags":["Leetcode - Dynamic Programming","Leetcode - String"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 5. Longest Palindromic Substring","url":"/Leetcode-5-Longest-Palindromic-Substring/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nDind the longest palindromic substring in a given string s\n\n### Similar Questions\n* Hard - [214. Shortest Palindrome](https://leetcode.com/problems/shortest-palindrome/)\n* Hard - [336. Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/)\n* Medium - [516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)\n* Medium - [647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)\n\n## Solution 1 - Brute Force\nEnumerate all substrings, determine whether it is a palindrome string, and save the longest palindrome string.\n\nTime complexity: need 2 for loop to enumerate all substring O(n<sup>2</sup>), and 1 for loop to determine if a string is palindrome. Thus overall time complexity O(n<sup>3</sup>).\n\n## Solution 2 - Expand from central\nWe know that the palindrome string must be symmetrical, so we can select a center each time, expand left and right, and determine whether the left and right characters are equal.\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nBecause there are strings with odd length and even length, we need to expand from one central or from two central, so there are n + n-1 central in total.\n\n``` Java\npublic String longestPalindrome(String s) {\n    if (s.length() == 1) {\n        return s;\n    }\n\n    String result = \"\";\n\n    for (int i = 0; i < s.length() - 1; i++) {\n        // central is 1 char\n        int length = expand(s, i, i);\n        // central is 2 chars\n        int length2 = expand(s, i, i + 1);\n\n        int longer = Math.max(length, length2);\n\n        if (longer > result.length()) {\n            result = s.substring(i - (longer - 1) / 2, i + longer / 2 + 1);\n        }\n    }\n\n    return result;\n}\n\n// given string s, expand from given central\nprivate int expand(String s, int start, int end) {\n    int left = start;\n    int right = end;\n\n    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n        left--;\n        right++;\n    }\n\n    return right - left - 1;\n}\n```\n\nTime complexity: O(n<sup>2</sup>)\n\n## Solution 3 - Manacher’s Algorithm\n> Manacher's Algorithm is a linear algorithm used to find the longest palindrome substring of a string. It was invented by a man named Manacher in 1975. The biggest contribution of this algorithm is to decrease the time complexity to Linear.\n\nSee: [Manacher’s Algorithm](https://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-1/). I will have a separate blog takling about this algothm in the future.","tags":["Leetcode - Dynamic Programming","Leetcode - String"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 6: Fault Tolerant - Hystrix","url":"/Spring-Cloud-6-Fault-Tolerant-Hystrix/","content":"When implementing the microservice architecture, we usually split the services into individual microservices, and the microservices communicate through the network and call each other, resulting in a dependency relationship between them. We know that due to network issues, the service does not guarantee 100% availability. If there is a problem with a single service, there will be network delay or even call failure when calling this service, and the call failure will cause the user to refresh the page and try again. This, coupled with other service calls, increase the load on the server, causing the service to be unavailable, and eventually lead to a crash of the entire service.\n\nTo solve this problem `Netflix` created `Hystrix` library based on the circuit breaker pattern. \"Circuit breaker\" itself is a switching device. When a service fails, the fault monitoring of the circuit breaker (similar to a blown fuse) returns the service caller with an expected, manageable alternative response (`FallBack`), rather than waiting for a long time or throwing an exception that the caller cannot handle. This guarantees that the thread of service caller will not be occupied for a long time and needlessly, thereby preventing the fault from spreading in the whole distributed system.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nOf course, when the frequency of request failures is low, `Hystrix` will still return the failure directly to the client. Only when the number of failures reaches the threshold (defaults to 5 failures within 20 seconds), the circuit breaker opens and does not perform subsequent communication, but directly returns a fallback response.\n\n## Example Project\n`Feign` integrates the `Ribbon` and `Hystrix` by default, so we modify the code based on the previous article {% post_link Spring-Cloud-6-Fault-Tolerant-Hystrix 'Spring-Cloud-6-Fault-Tolerant-Hystrix' %}.\n\nIt is the service consumer that implements the microservice fault tolerance protection, which is the `service-product-consumer` project. Our code are mainly changing the `service-product-consumer` project, the code of other projects will remain unchanged.\n\n### 1. Hystrix Dependency\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n```\n\n### 2. Main Application\n``` Java\n@EnableFeignClients\n@EnableDiscoveryClient\n@SpringBootApplication\n@EnableCircuitBreaker\npublic class ConsumerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsumerApplication.class, args);\n    }\n}\n```\n\nAdd `@EnableCircuitBreaker` annotation to enable circuit breaker support.\n\n### 3. Implement ProductService Fallback\nAdd a concrete class to implement `ProductService` interface.\n\n``` Java\n@Component\npublic class ProductServiceFallback implements ProductService {\n    @Override\n    public List<Product> findAll() {\n        return Collections.emptyList();\n    }\n\n    @Override\n    public Product loadByItemCode(String itemCode) {\n        return new Product(\"error\", \"Unknown\", \"Unknown\", 0);\n    }\n}\n```\n\n### 4. Enable ProductService to have fault tolerance\n``` Java\n@FeignClient(value = \"PRODUCT-SERVICE\", fallback = ProductServiceFallback.class)\npublic interface ProductService {\n    @RequestMapping(value = \"/products\", method = RequestMethod.GET)\n    List<Product> findAll();\n\n    @RequestMapping(value = \"/products/{itemCode}\", method = RequestMethod.GET)\n    Product loadByItemCode(@PathVariable(\"itemCode\") String itemCode);\n}\n```\n\nJust need to add fallback configuration to `@FeignClient` annotation, and set it to the fallback class `ProductServiceFallback`.\n\n### Enable Hystrix on Feign \nAdd the following configuration to application.properties.\n\n``` Java\nfeign.hystrix.enabled=true\n```\n\n### 5. Fault Tolerance Testing\n1. First, we start `Eureka Server`, two `PRODUCT-SERVICE` and `PRODUCT-SERVICE-CONSUMER`. After starting, we can see the registered services in the monitoring interface of `Eureka Server`:\n{% asset_img 2.png %}\n<br/>\n<br/>\n\n2. Visit: http://localhost:9090/products/item-3.\n{% asset_img 3.png %}\n<br/>\n<br/>\nMeans our service call is success.\n\n3. Now We stopped the `PRODUCT-SERVICE` service with port 2100. At this time, we can see that the registered services are as follows in the monitoring interface of `Eureka Server`, indicating that one of the `PRODUCT-SERVICE` has been down, and at this time, we can still get the correct response by visiting: http://localhost:9090/products/item-3:\n{% asset_img 4.png %}\n<br/>\n<br/>\n\n4. We continue to stop the `PRODUCT-SERVICE` service with port 2200. At this time, we can see that the registered services are as follows. Note that all `PRODUCT-SERVICE` services have been down. At this time, if we visit: http://localhost:9090/products/item-3, we will see the fallback response:\n{% asset_img 5.png %}\n<br/>\n<br/>\n{% asset_img 6.png %}\n\nIt can be seen that FallBack has been activated. When all `PRODUCT-SERVICE` does not work, the `ProductService` in `PRODUCT-SERVICE-CONSUMER` has entered a fallback process.\n\n## Hystrix Fault Tolerance Principle\n**Request encapsulation:** Whether it is `HystrixCommand` or `HystrixObervableCommand`, you can see from the class name that `Hystrix` actually uses \"command mode\". The command mode is used to encapsulate service call, and each command is executed in a separate thread;\n\n**Trip mechanism:** When the error rate of a service exceeds a certain threshold (default 5 failures within 20 seconds), `Hystrix` can automatically or manually perform a service trip and stop requesting the service for a period of time;\n\n**Resource isolation:** `Hystrix` maintains a small thread pool for each service dependency. If the thread pool is full, requests to the service will be rejected immediately instead of waiting in a queue, thereby speeding up the determination of service failure;\n\n**Service monitoring:** `Hystrix` can monitor operational indicators and configuration changes in near real time, such as the success, failure, timeout, and rejection of requests;\n\n**Fallback mechanism:** When the request fails, times out, rejected, or when the circuit breaker is opened, the corresponding fallback logic is executed;\n\n**Self-healing:** When the circuit breaker is opened for a period of time, `Hystrix` will enter a \"half open\" state. The circuit breaker will allow a request to try to make a request to the service. If the service can be successfully called, close the circuit breaker, otherwise the circuit breaker will continue turn on.\n\n## Hystrix Monitoring\nIn addition to implementing service fault tolerance, `Hystrix` also provides monitoring of service requests: the number of requests executed per second, the number of successes, and so on. Enabling monitoring of `Hystrix` is very simple. One is to add `spring-cloud-starter-netflix-hystrix`. The other is to add `spring-boot-starter-actuator`, which enables the `/ hystrix-stream` endpoint to obtain monitoring data from `Hystrix`.\n\n### Use Spring Boot Actuator\n#### 1. Add dependency\n``` Xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n#### 2. application.properties\n``` Java\nmanagement.endpoints.web.exposure.include=hystrix.stream\n```\n\n#### 3. Testing Monitor\nAfter starting `PRODUCT-SERVICE-CONSUMER`, and call the service: http://localhost:9090/products/item-3. Then visit: http://localhost:9090/actuator/hystrix.stream:\n{% asset_img 7.png %}\n<br/>\n<br/>\n\nWe can see that the page will repeatedly output some statistics. It is very hard to read the data. Fortunately, `Hystrix`  provides us with a visual interface to view these data.\n\n### Hystrix Dashboard\nWe can integrate `Hystrix Dashboard` with `PRODUCT-SERVICE-CONSUMER`\n\n#### 1. Dependency\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\n</dependency>\n```\n        \n#### 2. Main application\n``` Java\n@EnableFeignClients\n@EnableDiscoveryClient\n@SpringBootApplication\n@EnableCircuitBreaker\n@EnableHystrixDashboard\npublic class ConsumerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsumerApplication.class, args);\n    }\n}\n```\n\nAdd `@EnableHystrixDashboard` annotation to enable `Hystrix Dashboard`.\n\n#### 3. Start service\nStart `PRODUCT-SERVICE-CONSUMER`. Visit: http://localhost:9090/hystrix:\n{% asset_img 8.png %}\n<br/>\n<br/>\n\nThe Dashboard has been started successfully. Then enter the previous address in the interface: http://localhost:9090/actuator/hystrix.stream, and then click `[Monitor Stream]` to see the statistics report page:\n{% asset_img 9.png %}\n<br/>\n<br/>\n\nWe can see statistics for two service interfaces: `findAll` and `loadByItemCode`.\n\nThe statistical information of each method contains two important graphical information: a solid circle and a curve.\n\n**Solid circles:** Two indications. The color indicates the health of the instance, which decreases from green, yellow, orange, and red. The size changes according to the size of the requested traffic. The larger the traffic, the larger the solid circle, and vice versa.\n**Curve:** Statistics about the change of request traffic within 2 minutes, and the curve can be used to analyze the rising and falling trends of the traffic.\n\nThe meaning of the numbers in the interface is as follows (image from https://github.com/Netflix-Skunkworks/hystrix-dashboard/wiki):\n{% asset_img 10.png %}\n<br/>\n<br/>\n\nOn the Dashboard homepage, we know that `Hystrix Dashboard` supports three monitoring methods:\n**Default cluster monitoring:** via http://turbine-hostname:port/turbine.stream, monitor the default cluster;\n**Specified cluster monitoring:** via http://turbine-hostname:port/turbine.stream?Cluster=[clusterName] to monitor the specified `clusterName` cluster;\n**Single-machine application monitoring:** http://hystrix-app:port/hystrix.stream to achieve monitoring of a service instance.\n\nThe above example demonstrated the third way.\n\nCheck out the source code here: [hystrix demo](https://github.com/nicklee1006/SpringCloudDemo/tree/master/hystrix)","categories":["Spring Cloud"]},{"title":"Leetcode 90. Subsets II","url":"/Leetcode-90-Subsets-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nReturn all subsets of a set of integers (may contain duplicates).\n\n### Similar Questions\n* Medium - {% post_link Leetcode-78-Subsets '78. Subsets' %}\n\n## Solution\nWe can revise the solution of {% post_link Leetcode-78-Subsets '78. Subsets' %}. Let's take a look at what would happen if we followed the idea of {% post_link Leetcode-78-Subsets '78. Subsets' %} directly. The previous idea was to add in first element, then add in second element to the subset formed previous. With n-th element, that is add n-th element to all previously formed subset\n\nFor example, the iteration process of nums[1, 2, 3].\n```\ninitialize empty list:      []\n1st iteration (nums[k] = 1):[[], [1]]\n2nd iteration (nums[k] = 2):[[], [1], [2], [1, 2]]\n3rd iteration (nums[k] = 3):[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n```\n\nBut what happens if there are duplicate numbers?\n\nE.g, nums[1, 2, 2]\n```\n1st iteration (nums[k] = 1):[[], [1]]\n2nd iteration (nums[k] = 2):[[], [1], [2], [1, 2]]\n3rd iteration (nums[k] = 2):[[], [1], [2], [1, 2], [2], [1, 2], [2, 2], [1, 2, 2]]\n```\n\nWe noticed that there are duplicate arrays.\n\nHow to avoid it? We can make a Hashset to store the results, everytime we have a new result, first sort the result, and try to add it to the set. This way we can avoid adding duplicates to the result set. Finally just need to convert the set to a list.\n\n``` Java\n// use set to avoid duplicate results\nSet<List<Integer>> results = new HashSet<>();\n\n// add empty list\nresults.add(new ArrayList<>());\n\nfor (int num : nums) {\n    List<List<Integer>> temp = new ArrayList<>();\n\n    for (List<Integer> existing : results) {\n        List<Integer> newListAppend = new ArrayList<>(existing);\n        newListAppend.add(num);\n\n        // sort the result\n        Collections.sort(newListAppend);\n\n        temp.add(newListAppend);\n    }\n\n    // if duplicate result, then wouldn't add to set\n    results.addAll(temp);\n}\n\nreturn new ArrayList<>(results);\n```","tags":["Leetcode - Backtracking","Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 81. Search in Rotated Sorted Array II","url":"/Leetcode-81-Search-in-Rotated-Sorted-Array-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nFollow up question on {% post_link Leetcode-33-Search-in-Rotated-Sorted-Array '33. Search in Rotated Sorted Array' %}. This time the array may contain duplicates\n\n### Similar Questions\n* Medium - {% post_link Leetcode-33-Search-in-Rotated-Sorted-Array '33. Search in Rotated Sorted Array' %}\n\n## Solution\nFor this question we can extend the solution from {% post_link Leetcode-33-Search-in-Rotated-Sorted-Array '33. Search in Rotated Sorted Array' %}. The algorithm is based on the fact that after splitting an array from any position, it is at least half sorted.\n\nFor example, [4 5 6 7 1 2 3], and split from 7, the left is [4 5 6 7], the right is [7 1 2 3]. So the left part is ordered.\n\nWe can find out which part is in order (by comparing the endpoints). Knowing which part is in order, all we need is the normal binary search and check if the target is in this part. If it is, Then discard the other half. If not, discard this half.\n\nThat is the approach we used for {% post_link Leetcode-33-Search-in-Rotated-Sorted-Array '33. Search in Rotated Sorted Array' %}. With this question, we need a slight modification. As for this question, we have duplicates in the array. So when we decide which part is in order, there is a problem. \n\nFor example, `nums = [ 1, 3, 1, 1, 1 ]` and `targer = 3`. The left half is `[1, 3, 1]`. By comparing endpoints `nums [start] <= nums [mid]`, the algorithm thinks that left half is in order, which is not the case.\n\nSo we need to take `nums[start] == nums[mid]` as a special case. The solution is quite simple, just `start++` will do.\n\n``` Java\nint start = 0;\nint end = nums.length - 1;\n\nwhile (start <= end) {\n    int mid = (start + end) / 2;\n\n    // find target\n    if (target == nums[mid]) {\n        return true;\n    }\n\n    // left side is ordered\n    if (nums[start] < nums[mid]) {\n        // target in left side\n        if (target >= nums[start] && target <= nums[mid]) {\n            end = mid - 1;\n        } else {\n            start = mid + 1;\n        }\n    // special case like [1, 3, 1]\n    } else if (nums[start] == nums[mid]) {\n        start++;\n    // right side is ordered    \n    } else {\n        // target in right side\n        if (target >= nums[mid] && target <= nums[end]) {\n            start = mid + 1;\n        } else {\n            end = mid - 1;\n        }\n    }\n}\n\nreturn false;\n```","tags":["Leetcode - Array","Leetcode - Binary Search"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 80. Remove Duplicates from Sorted Array II","url":"/Leetcode-80-Remove-Duplicates-from-Sorted-Array-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nRemove duplicates from a sorted array in-place, such that duplicates appears at most twice.\n\n### Similar Questions\n* Easy - [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\n\n## Solution\nMake use of 2 pointers. `Slow pointer` point to the element that satisfy the condition (appears at most twice). `Fast pointer` always move forward and loop through the array. We can use a variable to record how many times the element of `slow pointer` have occurred.\n\n``` Java\nint slow = 0;\nint fast;\n// count to mark number of same number\nint count = 1;\n\n// fast pointer always increase\nfor (fast = 1; fast < nums.length; fast++) {\n    if (nums[slow] == nums[fast]) {\n        // 2 pointers point to same number, but count = 1\n        // we can increase slow pointer\n        if (count < 2) {\n            slow++;\n            nums[slow] = nums[fast];\n            count++;\n        }\n    // 2 pointers point to different number\n    // reset count = 1\n    } else {\n        slow++;\n        nums[slow] = nums[fast];\n        count = 1;\n    }\n}\n\nreturn slow + 1;\n```","tags":["Leetcode - Array","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 5: Declarative REST Client - Feign","url":"/Spring-Cloud-5-Declarative-REST-Client-Feign/","content":"In the previous blog, we can find that when we call the API through `RestTemplate`, the parameters must be spliced in the request URL. If there are only a few parameters, we may still be able to tolerate it. Once there are multiple parameters, then splicing the request string would be inefficient and seem silly. So is there a better solution? The answer is yes, Netflix has provided us with a framework: `Feign`.\n\n`Feign` is a declarative Web Service client, and its purpose is to make Web Service calls easier. `Feign` provides a template for HTTP requests. By writing a simple interface and annotations, you can define the parameters, format, and address of the HTTP request. `Feign` will proxy HTTP requests, and we only need to call it like a method to complete the service request.\n\n`Feign` integrates `Ribbon` and `Hystrix` (I will talk about `Hystrix` later), so that we no longer need to use these two components explicitly. In addition, `Spring Cloud` also provides Spring MVC annotation support for `Feign`, which also allows us to use the same `HttpMessageConverter` in the Web.\n\nIn summary, Feign has the following characteristics:\n* Annotation support, including `Feign` annotations and `JAX-RS` annotations;\n* Support HTTP encoder and decoder;\n* Support `Hystrix` and its Fallback;\n* Support `Ribbon` load balancing;\n* Supports compression of HTTP requests and responses.\n\n## Example Project\nIn this example we will build an e-mall project. We have a `Product-Service` provides product services. It is an `Eureka Client`, and is a service provider. `Product-Service-Consumer` is also an `Eureka Client`. As a service consumer, it uses `Feign`. The `Service-Discovery` remains unchanged (we can directly reuse the code in previous article).\n\n{% asset_img architecture.png %}\n<br/>\n<br/>\n\n### Product-Service\n#### 1. pom.xml\n`Product-Service` is a standard `Eureka Client`, so `pom.xml` is the same as the previous `Service-Hello`\n``` Xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n    </dependency>\n</dependencies>\n```\n\n#### 2. Main class\n``` Java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class ProductServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ProductServiceApplication.class, args);\n    }\n}\n```\n\nThis is same as previous blogs\n\n#### 3. Product entity\n``` Java\npublic class Product {\n    // ========================================================================\n    // fields =================================================================\n    private String itemCode;\n    private String name;\n    private String brandName;\n    private int price;\n\n    // ========================================================================\n    // constructor ============================================================\n    public Product() {\n    }\n\n    public Product(String itemCode, String name, String brandName, int price) {\n        this.itemCode = itemCode;\n        this.name = name;\n        this.brandName = brandName;\n        this.price = price;\n    }\n\n    public String getItemCode() {\n        return itemCode;\n    }\n\n    public void setItemCode(String itemCode) {\n        this.itemCode = itemCode;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getBrandName() {\n        return brandName;\n    }\n\n    public void setBrandName(String brandName) {\n        this.brandName = brandName;\n    }\n\n    public int getPrice() {\n        return price;\n    }\n\n    public void setPrice(int price) {\n        this.price = price;\n    }\n}\n```\n\n#### 4. Product service\n``` Java\n@RestController\n@RequestMapping(\"/products\")\npublic class ProductEndpoint {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ProductEndpoint.class);\n\n    private List<Product> products;\n\n    @Value(\"${server.port}\")\n    private int serverPort = 0;\n\n    public ProductEndpoint() {\n        products = new ArrayList<>();\n        products.add(new Product(\"item-1\", \"test-1\", \"brand1\", 100));\n        products.add(new Product(\"item-2\", \"test-2\", \"brand2\", 200));\n        products.add(new Product(\"item-3\", \"test-3\", \"brand3\", 300));\n        products.add(new Product(\"item-4\", \"test-4\", \"brand4\", 400));\n        products.add(new Product(\"item-5\", \"test-5\", \"brand5\", 500));\n        products.add(new Product(\"item-6\", \"test-6\", \"brand6\", 600));\n    }\n\n    @RequestMapping(method = RequestMethod.GET)\n    public List<Product> list() {\n        LOGGER.info(\"Server port {}\", serverPort);\n\n        return this.products;\n    }\n\n    @RequestMapping(value = \"/{itemCode}\", method = RequestMethod.GET)\n    public Product detail(@PathVariable String itemCode) {\n        LOGGER.info(\"Server port {}\", serverPort);\n\n        for (Product product : products) {\n            if (product.getItemCode().equalsIgnoreCase(itemCode))\n                return product;\n        }\n        return null;\n    }\n}\n```\n\nThis service provides the following two interfaces:\n* list: get product list;\n* detail: get detailed data of the specified product.\n\n#### 5. application.properties\n``` Java\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n\nserver.port=2100\n\nspring.application.name=PRODUCT-SERVICE\n```\n\n#### 6. Launch Testing\nStart `Service-discovery` and `Product-Service`, we can see that `PRODUCT-SERVICE` has registered in the `Eureka server`.\n{% asset_img admin.png %}\n<br/>\n<br/>\n\n### Product-Service-Consumer\n#### 1. pom.xml\n``` Xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-openfeign</artifactId>\n    </dependency>\n</dependencies>\n```\n\n#### 2. Main class\n``` Java\n@EnableFeignClients\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class MallApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MallApplication.class, args);\n    }\n}\n```\n\nWe added the `@EnableFeignClients` annotation to the startup class to enable `Feign` related functions.\n\n#### 3. Service call class\n`Spring Cloud` creates a proxy class that can be called directly by the application according to this interface. In order to complete the proxy, we need to add some annotations, where `@FeignClient` is the `PRODUCT-SERVICE` defined by the `Product-Service`. `@RequestMapping` is an annotation of SpringMVC, which corresponds to two API interfaces provided in the `Product-Service`.\n``` Java\n@FeignClient(value = \"PRODUCT-SERVICE\")\npublic interface ProductService {\n    @RequestMapping(value = \"/products\", method = RequestMethod.GET)\n    List<Product> findAll();\n\n    @RequestMapping(value = \"/products/{itemCode}\", method = RequestMethod.GET)\n    Product loadByItemCode(@PathVariable(\"itemCode\") String itemCode);\n}\n```\n\n> Note: if your service compiles a jar package separately, you need to specify the value of `basePackages` when using the `@EnableFeignClients` annotation. Otherwise, there will be an error reporting `ProductService` bean cannot be found when autowiring.\n\n``` Java\n@EnableFeignClients(basePackages = \"com.feigndemo.**\")\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class MallApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MallApplication.class, args);\n    }\n}\n```\n\n#### 4. Controller\nThe Controller is a standard SpingMVC Controller, which is used to provide users with specific services.\n``` Java\n@RestController\n@RequestMapping(\"/products\")\npublic class ProductController {\n    @Autowired\n    private ProductService productService;\n\n    @RequestMapping(method = RequestMethod.GET)\n    public List<Product> list() {\n        return this.productService.findAll();\n    }\n\n    @RequestMapping(value = \"/{itemCode}\", method = RequestMethod.GET)\n    public Product detail(@PathVariable String itemCode) {\n        return this.productService.loadByItemCode(itemCode);\n    }\n}\n```\n\n#### 5. application.properties\n``` Java \neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n\nserver.port=9090\n\nspring.application.name=PRODUCT-SERVICE-CONSUMER\n```\n\n#### 6. Launch Testing\nStart `Product-Service-Consumer`, and visit: http://localhost:9090/products\n{% asset_img admin2.png %}\n<br/>\n<br/>\n\nAnd visiting http://localhost:9090/products/item-3\n{% asset_img admin3.png %}\n<br/>\n<br/>\n\n## Parameter Binding\n`Feign` supports a variety of annotations. When using `Feign`, we can use `Feign`'s own annotations or `JAX-RS` annotations as needed. Spring Cloud has enhanced `Feign` so that `Feign` supports Spring MVC annotations. As above code:\n``` Java\n@RequestMapping(value = \"/products\", method = RequestMethod.GET)\nList<Product> findAll();\n\n@RequestMapping(value = \"/products/{itemCode}\", method = RequestMethod.GET)\nProduct loadByItemCode(@PathVariable(\"itemCode\") String itemCode);\n```\n\nWe are using Spring MVC annotations. The annotations we commonly use in Spring MVC are:\n* `@RequestParam` binds a single request parameter value;\n* `@PathVariable` binds the URI template variable value;\n* `@RequestHeader` binds the request header data;\n* `@RequestBody` binds the requested content area data and can perform automatic type conversion, etc.\n\nExample of using `@RequestParam`, `@PathVariable`, and `@RequestHeader`:\n``` Java\n@RequestMapping(value = \"/products/detail\", method = RequestMethod.GET)\nProduct loadByItemCode(@RequestParam(\"itemCode\") String itemCode);\n\n@RequestMapping(value = \"/products/{itemCode}\", method = RequestMethod.GET)\nProduct loadByItemCode(@PathVariable(\"itemCode\") String itemCode);\n\n@RequestMapping(value = \"/products/detail\", method = RequestMethod.GET)\nProduct loadByItemCode(@RequestHeader(\"itemCode\") String itemCode);\n```\n\nOf course, we can also use multiple parameter binding, as follows:\n``` Java\n@RequestMapping(value = \"/products/{itemCode}\", method = RequestMethod.POST)\nProduct changPrice(@PathVariable(\"itemCode\") String itemCode, @RequestParam(\"price\") int price);\n```\n\n### Pass object as parameter\nWhen we define an interface, we often include an object in the parameters. For example, our service interface is as follows:\n``` Java\nUser register(User user);\n```\n\nSo how to pass complex `user` object? Just use the `@RequestBody` as follows:\n``` Java\n@RequestMapping(value = \"/users/register\", method = RequestMethod.POST)\nUser register(@RequestBody User user);\n```\n\n> When using it, you need to pay attention that `User` object must have a default constructor, otherwise `Feign` will not be able to convert to the `User` object according to the JSON string, thereby throwing an exception, causing the call to fail.\n\nCheck out the source code here: [Feign demo](https://github.com/nicklee1006/SpringCloudDemo/tree/master/feign)","categories":["Spring Cloud"]},{"title":"Leetcode 79. Word Search","url":"/Leetcode-79-Word-Search/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nSearch if adjacent chars in a 2D board can form the given word.\n\n### Similar Questions\n* Hard - [212. Word Search II](https://leetcode.com/problems/word-search-ii/)\n\n## Solution\nWe can think of the matrix as a graph, and then use the DFS traversal.\n\nWhat we need to do is to determine whether the current traversal element corresponds to the word during the DFS process. If there is no match, end the current traversal, return to previous element, and try other paths. Of course, just like ordinary DFS, we need a visited array to mark whether the element has been visited.\n\n``` Java\npublic boolean exist(char[][] board, String word) {\n    int row = board.length;\n    int col = board[0].length;\n\n    if (row == 0) {\n        return false;\n    }\n\n    // mark if the point is visited\n    boolean[][] visited = new boolean[row][col];\n\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            // (i, j) as a start point\n            if (dfs(board, visited, i, j, word, 0)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n// true if start from (row, col), can find a solution\n// charIndex is the index of char in the word\nprivate boolean dfs(char[][] board, boolean[][] visited, int row, int col, String word, int charIndex) {\n    // check index out bound\n    if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) {\n        return false;\n    }\n\n    // check if the grid has been visited\n    // or the char doesn't match\n    if (visited[row][col] || word.charAt(charIndex) != board[row][col]) {\n        return false;\n    }\n\n    // already match the word\n    if (charIndex == word.length() - 1) {\n        return true;\n    }\n\n    // mark current grid as visited\n    visited[row][col] = true;\n\n    // check up\n    boolean up = dfs(board, visited, row - 1, col, word, charIndex + 1);\n    if (up) {\n        return true;\n    }\n\n    // check down\n    boolean down = dfs(board, visited, row + 1, col, word, charIndex + 1);\n    if (down) {\n        return true;\n    }\n\n    // check left\n    boolean left = dfs(board, visited, row , col - 1, word, charIndex + 1);\n    if (left) {\n        return true;\n    }\n\n    // check right\n    boolean right = dfs(board, visited, row, col + 1, word, charIndex + 1);\n    if (right) {\n        return true;\n    }\n\n    visited[row][col] = false;\n    return false;\n}\n```","tags":["Leetcode - Backtracking","Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 78. Subsets","url":"/Leetcode-78-Subsets/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nReturn all subsets of a set of distinct integers.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-90-Subsets-II '90. Subsets II' %}\n* Medium - [784. Letter Case Permutation](https://leetcode.com/problems/letter-case-permutation/)\n\n## Solution - Iteration\nFirst consider all subset of 1 element of the given array, then all subset of 2 elements of the array ... and finally all subset of n elements of the array. To find all subset of k elements, just add `nums[k]` to all subset of k-1 element.\n\nFor example, the iteration process of nums[1, 2, 3].\n```\ninitialize empty list:      []\n1st iteration (nums[k] = 1):[[], [1]]\n2nd iteration (nums[k] = 2):[[], [1], [2], [1, 2]]\n3rd iteration (nums[k] = 3):[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n```\n\n``` Java\n// result list\nList<List<Integer>> results = new ArrayList<>();\n\n// add empty list\nresults.add(new ArrayList<>());\n\nfor (int num : nums) {\n    // append nums[i] to all existing list\n    List<List<Integer>> temp = new ArrayList<>();\n\n    for (List<Integer> existResult : results) {\n        List<Integer> tempResult = new ArrayList<>(existResult);\n        tempResult.add(num);\n\n        temp.add(tempResult);\n    }\n\n    results.addAll(temp);\n}\n\nreturn results;\n```\n\nOther solutions: [backtracking](https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)\nOther solutions: [bit manipulation](https://leetcode.com/problems/subsets/discuss/27278/C%2B%2B-RecursiveIterativeBit-Manipulation)","tags":["Leetcode - Backtracking","Leetcode - Array","Leetcode - Bit Manipulation"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 4: Load Balancer - Ribbon","url":"/Spring-Cloud-4-Load-Balancer-Ribbon/","content":"Before microservices, the load balancing solution was mainly a centralized load balancer. There was another independent load balancer between service consumers and service providers. Load balancer is usually specialized hardware, such as F5, or software-based, such as VS, HAproxy. There is an address mapping table for all services on the load balancer. When a service consumer invokes a target service, it initiates a request to the load balancer, and the load balancer forwards the request to the target server after performing load balancing using a certain strategy (such as Round-Robin).\n\nThe emergence of microservices provides another idea for the implementation of load balancer: encapsulate the functions of load balancing into a library and integrate it with the service consumer's process, rather than provide a centralized device or server. This solution is called `Soft Load Balancing` or `Client Load Balancing`. In conjunction with the service discovery function of `Eureka` in Spring Cloud, the `Ribbon` sub-project implements load balancing for REST clients.\n\n## Example Project\n### 1. We can extend the eureka demo project\nCode: [Eureka demo](https://github.com/nicklee1006/SpringCloudDemo/tree/eureka-demo)\n### 2. Add Dependency to service-hello-consumer\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\n</dependency>\n```\n\n### 3. Main Class\n``` Java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class HelloServiceConsumerApplication {\n    @Bean\n    @LoadBalanced\n    RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloServiceConsumerApplication.class, args);\n    }\n}\n```\n\nIn this main class:\n* `@EnableDiscoveryClient` annotation, indicating that this is an `Eureka` client, and can also get a list of services registered in the `Eureka server`;\n* We have added a `@LoadBalanced` annotation to the `RestTemplate`. This annotation enables the `RestTemplate` to enable client load balancing function.\n\n### 4. Load Balancing Test\n* 4.1 Start `Eureka server`\n* 4.2 Start multiple service provider: service-hello. Here I started 2 services.\n``` bash\njava -jar service-hello-0.0.1-SNAPSHOT.jar\njava -jar service-hello-0.0.1-SNAPSHOT.jar --server.port=2200\n```\n* 4.3 Start service consumer: service-hello-consumer\n* 4.4 Open the Eureka server admin page: http://localhost:8761, we can see that two `HELLO-SERVICE` services and one `HELLO-CONSUMER` service have been registered.\n{% asset_img admin.png %}\n<br/>\n<br/>\n\n* 4.5 Visit `Hello-Consumer`: http://localhost:8080/hello and refresh it multiple times. We can see the following two outputs appear alternately:\n{% asset_img page1.png %}\n<br/>\n<br/>\n{% asset_img page2.png %}\n<br/>\n<br/>\nIt shows that `hello-consumer` is accessing two service instances of `HELLO-SERVICE` alternately, which means that our load balancing test is successful.\n\n## Ribbon's load balancing strategy\nRibbon itself provides the following load balancing strategies:\n\n* **RoundRobinRule:** Round robin policy. `Ribbon` selects the server in round robin manner. This is the default value. So the two services started in the example will be cyclically accessed;\n* **RandomRule:** Random selection, which means that `Ribbon` will randomly select one from the server list to access randomly;\n* **BestAvailableRule:** The maximum availability policy. After filtering out the failed server, select the one with the lowest number of concurrent requests;\n* **WeightedResponseTimeRule:** With a weighted polling strategy. The response time of each server is weighted, and then the corresponding server is obtained by polling;\n* **AvailabilityFilteringRule:** Available filtering strategy. First filter out some service instances that have failed or concurrent requests are larger than the threshold, and then select one from the filtered instance list in a linear polling manner;\n* **ZoneAvoidanceRule:** Zone-aware strategy. First use the primary filter (zone loader, select the optimal zone) to filter all instances and return the filtered instance list. Use the filters in the secondary filter condition list to perform on the results of the primary filter. Determine the minimum number of filters (default 1) and the minimum percentage of filtering (default 0), and finally use `RoundRobinRule` (polling method) to select a server instance from the server that meets the conditions.\n\n> We can implement our own load balancing strategy by inheriting `ClientConfigEnabledRoundRobinRule`.\n\nCheck out the source code here: [Ribbon demo](https://github.com/nicklee1006/SpringCloudDemo/tree/master/ribbbon)","categories":["Spring Cloud"]},{"title":"Leetcode 75. Sort Colors","url":"/Leetcode-75-Sort-Colors/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGive an array containing only 0, 1, and 2, sort the numbers from small to large.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-148-Sort-List '148. Sort List' %}\n* Medium - [324. Wiggle Sort II](https://leetcode.com/problems/wiggle-sort-ii/)\n\n## Solution 1\nA very straightforward method. Requires 2 iterations. During first iteration, count the number of occurrences of 0, the number of occurrences of 1, and the number of occurrences of 2. During second iteration, traverse the array and change the elements of the array to the corresponding values according to the number of occurrences. Of course we only need to record 0 and 1, and the rest is 2.\n\nTime complexity O(n), space complexity O(1).\n\n## Solution 2\nSolution 1 requires 2 iterations. Can we do better in only 1 iteration?\n\nSuppose the array only have number 0 and 1 (e.g, `1 0 1 1 0`). We can use a pointer, `zero_position`, meaning the positions before this pointer are `0`. Then use a pointer `i` to traverse the array, find 0 and put 0 to the position pointed by `zero_position`, and move `zero_position` forward. Let `Z` be `zero_position` and see the traversal process below.\n```\n1 0 1 1 0   Initialize Z,i point to position 0，move forward i\n^\nZ\ni\n\n1 0 1 1 0   Find 0，exchange value at Z and i, move forward Z\n^ ^\nZ i\n\n0 1 1 1 0   Move forward i\n  ^\n  i\n  Z\n\n0 1 1 1 0  Move forward i\n  ^ ^\n  Z i\n\n0 1 1 1 0  Move forward i\n  ^   ^\n  Z   i\n\n0 1 1 1 0  Found 0，exchange value at Z and i, move forward Z\n  ^     ^\n  Z     i\n\n0 0 1 1 1  Finish\n    ^   ^\n    Z   i\n```\n\nNow We have 3 numbers, so we can use two pointers, one is `zero_position`. As before, all the positions before it are all 0. Another pointer, `two_position`. All the positions after it are all 2.\n\n```\n0 1 0 2 1 2 2 2\n  ^ ^   ^\n  Z i   T\n```\n\n``` Java\n// elements before this are all '0'\nint zeroIndex = 0;\n// elements after this are all '2'\nint twoIndex = nums.length - 1;\n\nfor (int i = 0; i <= twoIndex; i++) {\n    if (nums[i] == 0) {\n        // exchange zeroIndex with i\n        int temp = nums[zeroIndex];\n        nums[zeroIndex] = nums[i];\n        nums[i] = temp;\n\n        // move forward zeroIndex\n        zeroIndex++;\n    } else if (nums[i] == 2) {\n        // exchange twoIndex with i\n        int temp = nums[twoIndex];\n        nums[twoIndex] = nums[i];\n        nums[i] = temp;\n\n        // move backward twoIndex\n        twoIndex--;\n        // Note here since we exchanged the number after index i\n        // We haven't check this number yet. It will be skipped\n        // So we need i--, to check this number\n        i--;\n    }\n}\n```\n\nTime complexity O(n), space complexity O(1).","tags":["Leetcode - Array","Leetcode - Two Pointers","Leetcode - Sort"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 74. Search a 2D Matrix","url":"/Leetcode-74-Search-a-2D-Matrix/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nSearch a value in an m x n matrix, determine if it exists.\n\n### Similar Questions\n* Medium - [240. Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/)\n\n## Solution\nAs the martix is ordered, there is no doubt that we need to use binary search. First find which row the target belongs to, then use binary search to determine. We just need to consider how to convert the index into the row and column of the matrix. To do so, we can use division and mod.\n\n``` Java\n// matrix is empty\nif (matrix.length == 0 || matrix[0].length == 0) {\n    return false;\n}\n\nint col = matrix[0].length;\n\n// loop each row, find which row the target belongs to\nfor (int[] ints : matrix) {\n    // target in this row\n    if (target >= ints[0] && target <= ints[col - 1]) {\n        // use binary search to this row\n        int low = 0;\n        int high = col - 1;\n\n        while (low <= high) {\n            int mid = (low + high) / 2;\n\n            if (target == ints[mid]) {\n                return true;\n            } else if (target < ints[mid]) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return false;\n    }\n}\n\nreturn false;\n```","tags":["Leetcode - Array","Leetcode - Binary Search"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 64. Minimum Path Sum","url":"/Leetcode-64-Minimum-Path-Sum/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nFrom top left to bottom right, find a path that minimize the sum along the path.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-62-Unique-Paths '62. Unique Paths' %}\n* Hard - [174. Dungeon Game](https://leetcode.com/problems/dungeon-game/)\n* Hard - [741. Cherry Pickup](https://leetcode.com/problems/cherry-pickup/)\n\n## Solution\nDefine a 2D array. Each element of the array represent the minimum sum starting from top left point to this point. For example, `dp[i][j] = 5` means that starting from `(0, 0)` to `(i, j)`, the minimum sum is 5.\n\nThe value on the first row, it is only reachable from its left point. And first column is only reachable from its up point.\n\nFor other points, the minimum sum is the sum of itself and minimum value of the point up it and left to it. Thus we have our dynamic programming formula: `dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1])`. And we start to fill the dp array from second row.\n\n``` java\n// result grid\nint[][] dp = new int[grid.length][grid[0].length];\n\ndp[0][0] = grid[0][0];\n\n// fill the first row, one reachable from its left point\nfor (int i = 1; i < grid[0].length; i++) {\n    dp[0][i] = dp[0][i - 1] + grid[0][i];\n}\n\n// fill the first column, one reachable from its up point\nfor (int i = 1; i < grid.length; i++) {\n    dp[i][0] = dp[i - 1][0] + grid[i][0];\n}\n\n// only one row or column\nif (grid.length == 1 || grid[0].length == 1) {\n    return dp[grid.length - 1][grid[0].length - 1];\n}\n\n// start from [1, 1], fill the result array\nfor (int i = 1; i < grid.length; i++) {\n    for (int j = 1; j < grid[0].length; j++) {\n        dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);\n    }\n}\n\nreturn dp[grid.length - 1][grid[0].length - 1];\n```","tags":["Leetcode - Dynamic Programming","Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 3: Eureka Clustering","url":"/Spring-Cloud-3-Eureka-Clustering/","content":"Last post we talked about `Eureka`. It is one of the key elements of Spring Cloud. Service center as a critical service, if it is a single point and having a failure then it is devastating. In a distributed system, the service center is the most important part and should be in a state that can provide services at any time. To maintain its availability, using clusters is a good solution. `Eureka` achieves high availability deployment by registering with each other, so we only need to configure `Eureke Server` with other available `serviceUrl` to achieve high availability deployment.\n\n## Two-node service center\nFirst let's try to setup a two-node service center.\n\n### 1. Create application-peer1.properties\n`Peer1` service center's configuration. Pointing `serviceUrl` to `peer2`.\n``` Java\nspring.application.name=spring-cloud-eureka-server\nserver.port=8000\neureka.instance.hostname=peer1\n\neureka.client.register-with-eureka=true\neureka.client.fetch-registry=true\n\neureka.client.serviceUrl.defaultZone=http://peer2:8001/eureka/\n```\n\n### 2. Create application-peer2.properties\n`Peer2` service center's configuration. Pointing `serviceUrl` to `peer1`.\n``` Java\nspring.application.name=spring-cloud-eureka-server\nserver.port=8001\neureka.instance.hostname=peer2\n\neureka.client.register-with-eureka=true\neureka.client.fetch-registry=true\n\neureka.client.serviceUrl.defaultZone=http://peer1:8000/eureka/\n```\n\n### 3. Host file\nAdd the following 2 lines to `hosts` file\n```\n127.0.0.1 peer1  \n127.0.0.1 peer2  \n```\n\n### Start server\nRun the following command\n``` bash\n# package jar file\nmvn clean package\n# start eureka server using 2 configurations\njava -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1\njava -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2\n```\n\nVisit `http://localhost:8000/`\n{% asset_img page1.png %}\n<br/>\n<br/>\n\nWe can see that `peer1`'s service center DS Replicas already has the configuration information of `peer2`, and `peer2` appears in available-replicas. If we manually stopped `peer2`, then `peer2` would move to the unavailable-replicas column, indicating that peer2 was unavailable.\n\n## Use eureka cluster\nIn production, we may need three or more service centers to ensure the stability of the service. The configuration are actually the same: pointing the service centers to other service centers. Here I will only introduce the configuration of only three clusters. In fact, it is similar to the two-node service center. Each service center can point to the other two nodes.\n\napplication-peer1.properties\n``` Java\nspring.application.name=spring-cloud-eureka-server\nserver.port=8000\neureka.instance.hostname=peer1\n\neureka.client.register-with-eureka=true\neureka.client.fetch-registry=true\n\neureka.client.serviceUrl.defaultZone=http://peer2:8001/eureka/, http://peer3:8002/eureka/\n```\n\napplication-peer2.properties\n``` Java\nspring.application.name=spring-cloud-eureka-server\nserver.port=8001\neureka.instance.hostname=peer2\n\neureka.client.register-with-eureka=true\neureka.client.fetch-registry=true\n\neureka.client.serviceUrl.defaultZone=http://peer1:8000/eureka/, http://peer3:8002/eureka/\n```\n\napplication-peer3.properties\n``` Java\nspring.application.name=spring-cloud-eureka-server\nserver.port=8002\neureka.instance.hostname=peer3\n\neureka.client.register-with-eureka=true\neureka.client.fetch-registry=true\n\neureka.client.serviceUrl.defaultZone=http://peer1:8000/eureka/, http://peer2:8001/eureka/\n```\n\nStart `peer1`, `peer2`, `peer3` eureka server\n``` bash\njava -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1\njava -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2\njava -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer3\n```\n\nVisit `http://localhost:8000/`\n{% asset_img page2.png %}\n<br/>\n<br/>\n\nWe can see `peer2` and `peer3`'s information in `peer1`\n\nCheck out the source code here: [Eureka cluster demo](https://github.com/nicklee1006/SpringCloudDemo/tree/master/eureka-cluster)","categories":["Spring Cloud"]},{"title":"Spring Cloud 2: Service Discovery - Eureka","url":"/Spring-Cloud-2-Service-Discovery/","content":"`Eureka` is a Netflix open source product that provides service registration and discovery. It provides a complete implementation of `Service Registry` and `Service Discovery`. It is also one of the most important and core components of Spring Cloud.\n\n## Service Center\nThe service center is also called the registration center, which manages various service functions including service registration, discovery, fusing, load balancing, and downgrading. So how does it makes service call easier? Let's see an example.\n\nWithout service center, we have `service A` calls `service B`, and `service B` calls `service C`.\n{% asset_img service1.png %}\n<br/>\n<br/>\n\nWith service center, the service calls have two steps. In the first step, `service A` first requests the `service B` from the `service center`, and then `service B` requests the `service C` from the `service center`.\n{% asset_img service2.png %}\n<br/>\n<br/>\n\nThe above examples are just two or three simple calls to each other, but imagine if there are more than 20 and 30 services. With `service center` you do not need to know the IP address of the service you call, or how many servers it has. Each time simply go directly to the `service center` and get the services that needs to be call.\n\nSince various services are registered in the `service center`, many advanced functions can be implemented. For example, having several services providing the same service for load balancing; monitoring the service call success rate for fusing, removing fault points in the service list; monitoring service call time to set different weights for different services, and so on.\n\n## Eureka\nSpring Cloud encapsulates the `Eureka` module developed by Netflix to implement service registration and discovery. `Eureka` uses the C-S design architecture. `Eureka Server` is the server for the service registration function. It is the service registration center. The other microservices in the system use `Eureka Client` to connect to `Eureka Server` and maintain a heartbeat connection. In this way, the system maintenance staff can monitor whether the microservices in the system are running normally through `Eureka Server`. Some other modules of Spring Cloud (such as `Zuul`) can use `Eureka Server` to discover other microservices in the system and execute related logic.\n\n`Eureka` consists of two components: `Eureka Server` and `Eureka Client`. `Eureka Server` is used as a service registration server. The `Eureka Client` is a java client that is used to simplify interaction with the server, act as a polling load balancer, and provide failover support for services.\n{% asset_img service3.png %}\n<br/>\n<br/>\n\nThe above diagram briefly describes the basic architecture of `Eureka`, which consists of 3 roles:\n* **Eureka Server**: Service registration center, responsible for service registration, maintenance and query of service list\n* **Service Provider**: An `Eureka Client`, responsible for registering, renewing, and deregistering the services with `Eureka Server`. The main data provided during registration includes service name, machine IP, port number, domain name, etc., so that service consumers can find it\n* **Service Consumer**: An `Eureka Client`, will also register itself with the services provided by `Eureka Server`. Usually with consumer, it is more to obtain the corresponding service list from `Eureka Server`, so that it can initiate service calls.\n\n> Service Provider and Service Consumer are not a strict concept, often the service consumer is also a service provider, and at the same time, the service provider may also call the services provided by other service providers. Of course, when we build microservices, we still need to adhere to the division between business levels and try to avoid circular dependencies between services.\n\n## Example Project\nIn this example project, I will have 3 modules:\n* **Service-discovery**: As the service registration center and `Eureka server`\n* **Service-hello**: Service provider and `Eureka client`\n* **Service-hello-consumer**: Service consumer and `Eureka client`\n{% asset_img architecture.png %}\n<br/>\n<br/>\n\n### Service-discovery\n#### 1. Add dependency\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-dependencies</artifactId>\n    <version>Greenwich.SR4</version>\n    <type>pom</type>\n    <scope>import</scope>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n\n#### 2. Main class\n``` Java\n@EnableEurekaServer\n@SpringBootApplication\npublic class ServiceDiscoveryApplication {\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(ServiceDiscoveryApplication.class).web(WebApplicationType.SERVLET).run(args);\n    }\n}\n```\n\nThe key here is adding `@EnableEurekaServer`, to declare that it is an `Eureka server`.\n\n#### 3. Configuration file\nConfiguration is placed under `resource/application.properties`\n\n``` Java\nserver.port=8761\n\nspring.application.name=eureka-server\n\neureka.instance.hostname=localhost\neureka.client.register-with-eureka=false\neureka.client.fetch-registry=false\neureka.client.service-url.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka\n```\n\n* `eureka.client.register-with-eureka`: Whether to register itself with Eureka Server. The default is `true`.\n* `eureka.client.fetch-registry`: Whether to obtain registration information from Eureka Server. The default is `true`.\n* `eureka.client.service-url.defaultZone`: Set the address to interact with `Eureka Server`. Both the query service and the registration service need to rely on this address. The default is `http://localhost:8761/eureka`; multiple addresses can be separated by ','.\n\n#### 4. Start server\nStart the server and visit `http://localhost:8761`, should be able to see the following page:\n{% asset_img page.png %}\n<br/>\n<br/>\n\nUnder `Instance currently registered with Eureka` section, there is no service instance registered yet.\n\n### Service-hello\nIn this example, we define a simple service. It returns a string `Hello, Spring Cloud!` When calling the `/hello` service endpoint.\n\n#### 1. Add dependency\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-dependencies</artifactId>\n    <version>Greenwich.SR4</version>\n    <type>pom</type>\n    <scope>import</scope>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n#### 2. Main class\n``` Java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class HelloServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(HelloServiceApplication.class, args);\n    }\n}\n```\n\nThe difference here with the `service-discovery` is change the annotation to `@EnableDiscoveryClient`, to declare that it is an `Eureka client`.\n\n#### 3. API service\n``` Java\n@RestController\npublic class HelloEndpoint {\n    private static final Logger LOGGER = LoggerFactory.getLogger(HelloEndpoint.class);\n\n    @Autowired\n    private EurekaInstanceConfig eurekaInstanceConfig;\n    @Value(\"${server.port}\")\n    private int serverPort = 0;\n\n    @RequestMapping(value = \"/hello\", method = RequestMethod.GET)\n    public String hello() {\n        LOGGER.info(\"/hello, instanceId:{}, host:{}\", eurekaInstanceConfig.getInstanceId(), eurekaInstanceConfig.getHostName(false));\n\n        return \"Hello, Spring Cloud! My port is \" + serverPort;\n    }\n}\n```\n\nA very simple service provide only `/hello` endpoint\n\n#### 4. Configuration\n``` Java\nserver.port=2100\n\nspring.application.name=HELLO-SERVICE\n\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n```\n\nHere the `spring.application.name` must be set. Service consumer find this service by this name. `eureka.client.service-url` must also be set. It means that we want to register services with those `Eureka servers`. Here we can declare multiple `Eureka servers`\n\n#### 5. Start server\nAfter server start-up, should be able to see this console log:\n``` Java\ncom.netflix.discovery.DiscoveryClient    : DiscoveryClient_HELLO-SERVICE/192.168.1.106:HELLO-SERVICE:2100 - registration status: 204\n```\n\nRefresh http://localhost:8761:\n{% asset_img page2.png %}\n<br/>\n<br/>\n\nWe have successfully registered our service to the `Eureka server`.\n\n### Service-hello-consumer\nIn the previous sections, a simple `Eureka server` and client has been built. In order for us to better appreciate the role played by Eureka, let's build a service consumer that will call the services provided by `SERVICE-HELLO`.\n\n#### 1. Add dependency\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-dependencies</artifactId>\n    <version>Greenwich.SR4</version>\n    <type>pom</type>\n    <scope>import</scope>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\nSame as `Service-hello`.\n\n#### 2. Main class\n``` Java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class HelloServiceConsumerApplication {\n    @Bean\n    @LoadBalanced\n    RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloServiceConsumerApplication.class, args);\n    }\n}\n```\n\nSame as `Service-hello`, annotated with `@EnableDiscoveryClient` to declare a `Eureka client`.\n\n#### 3. Service call\n``` Java\n@RestController\npublic class HelloController {\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @RequestMapping(value = \"/hello\", method = RequestMethod.GET)\n    public String hello() {\n        return restTemplate.getForEntity(\"http://HELLO-SERVICE/hello\", String.class).getBody();\n    }\n}\n```\n\nThe service call is a standard controller. The `hello()` method will call the `SERVICE-HELLO/hello` service through the `restTemplate` and return.\n\n#### 4. Configuration\n``` Java\nserver.port=8080\n\nspring.application.name=hello-consumer\n\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n```\n\n#### 5. Start server\nAfter server start-up, should also be able to see this console log:\n``` Java\ncom.netflix.discovery.DiscoveryClient    : DiscoveryClient_HELLO-CONSUMER/192.168.1.106:hello-consumer:8080 - registration status: 204\n```\n\nRefresh http://localhost:8761:\n{% asset_img page3.png %}\n<br/>\n<br/>\n\nWe can see there are 2 services registered.\n\n#### 6. Verify the service call\nVisit http://localhost:8080/hello, should see the response:\n{% asset_img page4.png %}\n<br/>\n<br/>\n\nAlso the console log of `Service-hello` should have an output:\n``` Java\nINFO 6602 --- [nio-2100-exec-1] s.helloservice.endpoint.HelloEndpoint    : /hello, instanceId:192.168.1.106:HELLO-SERVICE:2100, host:192.168.1.106\n```\n\nNow we have successfully built our first Spring Cloud Eureka demo.\n\nCheck out the source code here: [Eureka demo](https://github.com/nicklee1006/SpringCloudDemo/tree/master/eureka)","categories":["Spring Cloud"]},{"title":"Leetcode 63. Unique Paths II","url":"/Leetcode-63-Unique-Paths-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nSimilar to {% post_link Leetcode-62-Unique-Paths 'Question 62: Unique Paths' %}. This time given a input array to mark obstacles.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-62-Unique-Paths '62: Unique Paths' %}\n* Hard - [980. Unique Paths III](https://leetcode.com/problems/unique-paths-iii/)\n\n## Solution\nThe solution is similar to {% post_link Leetcode-62-Unique-Paths 'Question 62: Unique Paths' %}. Define a 2D array `result`. Each element of `result` represent the unique path starting from this point to bottom-right point.\n\nThe point on the last row and last column can only have 1 unique path (because we can only move right and down). However, if we traverse from the last to the first (e.g, from right to left or bottom to top), if there are any obstacle on the route, then the rest on the last row and last column is 0, as this route is blocked.\n\nFor other points, the number of unique paths is determined by unique path of the point below it and right to it. There are 3 situations:\n1. If both bottom and right point is obstacle or the position itself is obstacle, set to 0\n2. If only one of bottom and right point is obstacle, set to right or bottom \n3. Otherwise, `result[i][j] = result[i + 1][j] + result[i][j + 1]`.\n\nFinally we just need to get the value of `result[0][0]`\n\n``` Java\n// get number of columns and rows\nint columns = obstacleGrid[0].length;\nint rows = obstacleGrid.length;\n\n// result array\nint[][] result = new int[rows][columns];\n\n// check if the bottom-right point itself is obstable or not\nresult[rows - 1][columns - 1] = obstacleGrid[rows - 1][columns - 1] == 1 ? 0 : 1;\n\n// to mark if encounter any obstacle on last row\nint obstacle = 0;\n\n// fill right most column and last row with 1 or 0\nfor (int i = columns - 1; i >= 0; i--) {\n    if (obstacleGrid[rows - 1][i] == 1) {\n        obstacle = -1;\n    }\n    \n    result[rows - 1][i] = 1 + obstacle;\n}\n\n// to mark if encounter any obstacle on last column\nobstacle = 0;\nfor (int i = rows - 1; i >= 0; i--) {\n    if (obstacleGrid[i][columns - 1] == 1) {\n        obstacle = -1;\n    }\n\n    result[i][columns - 1] = 1 + obstacle;\n}\n\n// start from second last row and column\nfor (int i = rows - 2; i >= 0; i--) {\n    for (int j = columns - 2; j >= 0; j--) {\n        // both right or below point is obstacle or the point itself is obstacle\n        if ((obstacleGrid[i][j + 1] == 1 && obstacleGrid[i + 1][j] == 1) || obstacleGrid[i][j] == 1) {\n            result[i][j] = 0;\n        // the point below is obstacle\n        } else if (obstacleGrid[i][j + 1] == 1) {\n            result[i][j] = result[i + 1][j];\n        // the point at right is obstacle\n        } else if (obstacleGrid[i + 1][j] == 1) {\n            result[i][j] = result[i][j + 1];\n        } else {\n            result[i][j] = result[i][j + 1] + result[i + 1][j];\n        }\n    }\n}\n\nreturn result[0][0];\n```\n","tags":["Leetcode - Dynamic Programming","Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 1: What is Spring Cloud","url":"/Spring-Cloud-1-What-is-Spring-Cloud/","content":"I have been learning Spring Cloud recently, and found it quite interesting. So I would write a series of blogs to introduce different components of Spring Cloud. Let's begin with a brief introduction of Spring Cloud.\n\nSo what is Spring Cloud? In short, Spring Cloud is a collection of a series of frameworks. It is based on Spring Boot and make use of it to simplify the development of distributed system infrastructure. Spring Cloud consists of several useful functionalities such as `service discovery`, `configuration center`, `message bus`, `load balance`, and `monitoring`. It provides a complete set of solution to build an enterprise level cloud application.\n\nSpring Cloud includes several sub-projects, such as `Spring Cloud Config`, `Spring Cloud Netflix`, `Spring Cloud Security`, etc. Spring collects those mature frameworks from different companies, uses Spring Boot style to re-encapsulate them and removes complicated configuration, and gives developers an easy-to-use, easy-to-deploy and easy-to-maintain distributed system development toolkit.\n\nWith Spring Cloud, every individual service could be a separated application. It can be deployed individually, scale horitontallly and accessed individually. Those services are service unit, which is always called `microservice` (because they are usually very 'small' service that provides a certain type of service). Spring Cloud is the manager of all those microservices. Using microservice architecture, the number of projects (modules) would be huge, but Spring Cloud facilitate the management of all that.\n\nNow let's look at some most important components of Spring Cloud. It is a brief introduction, I will discuss more details in the following blogs.\n\n## Key Components\n### Netflix Eureka\nService center. CLoud side service discovery. It's the basic of Spring Cloud. All service register themselves at the service center. If one service need to invoke another service, it can find it in the service center as well.\n\n### Netflix Hystrix\nCircuit breaker. Provides a powerful fault tolerant capability. For example, if a service is not responding, but other services are not aware of that, that failing service will affect the system performance. With Hystrix, it would notify other services that the failing service can't be used.\n\n### Ribbon\nLoad balancer.\n\n### Netflix Zuul\nDynamic routing. Zuul is the front door of all front end applications and the back end services. When users invoke services, it must go through Zuul, see if the request is valid.\n\n### Spring Cloud Config\nConfiguration center. Developer can put all configurations to a remote server and manages those together rather than manage for each individual service.\n\n### Spring Cloud Bus\nEvent and message bus.\n\n### Spring Cloud Security\nSecurity toolkit basic on Spring Security. Add security control to the cloud application.\n\n### Spring Cloud Sleuth\nLogging toolkits. Provide solution of distributed routing tracking.\n\nThe relationship between all those components:\n{% asset_img 1.png %}\n<br/>\n<br/>\n\n* All request go through API gateway `Zuul` to get access to services.\n* API gateway obtain available service from service registry `Eureka`.\n* `Ribbon` complete load balancing and dispath request to back end service instancve.\n* All microserve use `Feign` to communicate.\n* `Hystrix` handles circuit breaker if services are unavailable.\n\nThese are the main components, but there a lot more other sercices that are provided by Spring Cloud.\n\n## Relationship with Spring Boot\n`Spring Boot` can be used to develop individual microservice, while `Spring Cloud` is based on `Spring Boot` to facilitate cloud application development. One can use only `Spring Boot` to develop application without `Spring Cloud`, but to develop `Spring Cloud`, `Spring Boot` must be used. There is a dependency relationship.\n\nPlease note that there is a strict relationship with the version of `Spring Cloud` and `Spring Boot`. If the versions don't match, the system won't work. Below is the table shows the relationship.\n\n<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg .tg-axxb{font-weight:bold;background-color:#c0c0c0;color:#000000;border-color:inherit;text-align:center;vertical-align:top}\n.tg .tg-n9g5{background-color:#ffffff;color:#000000;border-color:inherit;text-align:left;vertical-align:middle}\n</style>\n<table class=\"tg\">\n  <tr>\n    <th class=\"tg-axxb\">Spring Cloud</th>\n    <th class=\"tg-axxb\">Spring Boot</th>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">Angel</td>\n    <td class=\"tg-n9g5\">Spring Boot 1.2.x</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">Brixton</td>\n    <td class=\"tg-n9g5\">Spring Boot 1.3.x, and Spring Boot 1.4.x</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">Camden</td>\n    <td class=\"tg-n9g5\">Spring Boot 1.4.x, and Spring Boot 1.5.x</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">Dalston, Edgware</td>\n    <td class=\"tg-n9g5\">Spring Boot 1.5.x, not compatiable with Spring Boot 2.0.x</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">Finchley</td>\n    <td class=\"tg-n9g5\">Spring Boot 2.0.x, not compatiable with Spring Boot 1.5.x</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">Greenwich</td>\n    <td class=\"tg-n9g5\">Spring Boot 2.1.x</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">Hoxton</td>\n    <td class=\"tg-n9g5\">Spring Boot 2.2.x</td>\n  </tr>\n</table>\n\nIn the following blogs, I will using Spring Cloud `Greenwich` version.\n\n## Advantage of Spring Cloud\nThere are other microservice frameworks, such as `Dubbo`, `Kubernetes`. What are `Spring Cloud`'s advantages compared with those?\n* It is from Spring family. Make use of `Spring Boot` makes developing individual service a lot easier.\n* The community is very active. Lots of tutorials out there, and easy to find solutions.\n* Get circuit breaker, load balance, service discovery with only a few lines of code.\n\n","categories":["Spring Cloud"]},{"title":"Leetcode 62. Unique Paths","url":"/Leetcode-62-Unique-Paths/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nCount the number of paths from top-left corner to bottom-right corner. Can only move down or right.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-63-Unique-Paths-II '63: Unique Paths II' %}\n* Medium - {% post_link Leetcode-64-Minimum-Path-Sum '64. Minimum Path Sum' %}\n* Medium - [174. Dungeon Game](https://leetcode.com/problems/dungeon-game/)\n\n## Solution\nUse the idea of dynamic programming, we can define a 2D array. Each element of the array represent the unique path starting from this point to bottom-right point. For example, `dp[i][j] = 5` means that starting from `(i, j)`, there are 5 unique paths.\n\nLet's observe the problem. The first insight we can have is that the point on the last row and last column can only have 1 unique path (because we can only move right and down).\n\nFor other points, the number of unique paths is the sum of unique path of the point below it and right to it. Thus we have our dynamic programming formula: `dp[i][j] = dp[i + 1][j] + dp[i][j + 1]`. And we start to fill the dp array from second last row.\n\n``` Java\n// dp array\nint[][] result = new int[n][m];\n\nresult[n - 1][m - 1] = 1;\n// fill last row with 1\nfor (int i = 0; i < m - 1; i++) {\n    result[n - 1][i] = 1;\n}\n\n// fill right most column with 1\nfor (int i = 0; i < n - 1; i++) {\n    result[i][m - 1] = 1;\n}\n\n// fill the table from second last row\nfor (int i = n - 2; i >= 0; i--) {\n    for (int j = m - 2; j >= 0; j--) {\n        result[i][j] = result[i][j + 1] + result[i + 1][j];\n    }\n}\n\nreturn result[0][0];\n```\n\nTime complexity O(n * m), space complexity O(n * m).","tags":["Leetcode - Dynamic Programming","Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Cron Expressions","url":"/Cron-Expressions/","content":"Cron expression is a string comprising five or six fields separated by white space that represents a set of times. It is widely used to execute some scheduled tasks. It can be used with [Spring Scheduling Tasks](https://spring.io/guides/gs/scheduling-tasks/), or linux scheduled tasks.\n\n## Expression\n&#60;second&#62; &#60;minute&#62; &#60;hour&#62; &#60;day-of-month&#62; &#60;month&#62; &#60;day-of-week&#62; &#60;year&#62;\n\nwhere &#60;year&#62; field is optional.\n\n* **second**: may have `, - * /`, valid value is integer `0-59`\n* **minute**: may have `, - * /`, valid value is integer `0-59`\n* **hour**: may have `, - * /`, valid value is integer `0-23`\n* **day-of-month**: may have `, - * / ? L W C`, valid value is integer `0-31`\n* **month**: may have `, - * /`, valid value is integer `1-12` or `JAN-DEC`\n* **day-of-week**: may have `, - * / ? L C #`, valid value is integer `1-7` or `SUN-SAT`. `1` represent sunday, `2` represent monday...\n* **year**: may have `, - * /`, valid value is integer `1970-2099`\n\n## Specials Characters In Expression\n* **\\* (all)**: Means matching any value in the field. If using `*` in the `minute` field, it means that the event will be triggered every minute.\n* **? (any)**: Can only be applied to `day-of-month` and `day-of-week` field. It also matches any value of the field. For example, if you want to trigger the scheduling on the 20th of each month, no matter what day of week the 20th is, you can only use the following expression: `13 13 15 20 * ?`. The last bit can only use `?`.\n* **– (range)**: Means range. For example, Using `5-20` in the `minute` field means that it is triggered every minute from 5 minutes to 20 minutes.\n* **, (values)**: Means that the trigger starts at the start time, and then triggers at regular intervals. Write as `start/intervals`. For example, using 5/20 in the `minute` field means triggering at 5 minutes, and 25 minutes, 45 minutes.\n* **/ (increments)**: Means enumerated values. For example: using `5,20` in the `minute` field means triggering at 5 and 20 minutes.\n* **L (last)**: Means at the end. It can only appear in the `day-of-week` and `day-of-month` fields. If `5L` is used in the `day-of-week` field, it means that it is triggered on the last Thursday of the month.\n* **W (weekday)**: Means a valid working day (Monday to Friday). It can only appear in the `day-of-month` field. The system will trigger an event on the closest valid working day from the specified date. For example: `5W` is used in `day-of-month`. If the 5th is Saturday, it will be triggered on the nearest working day: Friday, that is, the 4th. If the 5th is Sunday, it will be triggered on the 6th (Monday); if the 5th is one of Monday to Friday, it will be triggered on the 5th. In addition, W's nearest search will not cross the month\n* **LW**: These two characters can be used together to indicate the last working day of a month, that is, the last Friday.\n* **\\#**: It is used to determine the day of the week of each month and can only appear in the `day-of-month` field. For example, `4#2` means the second Wednesday of a month.\n\n## Examples\n`30 * * * * ?`: Trigger task every 30 seconds\n`30 10 * * * ?`: Trigger task at 10 minutes and 30 seconds per hour\n`30 10 1 * * ?`: Trigger task every day at 1:10:30\n`30 10 1 20 * ?`: Trigger task at 1:10:30 on the 20th of each month\n`30 10 1 20 10 ? *`: Trigger task at 1:10:30 on the October 20th of each year\n`30 10 1 20 10 ? 2011`: Trigger task at 1:10:30 on the October 20th of 2011\n`30 10 1 ? 10 * 2011`: Trigger task every day at 1:10:30 in October 2011\n`30 10 1 ? 10 SUN 2011`: Trigger task every Sunday at 1:10:30 in October 2011\n`15,30,45 * * * * ?`: Trigger task every 15 seconds, 30 seconds, and 45 seconds\n`15-45 * * * * ?`: Trigger task every second from 15 to 45 seconds\n`15/5 * * * * ?`: Trigger task every 5 seconds starting at 15 seconds\n`15-30/5 * * * * ?`: Trigger task every 5 seconds between 15 and 30 seconds every minute\n`0 0/3 * * * ?`: Trigger task every 3 minutes starting 0 minutes and 0 seconds\n`0 15 10 ? * MON-FRI`: Trigger task from 10:15:00 from Monday to Friday\n`0 15 10 L * ?`: Trigger task at 10:15:00 on the last day of each month\n`0 15 10 LW * ?`: Trigger task at 10:15:00 on the last working day of each month\n`0 15 10 ? * 5L`: Trigger task at 10:15:00 on the last Thursday of every month\n`0 15 10 ? * 5#3`: Trigger task at 10:15:00 on the third week of each month","tags":["Cron Expression"]},{"title":"Leetcode 56. Merge Intervals","url":"/Leetcode-56-Merge-Intervals/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nMerge the intervals that have overlaps.\n\n### Similar Questions\n* Hard - [57. Insert Interval](https://leetcode.com/problems/insert-interval/)\n* Medium - [495. Teemo Attacking](https://leetcode.com/problems/teemo-attacking/)\n* Hard - [715. Range Module](https://leetcode.com/problems/range-module/)\n* Medium - [763. Partition Labels](https://leetcode.com/problems/partition-labels/)\n* Medium - [986. Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/)\n\n## Solution\nSuppose given an array of size `n`, then we assume that the first `n-1` elements has been merged. What we have to solve now is the remaining one, how to add it to the `n-1` elements that have been merged.\n\nWhat we can do here is first sort the whole array by the left endpoint of the interval. Then loop the whole array, and adding in the new one with the last element of already merged intervals.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nAfter sorting, we can simply compare the new interval with the last interval in the result set, see if they have overlap.\n\n* Case 1: If the left endpoint of the new interval is greater than the right endpoint of the last interval of the result list, then just add the new interval directly.\n\nFor example:\nResult list:  (1, 6), (8, 12)\nNew interval: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(15, 19)\nNew result list: (1, 6), (8, 12), (15, 19)\n\n* Case 2: If the left endpoint of the new interval is not larger than the right endpoint of the last interval of the result list then only the right endpoint of the new interval and the right endpoint of last interval of the result list need to be determined.\n\nResult list: (1, 6), (8, 12), (15, 19)\nNew interval: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(17, 21)\nNew result list: (1, 6), (8, 12), (15, 21)\n\n``` Java\npublic int[][] merge(int[][] intervals) {\n    if (intervals.length == 0) {\n        return new int[0][0];\n    }\n\n    // result list\n    List<List<Integer>> listResults = new ArrayList<>();\n\n    // sort the input, use the left endpoint as key to sort\n    Arrays.sort(intervals, Comparator.comparingInt(o -> o[0]));\n\n    // add the first element\n    listResults.add(Arrays.stream(intervals[0]).boxed().collect(Collectors.toList()));\n    \n\n    for (int i = 1; i < intervals.length; i++) {\n        // get last element in the result list\n        Integer[] previous = listResults.get(listResults.size() - 1).toArray(new Integer[0]);\n\n        // check if overlap\n        if (isOverlap(previous, intervals[i])) {\n            // if overlap, update the last element of result list\n            listResults.get(listResults.size() - 1).set(0, Math.min(previous[0], intervals[i][0]));\n            listResults.get(listResults.size() - 1).set(1, Math.max(previous[1], intervals[i][1]));\n        } else {\n            // add new interval to the result set\n            listResults.add(Arrays.stream(intervals[i]).boxed().collect(Collectors.toList()));\n        }\n    }\n\n    // convert to 2d array\n    int[][] results = new int[listResults.size()][2];\n    for (int i = 0; i < listResults.size(); i++) {\n        results[i][0] = listResults.get(i).get(0);\n        results[i][1] = listResults.get(i).get(1);\n    }\n\n    return results;\n}\n\n// determine if 2 intervals overlap\nprivate boolean isOverlap(Integer[] a, int[] b) {\n    return !(a[1] < b[0]);\n}\n```","tags":["Leetcode - Array","Leetcode - Sort"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 55. Jump Game","url":"/Leetcode-55-Jump-Game/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nJump from the 0th index of the array, the distance of the jump is less than or equal to the corresponding number in the array. Determine if can reach the last index.\n\n### Similar Questions\n* Hard - [45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\n\n## Solution\nWe need to know from `i-th` position, what is the furthest position it can reach. If any of the element has a furthest position that can reach end, then return `true`. If reach is position that can't be reached from previous elements, then return `false`.\n\n``` Java\nif (nums.length == 1) {\n    return true;\n}\n\n// the furthest postion that can reach\nint furthest = 0;\n// index of current position\nint index = 0;\n\nwhile (index < nums.length) {\n    // the furthest postion can be reached from this index\n    furthest = Math.max(furthest, nums[index] + index);\n\n    index++;\n\n    // if this postion can't be reached\n    if (index > furthest) {\n        return false;\n    }\n\n    // can reach last index\n    if (furthest >= nums.length - 1) {\n        return true;\n    }\n}\n\nreturn true;\n```","tags":["Leetcode - Greedy","Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 54. Spiral Matrix","url":"/Leetcode-54-Spiral-Matrix/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGive a m * n matrix, return the spiral order of all elements.\n\n### Similar Questions\n* Medium - [59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/)\n* Medium - [885. Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/)\n\n## Solution\nStart at the first position and walk along the boundary. When reach the boundary, change direction and continue until complete all positions.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nThere is no magic here, just simulate the process.\n\n``` Java\npublic List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> results = new ArrayList<>();\n\n    if (matrix.length == 0) {\n        return results;\n    }\n\n    // current index of the position\n    int indexX = 0;\n    int indexY = 0;\n\n    // up, right, down, left\n    int[][] direction = new int[][]{\n            {0, -1},\n            {1, 0},\n            {0, 1},\n            {-1, 0}\n    };\n\n    // moving direction, start towards right\n    Towards towards = Towards.RIGHT;\n\n    // mark the position of boundary\n    int topBorder = -1;\n    int bottomBorder = matrix.length;\n    int leftBorder = -1;\n    int rightBorder = matrix[0].length;\n\n    while (true) {\n        // finished\n        if (results.size() == matrix.length * matrix[0].length) {\n            return results;\n        }\n\n        results.add(matrix[indexY][indexX]);\n\n        switch (towards) {\n            // move right\n            case RIGHT:\n                // reach the boundary\n                if (indexX + 1 == rightBorder) {\n                    // change direction\n                    towards = Towards.DOWN;\n                    // move the boundary\n                    topBorder++;\n\n                    // moving toward down\n                    indexY += direction[towards.ordinal()][1];\n                } else {\n                    indexX += direction[towards.ordinal()][0];\n                }\n\n                break;\n            // move down\n            case DOWN:\n                if (indexY + 1 == bottomBorder) {\n                    towards = Towards.LEFT;\n                    rightBorder--;\n\n                    indexX += direction[towards.ordinal()][0];\n                } else {\n                    indexY += direction[towards.ordinal()][1];\n                }\n\n                break;\n            // move left\n            case LEFT:\n                if (indexX - 1 == leftBorder) {\n                    towards = Towards.UP;\n                    bottomBorder--;\n\n                    indexY += direction[towards.ordinal()][1];\n                } else {\n                    indexX += direction[towards.ordinal()][0];\n                }\n                break;\n            // move up\n            case UP:\n                if (indexY - 1 == topBorder) {\n                    towards = Towards.RIGHT;\n                    leftBorder++;\n\n                    indexX += direction[towards.ordinal()][0];\n                } else {\n                    indexY += direction[towards.ordinal()][1];\n                }\n                break;\n        }\n    }\n}\n\nprivate enum Towards {\n    UP, RIGHT, DOWN, LEFT\n}\n```","tags":["Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 53. Maximum Subarray","url":"/Leetcode-53-Maximum-Subarray/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nFind a contiguous subarray in an array that has the largest sum.\n\n### Similar Questions\n* Easy - [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\n* Medium - [152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)\n* Easy - [697. Degree of an Array](https://leetcode.com/problems/degree-of-an-array/)\n* Medium - [978. Longest Turbulent Subarray](https://leetcode.com/problems/longest-turbulent-subarray/)\n\n## Solution\nDynamic programming can be used here to tackle this problem.\n\nWe can use a one-dimensional array `dp[i]` to represent the largest sum of subarray ending at index `i`. In other words, the last element of this sub-array is the index `i` element, and this subarray has the largest sum.\n\nWe have 2 situations here:\n* If `dp[i-1] < 0`, then `dp[i] = nums[i]` \n* If `dp[i-1] >= 0`, then `dp[i] = dp[i-1] + nums[i]`\n\nCode:\n``` Java\n// dp array\nint[] dp = new int[nums.length];\nint result = nums[0];\n\n// base condition\ndp[0] = nums[0];\n\nfor (int i = 1; i < nums.length; i++) {\n    //2 situations to update dp[i]\n    if (dp[i - 1] < 0) {\n        dp[i] = nums[i];\n    } else {\n        dp[i] = dp[i - 1] + nums[i];\n    }\n\n    // update result\n    result = Math.max(result, dp[i]);\n}\n\nreturn result;\n```\n\nTime complexity O(n), and space complexity O(n).\n\nNotice that we only used `dp[i-1]`, so the whole dp array isn't necessary here. Just need a variable to store the previous value.\n\n``` Java\nint previous = nums[0];\nint result = nums[0];\n\nfor (int i = 1; i < nums.length; i++) {\n    //2 situations to update dp[i]\n    if (previous < 0) {\n        previous = nums[i];\n    } else {\n        previous = previous + nums[i];\n    }\n\n    // update result\n    result = Math.max(result, previous);\n}\n\nreturn result;\n```\n\nThis way, time complexity is still O(n), but space complexity is optimized O(1).","tags":["Leetcode - Dynamic Programming","Leetcode - Array","Leetcode - Divde and Conquer"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 48. Rotate Image","url":"/Leetcode-48-Rotate-Image/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nRotate a 2D matrix by 90 degrees (clockwise). The rotation should be in-place (no extra space allocated).\n\n## Solution\nTo rotate 90 degrees clockwise, all we have to do is:\n1. Exchange by diagonal\n2. Exchange by center axis\n\nSee the graph for an illustration (image reference: [https://zhuanlan.zhihu.com/p/58965148](https://zhuanlan.zhihu.com/p/58965148))\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\n``` Java\npublic void rotate(int[][] matrix) {\n    int size = matrix.length;\n\n    // first rotate by diagonal\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            exchange(matrix, i, j);\n        }\n    }\n\n    // then exchange by mid\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size / 2; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[i][size - j - 1];\n            matrix[i][size - j - 1] = temp;\n        }\n    }\n}\n\n// exchange matrix[i][j] and matrix[j][i] in the matrix\nprivate void exchange(int[][] matrix, int i, int j) {\n    int temp = matrix[i][j];\n    matrix[i][j] = matrix[j][i];\n    matrix[j][i] = temp;\n}\n```","tags":["Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 40. Combination Sum II","url":"/Leetcode-40-Combination-Sum-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nSimilar to {% post_link Leetcode-39-Combination-Sum 'Question Leetcode 39. Combination Sum' %}. Only this time the same number in the array can be used <strong>once</strong>.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-39-Combination-Sum '39. Combination Sum' %}\n\n## Solution\nSolution referenced from here: [https://leetcode.com/problems/combination-sum-ii/discuss/16878/Combination-Sum-I-II-and-III-Java-solution-(see-the-similarities-yourself)](https://leetcode.com/problems/combination-sum-ii/discuss/16878/Combination-Sum-I-II-and-III-Java-solution-(see-the-similarities-yourself))\n\nThe whole algorithm works 99% same as {% post_link Leetcode-39-Combination-Sum '39. Combination Sum' %}. We only need to make sure that each number is only used once in the result. So how do we achieve that. We can sort the input array and skip the numner if it's same with previous number.\n\nCode:\n``` Java\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> results = new ArrayList<>();\n\n    // sort to remove duplicates\n    Arrays.sort(candidates);\n\n    backtrack(results, new ArrayList<>(), candidates, target, 0);\n\n    return results;\n}\n\nprivate static void backtrack(List<List<Integer>> results,\n                                List<Integer> tempList,\n                                int[] candidates,\n                                int remaining, \n                                int start) {\n    if (remaining < 0) {\n        return;\n    } else if (remaining == 0) {\n        results.add(new ArrayList<>(tempList));\n    } else {\n        for (int i = start; i < candidates.length; i++) {\n            // skip same number\n            if (i > start && candidates[i] == candidates[i - 1]) {\n                continue;\n            }\n\n            tempList.add(candidates[i]);\n\n            // start backtrack from i + 1, so we don't visit the same number\n            backtrack(results, tempList, candidates, remaining - candidates[i], i + 1);\n\n            // find solution or remaining < 0, backtrack one number in the list\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n```","tags":["Leetcode - Backtracking","Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 39. Combination Sum","url":"/Leetcode-39-Combination-Sum/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven an array and a target value, find all unique combination of numbers that add up to target. The same number in the array can be used multiple times.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-17-Letter-Combinations-of-a-Phone-Number '17. Letter Combinations of a Phone Number' %}\n* Medium - {% post_link Leetcode-40-Combination-Sum-II '40. Combination Sum II' %}\n* Medium - {% post_link Leetcode-77-Combinations '77. Combinations' %}\n* Medium - [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/)\n* Medium - [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/)\n\n## Solution\nThe solution to this question is a classical backtracking algorithm. I will have another post to talk about backtracking in a lot more details. For this particular question, what we need to do is:\n* Keep adding numbers to result set. Until:\n  * The sum equals the target \n  * Or the sum is greater than the target\n* Either way, we remove the last added number and continue adding next number\n\nFor example, if the input array is `[2, 3, 6, 7]` and target is `7`, the alroghtim runs as follows:\n* Add `2`. Result = `[2]`, Sum = `2`\n* Add `2`. Result = `[2, 2]`, Sum = `4`\n* Add `2`. Result = `[2, 2, 2]`, Sum = `6`\n* Add `2`. Result = `[2, 2, 2, 2]`, Sum = `8`. As Sum is greater than target, remove the last added number `2`, new result = `[2, 2, 2]`\n* Add `3`. Result = `[2, 2, 2, 3]`, Sum = `9`. As Sum is greater than target, remove the last added number `3`, new result = `[2, 2, 2]`\n* Add `6`. Result = `[2, 2, 2, 6]`, Sum = `12`. As Sum is greater than target, remove the last added number `6`, new result = `[2, 2, 2]`\n* Add `7`. Result = `[2, 2, 2, 7]`, Sum = `13`. As Sum is greater than target, remove the last added number `7`, new result = `[2, 2, 2]`\n* No more numbers left in the array, so further remove the last number in the result, get new result = `[2, 2]`\n* Add `3`. Result = `[2, 2, 3]`, Sum = `7`. As Sum equals to target, we add this result to the final list. And remove the last added number `3`, new result = `[2, 2]`\n* Add `6`. Result = `[2, 2, 6]`, Sum = `10`. As Sum is greater than target, remove the last added number `6`, new result = `[2, 2]`\n* Add `7`. Result = `[2, 2, 7]`, Sum = `11`. As Sum is greater than target, remove the last added number `7`, new result = `[2, 2]`\n* No more numbers left in the array, so further remove the last number in the result, get new result = `[2]`\n* Add `6`. Result = `[2, 6]`, Sum = `8`. As Sum is greater than target, remove the last added number `6`, new result = `[2]`\n* Add `7`. Result = `[2, 7]`, Sum = `9`. As Sum is greater than target, remove the last added number `7`, new result = `[2]`\n* No more numbers left in the array, so further remove the last number in the result, get new result = `[]`\n* Add `3`. Result = `[3]`, Sum = `3`\n* .....so on and so forth\n\n``` Java\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> results = new ArrayList<>();\n\n    backtrack(results, new ArrayList<>(), candidates, target, 0);\n\n    return results;\n}\n\nprivate static void backtrack(List<List<Integer>> results,\n                                List<Integer> tempList,\n                                int[] candidates,\n                                int remaining, \n                                int start) {\n    if (remaining < 0) {\n        return;\n    } else if (remaining == 0) {\n        results.add(new ArrayList<>(tempList));\n    } else {\n        for (int i = start; i < candidates.length; i++) {\n            tempList.add(candidates[i]);\n\n            backtrack(results, tempList, candidates, remaining - candidates[i], i);\n\n            // find solution or remaining < 0, backtrack one number in the list\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n```","tags":["Leetcode - Backtracking","Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 34. Find First and Last Position of Element in Sorted Array","url":"/Leetcode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nFind the first and last location of target value in a sorted array. Algorithm need to run in O(logn).\n\n### Similar Questions\n* Easy - [278. First Bad Version](https://leetcode.com/problems/first-bad-version/)\n\n## Solution 1 Linear Scan\nNote that the array is sort. So we can make use of that. First scan from left to right. Once target value is found, stop scanning and record the index. Then scan from right to left, and record the index of first occurance of target value.\n\nIf target value is not found when scanning from left to right, then we can directly return `[-1. -1]` as there is no target value in the array.\n\nThis algorithm is easy enough. However, time complexity is O(n), so it is not what we really want.\n\n## Solution 2 Binary Search\nSolution referenced from here: [https://leetcode.wang/leetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.html](https://leetcode.wang/leetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.html)\n\nAs we are targeting O(logn), binary search is a good candidate. \n\nIn a normal binary search, our algorith ends as soon as we find the target value. It may not be the leftmost target value. Like in the following case (pic taken from: ):\n\n{% asset_img sample1.png %}\n<br/>\n<br/>\n\nIn this case we need to keep looking for the leftmost target value. So once we found the target value, insted of return, we make `end = mid - 1` to keep searching. Eventually, the `start` will stop at the leftmost target value. \n\nWe can do the same to find the rightmost target value. The `end` will stop at the rightmost target value\n\nCode:\n``` Java\nint start = 0;\nint end = nums.length - 1;\n\n// array to record the result\nint[] result = new int[]{-1, -1};\n\nif (nums.length == 0) {\n    return result;\n}\n\n// first, try to find target, and keep search left part\n// when this loop exit, start must point to the leftmost target, or target not exist\nwhile (start <= end) {\n    int mid = (start + end) / 2;\n\n    // find target, keep search left\n    if (nums[mid] == target) {\n        end = mid - 1;\n    } else if (nums[mid] > target) {\n        end = mid - 1;\n    } else {\n        start = mid + 1;\n    }\n}\n\nif (start == nums.length || nums[start] != target) {\n    // didn't find target\n    return result;\n} else {\n    result[0] = start;\n}\n\n// search rightmost target\nstart = 0;\nend = nums.length - 1;\n\nwhile (start <= end) {\n    int mid = (start + end) / 2;\n\n    // find target, keep search right part\n    if (nums[mid] == target) {\n        start = mid + 1;\n    } else if (nums[mid] > target) {\n        end = mid - 1;\n    } else {\n        start = mid + 1;\n    }\n}\n\n// we already know that target exist\n// end will convergence to target\nresult[1] = end;\n\nreturn result;\n```\n\nTime complexity O(logn), and space complexity O(1).","tags":["Leetcode - Array","Leetcode - Binary Search"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 33. Search in Rotated Sorted Array","url":"/Leetcode-33-Search-in-Rotated-Sorted-Array/","content":"## Question\n{% asset_img question.png %}\n<br/>\n<br/>\nThe original array is sorted, but rotated at some pivot index. We need to find the target value in the rotated array in O(logn). As we are looking for an O(logn) solution, we need to make use of binary search.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-81-Search-in-Rotated-Sorted-Array-II '81. Search in Rotated Sorted Array II' %}\n* Medium - {% post_link Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array '153. Find Minimum in Rotated Sorted Array' %}\n\n## Solution\nObserve that for a given array, if we split it into half, at least one half is sorted. For example `[4 5 6 7 8 1 2 3]`, split from `7` and get `[4 5 6 7]` and `[8 1 2 3]`. The first half is sorted. \n\nBased on this observation, we can first find out which half is sorted (by comparing the end point values). Then check if target value is in this half. If it is, then discard the other half. If not, discard this half.\n\nCode:\n``` Java\nint start = 0;\nint end = nums.length - 1;\n\nwhile (start <= end) {\n    // get the mid point\n    int mid = (start + end) / 2;\n\n    // find the target!\n    if (target == nums[mid]) {\n        return mid;\n    }\n\n    // check which side is in order by comparing end points value\n    if (nums[start] <= nums[mid]) {\n        // left side is in order\n\n        // check if target in sorted half\n        // because this half is sorted, just check to see if target is in range\n        if (target >= nums[start] && target < nums[mid]) {\n            // in this case, target in left side\n            end = mid - 1;\n        } else {\n            // in this case, target in right side\n            start = mid + 1;\n        }\n    } else {\n        // right side is in order\n        if (target > nums[mid] && target <= nums[end]) {\n            start = mid + 1;\n        } else {\n            end = mid - 1;\n        }\n    }\n}\n\n// target no found\nreturn -1;\n```\n\nTime complexity O(logn), and space complexity O(1).","tags":["Leetcode - Array","Leetcode - Binary Search"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 31: Next Permutation","url":"/Leetcode-31-Next-Permutation/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nThis problem is a bit hard to understand. Suppose we have number 123, then the permutation has 132，213，231，312，321. Sort them in order gives us: **123** 132 213 231 312 321. So what we are looking for is `132`.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-46-Permutations '46. Permutations' %}\n* Medium - {% post_link Leetcode-47-Permutations-II '47. Permutations II' %}\n* Medium - {% post_link Leetcode-60-Permutation-Sequence '60. Permutation Sequence' %}\n\n## Solution\nSolution referenced from here: [31. Next Permutation](https://leetcode.com/articles/next-permutation/)\n\nIn normal cases, to make the number bigger, we need any digit to become larger. If we want to get a number that is just larger than the original one, we need to change the ones digit. For example, change 123 to 124.\n\nSince we are dealing with permutation, we can only exchange the digits.\n\nIf we start from the ones digit and proceed from right to left, find a larger one than the ones digit, and exchange them. The ones digit are exchanged to a higher position. After exchange the number become smaller because the ones digit is smaller. For example, number 132, we swap 2 and 3 and get 123, the ones digit become larger, but the overall number becomes smaller.\n\nSo ones digit is a no-go. Lets look at tens digti. If we exchange the first larger number that is left to the tens digit, the situation is the same. We will have a smaller number. For example, number 4123, we exchange 2 and 4, get 2143, smaller number!\n\nIf for a digit, we proceed from left to right, and exhange a number to the right that is larger. For 4123, we exchange 2 and 3, get 4132 which is larger. If for a certain digit (i.e tens digit), there is no digit to the right that is larger than it, then we move towards left until we get a number that has a digit to the right that is larger.\n\nAnother question is what if there are many digits to the right that are larger than it? In this case we want the one that is just larger to make sure the final number is as small as possible.\n\nAt this point we have a rough algorithm:\n1. Scan from right to left, find the digit that is smaller than it's right digit. We make the index of this digit `i`\n2. Scan from `i` to `end`, find the digit that is just larger than `i` digit. We make the index of this digit `j`\n3. Exhange `i` and `j`\n\nBut is it over? No. Although the number is larger, it may not be the next larger number. For example `158476531`, we start from tens digit `3`, no number to the right of `3` is larger than it. We move to `5`, `6`, `7`, the same. Until `4`. Then we look back from, and find `5` that is just larger than `4`. Exchange `5` and `4`, get `158576431`. We have a larger number, but it's not the one that is just larger. We need to reverse the digits that is right to `5` and get `158513467`, which is the just larger number.\n\nLook at the gif from [Leetcode](https://leetcode.com/problems/next-permutation/solution/) might help to understand to process:\n{% asset_img example.gif %}\n<br/>\n<br/>\nNow we have our algorithm:\n\n1. Scan from right to left, find the first digit that is smaller than it's right digit\n* index `i`\n* `num[i] < num[i+1]`\n2. Scan from `i` to `end`, find the element that is immediately bigger than `nums[i]`\n* index `j`\n* From `i` to `end`, the order is guaranteed to be descending\n3. Exchange `nums[i]` and `nums[j]`\n4. Reverse elements from `i + 1` to `end`\n\nCode:\n``` Java\npublic void nextPermutation(int[] nums) {\n    // start from tens digit\n    int firstSmallerIndex = nums.length - 2;\n\n    // find the first element that is smaller than it's right element\n    while (firstSmallerIndex >= 0 && nums[firstSmallerIndex + 1] <= nums[firstSmallerIndex]) {\n        firstSmallerIndex--;\n    }\n\n    // in this case all digit are in descending order (87654321), we just need to reverse all\n    if (firstSmallerIndex == -1) {\n        reverse(nums, 0);\n        return;\n    }\n\n    // from firstSmallerIndex to nums.length - 1, it's guaranteed to be in descending order\n    // find the index that is just bigger than firstSmallerIndex\n    int j = nums.length - 1;\n    while (j >= 0 && nums[j] <= nums[firstSmallerIndex]) {\n        j--;\n    }\n\n    // swap firstSmallerIndex and j\n    swap(nums, firstSmallerIndex, j);\n\n    // reverse elements to the right of firstSmallerIndex\n    reverse(nums, firstSmallerIndex + 1);\n}\n\n// helper method to swap 2 digits in the array\nprivate void swap(int[] nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}\n\n// helper method to reverse all elements starting from start, in the array\nprivate void reverse(int[] nums, int start) {\n    int i = start;\n    int j = nums.length - 1;\n\n    while (i <= j) {\n        swap(nums, i, j);\n        i++;\n        j--;\n    }\n}\n```\n\nTime Complexity: the wrost case is to scan all digit, so that is O(n). Space complexity: O(1)\n\nTo be honest, I think this question should be a `hard` level rather than a `medium`.","tags":["Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Java 8 Optional","url":"/Java-8-Optional/","content":"Java 8 introduced `Optional` class to avoid `NullPointerException`. Basically `Optional` class is a container to represent if an object exist or not. Use `Optional` make `null` value handling more elegant. See the example:\n\n``` Java\npublic String getUsername(User user) {\n    if(user == null)\n    {\n        return \"Unkown\";\n    }\n    \n    return user.getUsername();\n}\n```\n\nWith `Optional`:\n``` Java\npublic String getUsername(User user) {\n    return Optional.ofNullable(user).map(u -> u.getUsername()).orElse(\"Unkown\");\n}\n```\n\n## Create Optional object\nThere are 3 ways to create an `Optional` object:\n1. Create an `Optional` that has no value\n``` Java\nOptional<String> optional = Optional.empty();\n```\n\n2. Create an `Optional` that the object must not be null\n``` Java\nOptional<String> optional1 = Optional.of(\"optional object\");\n```\n\n3. Create an `Optional`. The object could be null. In this case the `Optional` has no value\n``` Java\nOptional<String> optional2 = Optional.ofNullable(null);\n```\n\n## get() Method\nIt is used to return the value of the wrapper object. But if the wrapper object value is null, a `NoSuchElementException` will be thrown.\n\n## isPresent() Method\nUsed to determined the if the object is not null. Using it is not a good behavior as the logic would be excatly the same if we do a null check. And we are introducing an extra step to wrap the object with `Optional`\n\n## ifPresent() Method\nThe `ifPresent()` accept a `Consumer Interface` as parameter. If the object is not null then the `Consumer Interface` will be called to perform a specific action.\n``` Java\nOptional<User> optionalUser = Optional.ofNullable(user);\n\n// if user exist then print the username\noptionalUser.ifPresent(user -> System.out.println(user.getUsername()));\n```\n\n## filter() Method\nThe `filter() `method accepts a `Predicate` interface, which is used to filter the `Optional` object. If the condition of `Predicate` is met, the `Optional` object itself is returned. Otherwise, an empty `Optional` object is returned.\n``` Java\nOptional.ofNullable(item).filter( i -> i.getPrice() > 100).ifPresent(i ->  System.out.println(\"The item cost over $100\"));\n```\n\n## map() Method\nThe `map()` method takes a `Function` object. It uses the `Function` to the `Optional` and wrap it into a new `Optional` object (the type of the wrapper object may change).\n``` Java\nOptional.ofNullable(user).map(u -> u.getUsername()); \n```\n\n## orElse() Method\nIf the `Optional` object is not null, then return it's value. Otherwise return the default value specified as the function parameter.\n``` Java\nOptional.ofNullable(user).map(u -> u.getUsername()).orElse(\"Unkown\");\n```\n\n## orElseGet() Method\nSimilar to `orElse()`, except that the parameter of the `orElseGet()` is a `Supplier` object. The return value of the `get()` of the `Supplier` object is used as the default value.\n``` Java\nOptional.ofNullable(user).map(u -> u.getUsername()).orElseGet(() -> \"Unkown\");  \n```\n\n## orElseThrow() Method\nSimilar to `orElseGet()`. The parameters are all `Supplier` objects, except that the `Supplier` object of `orElseThrow()` must return a `Throwable` exception. The `orElseThrow()` method is useful for scenarios where a specific exception needs to be thrown when the wrapped object value is null.\n``` Java\nOptional.ofNullable(user).map(u -> u.getUsername()).orElseThrow(() -> new RuntimeException(\"Unkown\"))\n```","tags":["Java 8 New Features"],"categories":["Java"]},{"title":"Leetcode 18: 4Sum","url":"/Leetcode-18-4Sum/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nSimilar to {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}. This time we want to find all 4 numbers that add up to the target  value.\n\n### Similar Questions\n* Easy - [1. Two Sum](https://leetcode.com/problems/two-sum/)\n* Medium - {% post_link Leetcode-15-3Sum '15: 3Sum' %}\n* Medium - [454. 4Sum II](https://leetcode.com/problems/4sum-ii/)\n\n## Soultion\nThe idea is excatly same with {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}. Just adding another layer of for loop.\n\n1. Sort the array\n2. First for loop to get the first number. (0 - num.length - 3)\n3. Use an If statement to avoid duplicate. (Skip the same number)\n4. Second for loop to get second number. (i + 1 to num.length - 2)\n5. Another If statement to avoid duplicate. (Skip the same number)\n6. Now we use 2 pointers `head` and `tail` to find remaining 2 numbers\n7. `sum = target - num[i] - num[j]`\n8. Depending on the comparison of sum and target:\n  8.1 sum = target: add to the result list, and move inward `head` and `tail` until all same number are skipped\n  8.2 sum < target: `head++`\n  8.3 sum > target: `tail--`\n\n``` Java\n        List<List<Integer>> results = new ArrayList<>();\n\n        Arrays.sort(nums);\n\n        // first for loop to get first number\n        for (int i = 0; i < nums.length; i++) {\n            // to avoid duplicate\n            if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n                // second for loop to get second number\n                for (int j = i + 1; j < nums.length; j++) {\n                    // to avoid duplicate\n                    if (j == i + 1 || (j > 0 && nums[j] != nums[j - 1])) {\n                        int low = j + 1;\n                        int high = nums.length - 1;\n\n                        int sum = target - nums[i] - nums[j];\n\n                        // find remaining 2 numbers\n                        while (low < high) {\n                            // find the results\n                            if (nums[low] + nums[high] == sum) {\n                                results.add(Arrays.asList(nums[i], nums[j], nums[low], nums[high]));\n\n                                low++;\n                                high--;\n\n                                // skip same number\n                                while (low < high && nums[low] == nums[low - 1]) {\n                                    low++;\n                                }\n\n                                // skip same number\n                                while (low < high && nums[high] == nums[high + 1]) {\n                                    high--;\n                                }\n                            } else if (nums[low] + nums[high] > sum) {\n                                high--;\n                            } else {\n                                low++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return results;\n```\n\nTime complexity O(n<sup>3</sup>), and space complexity O(1).","tags":["Leetcode - Array","Leetcode - Two Pointers","Leetcode - Hash Table"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 16: 3Sum Closest","url":"/Leetcode-16-3Sum-Closest/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nSimilar to {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}. This time we want to find the 3 sum that is closest to the target value.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-15-3Sum '15: 3Sum' %}\n\n## Solution 1\nBrute force. We need 3 nested loop to get all possible sums, and then get the sum that is closest to the target. Time  complexity is O(n<sup>3</sup>). Space complexity O(1).\n\n## Solution 2\nWe can make use of the similar idea of {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}.\n1. Sort the array\n2. Loop the array to get the first number `nums[i]`\n3. Use 2 pointers `head` and `tail` to loop the remaining array (`head = i + 1`)\n4. `sum = nums[i] + nums[head] + nums[tail]`\n5. Depending on the comparison of sum and target:\n  5.1 sum = target: then we can return the value as it as closest to the target\n  5.2 sum < target: `head++`\n  5.3 sum > target: `tail--`\n6. Use a variable to keep track of the smallest distance\n\nCode:\n``` Java\n    // keep trakc of minimun distance\n    int distance = Integer.MAX_VALUE;\n    int result = 0;\n\n    // sort the array\n    Arrays.sort(nums);\n\n    for (int i = 0; i < nums.length; i++) {\n        int low = i + 1;\n        int high = nums.length - 1;\n\n        // another loop with 2 pointers\n        while (low < high) {\n            int tempSum = nums[i] + nums[low] + nums[high];\n            if (tempSum == target) {\n                return tempSum;\n            } else if (tempSum > target) {\n                high--;\n            } else {\n                low++;\n            }\n\n            if (Math.abs(tempSum - target) < distance) {\n                distance = Math.abs(tempSum - target);\n                result = tempSum;\n            }\n        }\n    }\n\n    return result;\n```\n\nWe are running 2 loops (O(n<sup>2</sup>)), and space complexity O(1).","tags":["Leetcode - Array","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 15: 3Sum","url":"/Leetcode-15-3Sum/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven an array, find all unique triplets that add up to 0\n\n### Similar Questions\n* Easy - [1. Two Sum](https://leetcode.com/problems/two-sum/)\n* Medium - {% post_link Leetcode-16-3Sum-Closest '16: 3Sum Closest' %}\n* Medium - {% post_link Leetcode-18-4Sum '18: 4Sum' %}\n\n## Solution 1\nBrute force solution. We need 3 nested for loops. If we found that `nums[i] + nums[j] + nums[k] == target`, then need to check if the solution already exist (which takes O(n)). So the overall complexity is O(n<sup>3</sup>). Space complexity O(1).\n\n## Solution 2\nReference [https://leetcode.com/problems/3sum/discuss/7380/Concise-O(N2)](https://leetcode.com/problems/3sum/discuss/7380/Concise-O(N2)) as a O(n<sup>2</sup>) solution.\n\nThe main idea is to iterate through the array, fix one number as sum, and find another 2 numbers that add up to -sum. The clever thing is how to find the other two numbers in O(n).\n\nThe achieve that, first we need to sort the array.\n\nThen we get `num[i]` as target , and try to find if there are 2 element add up to `-num[i]`. As the array is sorted, we can use 2 pointers (low and high) at head and tail, so find 2 elements takes O(n).\n* `num[low] + num[high] > target`, high = high -1. As we are greater than target, we need to decrease the high pointer to make sum smaller.\n* `num[low] + num[high] < target`, low++. As we are smaller than target, we need to increase the low pointer to make sum larger.\n\nTo avoid add duplicate result, we need to move the pointer to point to different number with `num[low]` and `num[high]`. For example, let's say the array is `[-2, -1, 0, 0, 1, 1, 2, 3]`. The `num[i] = -2`. We found that `num[1] + num[5] + num[i] = 0`. To continue the loop, we need to move `high = 5` to `high = 3`. If we don't have this step, then when the loop continues, we will have `num[1] + num[4] + num[i] = 0` and this result is duplicate with the result we already have.\n\nCode:\n``` Java\nList<List<Integer>> results = new ArrayList<>();\n\n// sort the array\nArrays.sort(nums);\n\nfor (int i = 0; i < nums.length; i++) {\n    // skip the same number in array when we choose the number as sum target\n    if (i > 0 && nums[i] == nums[i - 1]) {\n        continue;\n    }\n\n    // start the loop to find remaining 2 numbers\n    int low = i + 1;\n    int high = nums.length - 1;\n\n    int target = -nums[i];\n\n    while (low < high) {\n        // find the 2 numbers\n        if (nums[low] + nums[high] == target) {\n            results.add(Arrays.asList(nums[low], nums[high], nums[i]));\n\n            low++;\n            high--;\n\n            // skip same number to avoid duplicate\n            while (low < high && nums[low] == nums[low - 1]) {\n                low++;\n            }\n\n            // skip same number to avoid duplicate\n            while (low < high && nums[high] == nums[high + 1]) {\n                high--;\n            }\n        } else if (nums[low] + nums[high] > target) {\n            high--;\n        } else {\n            low++;\n        }\n    }\n}\n\nreturn results;\n```\n","tags":["Leetcode - Array","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"How to deserialize Json content with unknown property when using Jackson","url":"/How-to-deserialize-Json-content-with-unknown-property-when-using-Jackson/","content":"When using Jackson to deserialize a Json string, if the Java object does't include all the fields in the Json, Jackson will complain about unknown properties. In this post I will show how to ignore the properties if it is not defined in our Java object.\n\nSuppose we have the following Json string:\n```\n{\n    \"name\": \"name1\", \n    \"studentId\": \"12345\",\n    \"major\": \"computer science\"\n}\n```\n\nAnd the Java object:\n``` Java\nclass Student {\n    String name;\n    int studentId;\n\n    // getters and setters\n}\n```\n\nWhen we map the Json to the Java object, will see the following exception:\n```\ncom.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: \nUnrecognized field \"major\" (class com.experiment.jackson.JacksonDeserialize$Student), \nnot marked as ignorable (2 known properties: \"name\", \"studentId\"])\n```\n\nThere are 2 ways to deal with this problem:\n1. Configure the ObjectMapper to ignore unknown properties\n``` Java\nObjectMapper mapper = new ObjectMapper();\nmapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n```\n\n2. Mark the Java object to ignore unknown field. This way we only specify to ignore unknown properties when deserialize this particular class.\n``` Java\n@JsonIgnoreProperties (ignoreUnknown = true)\nclass Student {\n    String name;\n    int studentId;\n    \n    // getters and setters\n}\n```","tags":["Jackson"],"categories":["Java"]},{"title":"Leetcode 11: Container With Most Water","url":"/Leetcode-11-Container-With-Most-Water/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nEach element of the array represents a height of a column. We want to pick 2 columns that can hold the most amount of water (shorter column height * distance between 2 columns).\n\n### Similar Questions\n* Hard - [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n\n## Solution 1\nThe most naive method is brute force. Check each pair of elements and calculate the result. Use a variable to store the largest one. We need 2 for loops, so the time complexity is O(n<sup>2</sup>). The good thing is that no extra space required. Thus space complexity is O(1).\n\n## Solution 2\nThe amount of water is determined by shorter column height and distance between 2 columns. If we start from maximun distance (in the following example, index 0 and 8). Then the height is column 0 as we are getting the shorter column height.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nIf we want to have a larger area, we can only reduce the distance and increase the height. So do we move the column 0 to column 1 ? Or column 8 to column 7? Of course, we will move the column that is shorter, so that the height might be increased.\n\nIn this example, if we change the column 8 to column 7, the distance is reduced, but the height is still unchanged (column 0 is still shorter), so the area will be reduced. But if we move column 0 to column 1, then column 8 becomes the shorter column and the area may increase.\n\nWhat if 2 columns have the same height? Well, in this case it doesn't matter which one we move. There will be 2 Circumstances.\n\n* There are 0 or 1 column between the 2 columns that is higher. Then the maximun area is when we choose these 2 same height column. As no matter how we move, the height is always less than these 2 columns, and distance is also smaller.\n* There are 2 or more columns between the 2 columns that is higher. These 2 columns will move to higher columns eventually, no matter which one moves first. \n\nSo the algorithm goes as follows:\n1. Have 2 pointers. one at start of array and one at the end of array.\n2. Each time move one pointer with smaller height inward\n3. Use a variable to record the area each time\n4. Loop until 2 pointers cross\n\nCode\n``` Java\nint result = 0;\nint left = 0;\nint right = height.length - 1;\n\nwhile (left < right) {\n    result = Math.max(result, (right - left) * Math.min(height[left], height[right]));\n\n    if (height[left] < height[right]) {\n        left++;\n    } else {\n        right--;\n    }\n}\n\nreturn result;\n```\n\nWe only loop the array once, so time complexity O(n). Space complexity O(1)","tags":["Leetcode - Array","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"How to force Github Pages rebuild","url":"/How-to-force-Github-Pages-rebuild/","content":"Github Pages has a nice feature that whenever you made a new commit, it will automatically build the page and publish the new changes. However, I ran into a strange situation that Github Pages didn't build my new commit. I could have just make another commit to trigger the build, but I'd rather have a nicer solution which can force Github Pages to build my site. After a bit of google search, turned out that Github provides an API to request a page build. Let's look at how to do this.\n\n## How to check the build status of Github Pages\nFirstly, let's look at how to check the build status of Github Pages. The easiest way is to check the commit history of your repository:\n{% asset_img commit.png %}\n<br/>\n<br/>\nIf the build fails due to some errors, then you will see something like this:\n{% asset_img commit-fail.png %}\n<br/>\n<br/>\nThen you should be able to check the error message by click on the red cross\n{% asset_img check.gif %}\n\n(GIF taken from [https://github.blog/2019-09-13-github-pages-builds-now-use-the-checks-api/](https://github.blog/2019-09-13-github-pages-builds-now-use-the-checks-api/))\n\n## Use Github API to force Github Pages rebuild site\nI found the solution here: [https://stackoverflow.com/questions/24098792/how-to-force-github-pages-build](https://stackoverflow.com/questions/24098792/how-to-force-github-pages-build)\n\n### Create a personal access token\nFollow the instructions here: [https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line](https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line)\n\nLog in Github account and navigate to: *Settings* -> *Developer settings* -> *Personal access tokens* -> *Generate new token*\n\nSelect *repo* scope\n{% asset_img repo.png %}\n\n### Call the Github API\nRun the script from command line or terminal:\n\n``` bash\ncurl -u username:token -X POST https://api.github.com/repos/username/reponame/pages/builds -H \"Accept: application/vnd.github.mister-fantastic-preview+json\"\n```\n\nReplace `username` with Github username\nReplace `token` with access token\nReplace `reponame` with repository name\n\nCheck detailed API documentation here: [https://developer.github.com/v3/repos/pages/#request-a-page-build](https://developer.github.com/v3/repos/pages/#request-a-page-build)\n\nYou should be able to see the result like this:\n{% asset_img result.png %}","categories":["how-to-guide"]},{"title":"Use Intellij to visualize debugging Stream operation","url":"/Use-Intellij-to-visualize-debugging-Stream-operation/","content":"Last time I talked about the stream API feature in Java 8. It is a very good new feature, but unlike previously looping code, single-step debugging does not work for stream API. Luckily, IntelliJ IDEA provides a tool for us to visualize the stream code.\n\nExample code:\n``` Java\nList<Integer> numbers2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\n\nnumbers2.stream()\n    .map(x -> x * x)\n    .filter(x -> x % 3 == 0)\n    .forEach(System.out::println);\n```\n\n<br/>\nAdd a break point at the last line of stream\n{% asset_img breakpoint.png %}\n<br/>\n<br/>\nStart debug, and find the button in debug interface\n{% asset_img button.png %}\n<br/>\n<br/>\nWait for a few seconds, you can see the results of each step of the stream operation\n{% asset_img result.png %}","tags":["Stream API","Intellij"],"categories":["Java"]},{"title":"Java 8 Streams Operations","url":"/Java-8-Streams-Operations/","content":"Stream operation is one of the main feature of Java 8. I have met these code a lot recently in the work. So I thought it would be good to write it up and summarize the key point of the knowledge.\n\n## Creation of stream\nThere are multiple different ways to create steams:\n\n### Stream.of()\n``` Java\nstatic <T> Stream<T> of(T... values)\n```\nExample:\n``` Java\nStream<String> stringStream = Stream.of(\"a\", \"b\", \"c\", \"d\");\n\nstringStream.forEach(System.out::println);\n\n// ============== Output：===============\n// a\n// b\n// c\n// d\n```\n\n### Stream.iterate()\n``` Java\nstatic <T> Stream<T> iterate(T seed, UnaryOperator<T> f)\n```\nCreate a stream start with a value, and iterate through by a certain operator.\n\nExample:\n``` Java\nStream.iterate(10, n -> n + 1)\n    .limit(5)\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// 10\n// 11\n// 12\n// 13\n// 14\n```\n\n### Stream.generate()\n``` Java\nstatic <T> Stream<T> generate(Supplier<T> s)\n```\nCreate a stream based on the value generate function. The generate function returns 1 value each time\n\nExample:\n``` Java\nStream.generate(Math::random)\n    .limit(5)\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// 0.09623470299238657\n// 0.8470095359492898\n// 0.20505426293183482\n// 0.8112754654328852\n// 0.009673283068063365\n```\n\n### Create a stream from an existing collection\n``` Java\nList<String> strings = Arrays.asList(\"hello\", \"world\", \"Java8\");\n\nstrings.stream().forEach(System.out::println);\n\n// ============== Output：===============\n// hello\n// world\n// Java8\n```\n\n## Stream operation\nNow we know how to create stream, let's look at what operations can be applied to stream\n\n### Filter and slice\n#### filter()\nThe filter method accepts a function that returns a boolean as a parameter, and returns a stream containing all the elements that match the condition. \n\nFor example, you can select all words starting with the letter w and print them like this:\n\n``` Java\nList<String> words = Arrays.asList(\"random\", \"hello\", \"wow\", \"world\", \"java\");\n\nwords.stream()\n    .filter(word -> word.startsWith(\"w\"))\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// wow\n// world\n```\n\nOr you can get the list that match those condition like this:\n``` Java\nList<String> words = Arrays.asList(\"random\", \"hello\", \"wow\", \"world\", \"java\");\n\nList<String> filtered = words.stream()\n    .filter(word -> word.startsWith(\"w\"))\n    .collect(Collectors.toList());\n```\n\n#### distince()\nThe distinct method will return a stream of elements that are unique. \n\nFor example, the following code returns the list that has no duplicates:\n``` Java\nList<Integer> numbers = Arrays.asList(1, 2, 1, 3, 2, 1, 3, 4);\n\nnumbers.stream()\n    .distinct()\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// 1\n// 2\n// 3\n// 4\n```\n\n#### skip()\nThe skip(n) method returns a stream that throws away the first n elements. If there are fewer than n elements in the stream, an empty stream is returned.\n\n### Mapping\nA very common data processing method is to select information from certain objects. For example, in SQL, you can select a column from the table, and the Stream API also provides similar tools through the `map` and `flatMap` methods.\n\n#### map()\nBefore Java8, we  need to take out one field of a collection object and then save it to another collection. With stream map, we can simply use map function to map out the field we want, then use collect them to new collection\n\n``` Java\npublic static void main(String[] args) {\n    List<Person> persons = Arrays.asList(new Person(20, \"Nick Li\"),\n        new Person(30, \"Mike\"), new Person(40, \"Peter\"));\n\n    persons.stream()\n        .map(Person::getAge)\n        .forEach(System.out::println);\n}\n\n// ============== Output：===============\n// 20\n// 30\n// 40\n\nprivate static class Person {\n    private int age;\n    private String name;\n\n    public int getAge() {\n        return age;\n    }\n\n    // skip constructor and other set, get methods\n}\n```\n\n#### flatMap()\nIf we want to know how many unique character in a list of words,  what should we do?\n\n``` Java\nList<String> words = Arrays.asList(\"Hello\", \"World\");\n\nwords.stream()\n    .map(s -> s.split(\"\"))\n    .distinct()\n    .collect(Collectors.toList())\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// [Ljava.lang.String;@312b1dae\n// [Ljava.lang.String;@7530d0a\n```\n\nThis is wrong because the map function returns a `String[]`. So we get a `Stream<String[]>` instead of `Stream<String>`. To solve this problem, we can use flatMap:\n``` Java\nList<String> words = Arrays.asList(\"Hello\", \"World\");\n\nwords.stream()\n     .map(s -> s.split(\"\"))\n     .flatMap(Arrays::stream)\n     .distinct()\n     .forEach(System.out::println);\n\n// ============== Output：===============\n// H\n// e\n// l\n// o\n// W\n// r\n// d\n```\n\nThe effect of using flatMap method is that each array is not mapped to a stream, but to the contents of the stream. In a nutshell, flatMap lets you convert each value in a stream to another stream, then join all the streams into one stream.\n\n### Find and match\nAnother common data processing method is to see if certain elements in the dataset match a given condition. The Stream API provides such tools through `allMatch`, `anyMatch`, `noneMatch`, `findFirst`, and `findAny` methods.\n\nThe function name is very self-explanatory. Let see some examples\n\nTo check if a collection contains even numbers:\n``` Java\nList<Integer> numbers = Arrays.asList(1, 2, 3);\n\nif (numbers.stream().anyMatch(x -> x % 2 == 0)) {\n    System.out.println(\"Yes\");\n} else {\n    System.out.println(\"No\");\n}\n\n// ============== Output：===============\n// Yes\n```\n\nTo find the first number in the list that it's square can be divided by 3\n``` Java\nList<Integer> numbers2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\n\nOptional<Integer> goodNumber = numbers2.stream()\n    .map(x -> x * x)\n    .filter(x -> x % 3 == 0)\n    .findFirst();\n\nSystem.out.println(goodNumber.get()); \n\n// ============== Output：===============\n// 9\n```\n\n### Reduce\nWe might need to complete more complext task, such as “Choose the longest word in a word” or “Calculate the total length of all words”. Such queries need to repeatedly combine the elements in the stream to get the final value. Such a query can be classified as a reduction operation (reducing the stream to a value).\n\nTo calculate the sum of an array:\n``` Java\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\nint sum = numbers.stream().reduce(0, (a, b) -> a + b);\n        \n// ============== Output：===============\n// 15\n```\n\nReduce returns the result every time and operates the result with the next element, such as the first time when traversing to element 1, returning the initial value 0 + 1 = 1, then using the return value of 1 and the second element 2, and so on, until the summation of the list of numbers is completed.\n\n### Intermediate and terminal operation\nAll operations on the Stream API fall into two categories: intermediate operations and terminal operations. The intermediate operation is just a kind of markup, and only the terminal operation will trigger the actual calculation.\n\n**Intermediate operations** can be divided into *stateless* and *stateful*. *Stateless* intermediate operations mean that the processing of elements is not affected by the previous elements, and *stateful* intermediate operations must wait until all elements are processed. For example, sorting is a stateful operation, and the sorting result cannot be determined until all elements are read.\n\n**The terminal operation** can be divided into *short-circuit* operation and *non-short-circuit* operation. The short-circuit operation means that the result can be returned without processing all the elements, such as finding the first element that satisfies the condition.\n\nA stream pipeline consists of a stream source, followed by zero or more intermediate operations, and a terminal operation.\n\n## To summarize the Stream API:\nA stream pipeline consists of a stream source, followed by zero or more intermediate operations, and a terminal operation.\n\n<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg .tg-axxb{font-weight:bold;background-color:#c0c0c0;color:#000000;border-color:inherit;text-align:center;vertical-align:top}\n.tg .tg-n9g5{background-color:#ffffff;color:#000000;border-color:inherit;text-align:left;vertical-align:middle}\n.tg .tg-x5q1{background-color:#ffffff;color:#000000;border-color:inherit;text-align:center;vertical-align:middle}\n.tg .tg-mq6t{background-color:#ffffff;color:#000000;border-color:inherit;text-align:left;vertical-align:middle}\n</style>\n<table class=\"tg\">\n  <tr>\n    <th class=\"tg-axxb\" colspan=\"4\">Stream API</th>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"11\">Intermediate<br>Operation</td>\n    <td class=\"tg-x5q1\" rowspan=\"7\">Stateless</td>\n    <td class=\"tg-n9g5\">unordered()<br></td>\n    <td class=\"tg-n9g5\">If order doesn't matter, then can use unordered() together with parallel() to speed up</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">filter()</td>\n    <td class=\"tg-n9g5\">Filter out elements in the stream based on a filter function</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">map()</td>\n    <td class=\"tg-n9g5\">Map stream to another stream based on a map function</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">mapToInt()<br>mapToLong()<br>mapToDouble()</td>\n    <td class=\"tg-mq6t\">Map to int, long or double</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">flatMap()</td>\n    <td class=\"tg-n9g5\">Make [[\"ABC\", \"DEF\"], [\"FGH\", \"IJK\"]] into [\"ABC\", \"DEF\", \"FGH\", \"IJK\"]：</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">flatMapToInt()<br>flatMapToLong()<br>flatMapToDouble()</td>\n    <td class=\"tg-mq6t\">Similar to mapToInt(), mapToLong(), mapToDouble()</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">peek()</td>\n    <td class=\"tg-n9g5\">Performs specified operation on each element of the stream and returns a new stream which can be used further.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"4\">Stateful</td>\n    <td class=\"tg-n9g5\">distinct()</td>\n    <td class=\"tg-n9g5\">Filter out duplicate element in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">sorted()</td>\n    <td class=\"tg-n9g5\">Sort the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">limit()</td>\n    <td class=\"tg-n9g5\">Limit the number of elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">skip()</td>\n    <td class=\"tg-n9g5\">Skip certain number of elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"13\">Terminal<br>Operation</td>\n    <td class=\"tg-x5q1\" rowspan=\"5\">short-circuit<br></td>\n    <td class=\"tg-n9g5\">anyMatch()</td>\n    <td class=\"tg-n9g5\">Return if any element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">allMatch()</td>\n    <td class=\"tg-n9g5\">Return if all element in the stream that satisfies the condition </td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">noneMatch()</td>\n    <td class=\"tg-n9g5\">Return if no element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">findFirst()</td>\n    <td class=\"tg-n9g5\">Find first element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">findAny()</td>\n    <td class=\"tg-n9g5\">Find any element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"8\">non-short-circuit</td>\n    <td class=\"tg-n9g5\">forEach()</td>\n    <td class=\"tg-n9g5\">Iterate all elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">forEachOrdered()</td>\n    <td class=\"tg-n9g5\">Iterate all elements in the stream by order. Can't make use of parallel()</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">toArray()</td>\n    <td class=\"tg-n9g5\">Return an array of all elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">reduce()</td>\n    <td class=\"tg-n9g5\">Reduce all elements to one results based on given function</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">collect()</td>\n    <td class=\"tg-n9g5\">Process the elements in the stream and get all values</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">max()</td>\n    <td class=\"tg-n9g5\">Find max element in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">min()</td>\n    <td class=\"tg-n9g5\">Find min element in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">count()</td>\n    <td class=\"tg-n9g5\">Get number of element in the stream</td>\n  </tr>\n</table>","tags":["Java 8 New Features","Stream API"],"categories":["Java"]},{"title":"How to deploy Hexo blog to Github pages","url":"/How-to-deploy-Hexo-blog-to-Github-pages/","content":"\nHexo provides fast and easy one-click deployment, supporting [Github Pages](https://pages.github.com), [Netlify](https://www.netlify.com), [OpenShift](https://www.openshift.com) etc. In this post, I will walk through the process of deploying Hexo blog site to [Github Pages](https://pages.github.com).\n\n## Folder structure of Hexo \nBefore discussing the process, I think it is important to understand the folder structure of Hexo. Basically, a Hexo blog site contains the following folders:\n\n* **scaffolds:** Template folder. When you create a new post, Hexo will create a \".md\" file under `source` based on scaffold.\n* **source:** The Resource folder. It is where the user resources are stored. It stores all \".md\" files which would be rendered to html pages.\n* **themes:** Stores all theme files.\n* **public** This is where all rendered files comes in. When deploying, we need this folder to get to the Github repository so that Github pages can host it.\n\nNow let's look at how to deploy the blog site to Github Pages.\n\n## Install hexo-deployer-git\n``` bash\nnpm install hexo-deployer-git --save\n```\n\n## Setup Github repository\nLogin GitHub account and create a new repository named username.github.io, where username is the username on GitHub.\n \n * Note that the first part of the repository must exactly match the username, otherwise it won’t work.\n\nRefer to [https://pages.github.com](https://pages.github.com) for more details.\n\n## Change config file\nAdd the following lines to `_config.yml`:\n\n```\ndeploy:\n  type:    git\n  repo:    <repository url> #e.g. https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io\n  branch:  [branch]         #branch name, default is 'master'\n  message: [message]        #commit message, default is 'Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}'\n```\n\n## Generate site files and push to remote repository\n``` bash\nhexo clean\nhexo deploy\n```\n\nWait for a couple of minutes, then visit username.github.io, the blog site should be visiable!\n\n## How does it works\nWhen hexo deploy is executed, Hexo pushes the files and directories in the `public` folder to the remote repositories and branches specified in `_config.yml` and completely overwrites the existing content under that branch.","tags":["hexo"],"categories":["how-to-guide"]},{"title":"How to build a blog with hexo","url":"/How-to-build-a-blog-with-hexo/","content":"\nHexo is a blog framework powered by Node.js. I recently built my blog with it and found it extremely easy and fast. The posts are written in Markdown and Hexo will generates static files in seconds. \n\nIn this post I will walk through the steps to setup a blog running locally. There will be another post discussing deploy the blog site to Github page. Here I will only discuss how to install Hexo blog on MacOS. For installation on other platforms such as Windows, please refer to other online posts like [https://www.how2shout.com/how-to/install-hexo-nodejs-blog-on-windows-10-with-github.html](https://www.how2shout.com/how-to/install-hexo-nodejs-blog-on-windows-10-with-github.html)\n\n## Requirems to install Hexo\n* [Node.js](https://nodejs.org/en/)\n* [Git](https://git-scm.com)\n\n## Install Node.js\nRun this script in the terminal:\n``` bash\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | sh\n```\n\nEdit zsh config to load nvm each time:\n\n``` bash\nvi ~/.zshrc\n```\n\nAdd: `[[ -s $HOME/.nvm/nvm.sh ]] && . $HOME/.nvm/nvm.sh` to the end of the file\n\nThen run the command to install node.js\n``` bash\nnvm install node\n```\n\nAfter the script finishes running, you should see the following output, which means node.js is all set. Great!\n\n{% asset_img node-success.png %}\n\n## Install Git\nNext is install Git so you can checkout code from source repositry. On Mac the easiest way is to use [HomeBrew](https://brew.sh). You can install Brew with one line of command:\n\n``` bash\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\nAfter Brew is installed, use it to install Git:\n\n``` bash\nBrew install git\n```\n\n## Install Hexo\nWith Node.js and Git all set, you can install Hexo run the following  command\n\n``` bash\nnpm install -g hexo-cli\n```\n\n## Create a blog site\nNow it comes to the moment when you are able to create the blog site. Simply run:\n\n``` bash\nhexo init my-blog\ncd my-blog\nhexo install\n```\n\nHexo will download and create all necessary files to 'my-blog' folder. \n\n## Run the Hexo server\nEverything is ready and you can run the Hexo server to view your blog site!\n\n``` bash\nhexo server\n```\n\nVisit [http://localhost:4000](http://localhost:4000) and you should be able to see the webpage show up\n\n{% asset_img blog-page.png %}\n\n\nCongraturations! You have a blog site up and running. You can create a post using `hexo new post \"Blog title\"`. You can also change the themes and add plugins to the site.","tags":["hexo"],"categories":["how-to-guide"]}]
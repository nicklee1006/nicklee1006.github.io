[{"title":"Leetcode 55. Jump Game","url":"/Leetcode-55-Jump-Game/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nJump from the 0th index of the array, the distance of the jump is less than or equal to the corresponding number in the array. Determine if can reach the last index.\n\n### Similar Questions\n* Hard - [45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\n\n## Solution\nWe need to know from `i-th` position, what is the furthest position it can reach. If any of the element has a furthest position that can reach end, then return `true`. If reach is position that can't be reached from previous elements, then return `false`.\n\n``` Java\nif (nums.length == 1) {\n    return true;\n}\n\n// the furthest postion that can reach\nint furthest = 0;\n// index of current position\nint index = 0;\n\nwhile (index < nums.length) {\n    // the furthest postion can be reached from this index\n    furthest = Math.max(furthest, nums[index] + index);\n\n    index++;\n\n    // if this postion can't be reached\n    if (index > furthest) {\n        return false;\n    }\n\n    // can reach last index\n    if (furthest >= nums.length - 1) {\n        return true;\n    }\n}\n\nreturn true;\n```","tags":["Leetcode - Array","Leetcode - Greedy"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 54. Spiral Matrix","url":"/Leetcode-54-Spiral-Matrix/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGive a m * n matrix, return the spiral order of all elements.\n\n### Similar Questions\n* Medium - [59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/)\n* Medium - [885. Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/)\n\n## Solution\nStart at the first position and walk along the boundary. When reach the boundary, change direction and continue until complete all positions.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nThere is no magic here, just simulate the process.\n\n``` Java\npublic List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> results = new ArrayList<>();\n\n    if (matrix.length == 0) {\n        return results;\n    }\n\n    // current index of the position\n    int indexX = 0;\n    int indexY = 0;\n\n    // up, right, down, left\n    int[][] direction = new int[][]{\n            {0, -1},\n            {1, 0},\n            {0, 1},\n            {-1, 0}\n    };\n\n    // moving direction, start towards right\n    Towards towards = Towards.RIGHT;\n\n    // mark the position of boundary\n    int topBorder = -1;\n    int bottomBorder = matrix.length;\n    int leftBorder = -1;\n    int rightBorder = matrix[0].length;\n\n    while (true) {\n        // finished\n        if (results.size() == matrix.length * matrix[0].length) {\n            return results;\n        }\n\n        results.add(matrix[indexY][indexX]);\n\n        switch (towards) {\n            // move right\n            case RIGHT:\n                // reach the boundary\n                if (indexX + 1 == rightBorder) {\n                    // change direction\n                    towards = Towards.DOWN;\n                    // move the boundary\n                    topBorder++;\n\n                    // moving toward down\n                    indexY += direction[towards.ordinal()][1];\n                } else {\n                    indexX += direction[towards.ordinal()][0];\n                }\n\n                break;\n            // move down\n            case DOWN:\n                if (indexY + 1 == bottomBorder) {\n                    towards = Towards.LEFT;\n                    rightBorder--;\n\n                    indexX += direction[towards.ordinal()][0];\n                } else {\n                    indexY += direction[towards.ordinal()][1];\n                }\n\n                break;\n            // move left\n            case LEFT:\n                if (indexX - 1 == leftBorder) {\n                    towards = Towards.UP;\n                    bottomBorder--;\n\n                    indexY += direction[towards.ordinal()][1];\n                } else {\n                    indexX += direction[towards.ordinal()][0];\n                }\n                break;\n            // move up\n            case UP:\n                if (indexY - 1 == topBorder) {\n                    towards = Towards.RIGHT;\n                    leftBorder++;\n\n                    indexX += direction[towards.ordinal()][0];\n                } else {\n                    indexY += direction[towards.ordinal()][1];\n                }\n                break;\n        }\n    }\n}\n\nprivate enum Towards {\n    UP, RIGHT, DOWN, LEFT\n}\n```","tags":["Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 53. Maximum Subarray","url":"/Leetcode-53-Maximum-Subarray/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nFind a contiguous subarray in an array that has the largest sum.\n\n### Similar Questions\n* Easy - [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\n* Medium - [152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)\n* Easy - [697. Degree of an Array](https://leetcode.com/problems/degree-of-an-array/)\n* Medium - [978. Longest Turbulent Subarray](https://leetcode.com/problems/longest-turbulent-subarray/)\n\n## Solution\nDynamic programming can be used here to tackle this problem.\n\nWe can use a one-dimensional array `dp[i]` to represent the largest sum of subarray ending at index `i`. In other words, the last element of this sub-array is the index `i` element, and this subarray has the largest sum.\n\nWe have 2 situations here:\n* If `dp[i-1] < 0`, then `dp[i] = nums[i]` \n* If `dp[i-1] >= 0`, then `dp[i] = dp[i-1] + nums[i]`\n\nCode:\n``` Java\n// dp array\nint[] dp = new int[nums.length];\nint result = nums[0];\n\n// base condition\ndp[0] = nums[0];\n\nfor (int i = 1; i < nums.length; i++) {\n    //2 situations to update dp[i]\n    if (dp[i - 1] < 0) {\n        dp[i] = nums[i];\n    } else {\n        dp[i] = dp[i - 1] + nums[i];\n    }\n\n    // update result\n    result = Math.max(result, dp[i]);\n}\n\nreturn result;\n```\n\nTime complexity O(n), and space complexity O(n).\n\nNotice that we only used `dp[i-1]`, so the whole dp array isn't necessary here. Just need a variable to store the previous value.\n\n``` Java\nint previous = nums[0];\nint result = nums[0];\n\nfor (int i = 1; i < nums.length; i++) {\n    //2 situations to update dp[i]\n    if (previous < 0) {\n        previous = nums[i];\n    } else {\n        previous = previous + nums[i];\n    }\n\n    // update result\n    result = Math.max(result, previous);\n}\n\nreturn result;\n```\n\nThis way, time complexity is still O(n), but space complexity is optimized O(1).","tags":["Leetcode - Array","Leetcode - Divde and Conquer","Leetcode - Dynamic Programming"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 48. Rotate Image","url":"/Leetcode-48-Rotate-Image/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nRotate a 2D matrix by 90 degrees (clockwise). The rotation should be in-place (no extra space allocated).\n\n## Solution\nTo rotate 90 degrees clockwise, all we have to do is:\n1. Exchange by diagonal\n2. Exchange by center axis\n\nSee the graph for an illustration (image reference: [https://zhuanlan.zhihu.com/p/58965148](https://zhuanlan.zhihu.com/p/58965148))\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\n``` Java\npublic void rotate(int[][] matrix) {\n    int size = matrix.length;\n\n    // first rotate by diagonal\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            exchange(matrix, i, j);\n        }\n    }\n\n    // then exchange by mid\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size / 2; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[i][size - j - 1];\n            matrix[i][size - j - 1] = temp;\n        }\n    }\n}\n\n// exchange matrix[i][j] and matrix[j][i] in the matrix\nprivate void exchange(int[][] matrix, int i, int j) {\n    int temp = matrix[i][j];\n    matrix[i][j] = matrix[j][i];\n    matrix[j][i] = temp;\n}\n```","tags":["Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 40. Combination Sum II","url":"/Leetcode-40-Combination-Sum-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nSimilar to {% post_link Leetcode-39-Combination-Sum 'Question Leetcode 39. Combination Sum' %}. Only this time the same number in the array can be used <strong>once</strong>.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-39-Combination-Sum '39. Combination Sum' %}\n\n## Solution\nSolution referenced from here: [https://leetcode.com/problems/combination-sum-ii/discuss/16878/Combination-Sum-I-II-and-III-Java-solution-(see-the-similarities-yourself)](https://leetcode.com/problems/combination-sum-ii/discuss/16878/Combination-Sum-I-II-and-III-Java-solution-(see-the-similarities-yourself))\n\nThe whole algorithm works 99% same as {% post_link Leetcode-39-Combination-Sum '39. Combination Sum' %}. We only need to make sure that each number is only used once in the result. So how do we achieve that. We can sort the input array and skip the numner if it's same with previous number.\n\nCode:\n``` Java\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> results = new ArrayList<>();\n\n    // sort to remove duplicates\n    Arrays.sort(candidates);\n\n    backtrack(results, new ArrayList<>(), candidates, target, 0);\n\n    return results;\n}\n\nprivate static void backtrack(List<List<Integer>> results,\n                                List<Integer> tempList,\n                                int[] candidates,\n                                int remaining, \n                                int start) {\n    if (remaining < 0) {\n        return;\n    } else if (remaining == 0) {\n        results.add(new ArrayList<>(tempList));\n    } else {\n        for (int i = start; i < candidates.length; i++) {\n            // skip same number\n            if (i > start && candidates[i] == candidates[i - 1]) {\n                continue;\n            }\n\n            tempList.add(candidates[i]);\n\n            // start backtrack from i + 1, so we don't visit the same number\n            backtrack(results, tempList, candidates, remaining - candidates[i], i + 1);\n\n            // find solution or remaining < 0, backtrack one number in the list\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n```","tags":["Leetcode - Array","Leetcode - Backtracking"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 39. Combination Sum","url":"/Leetcode-39-Combination-Sum/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven an array and a target value, find all unique combination of numbers that add up to target. The same number in the array can be used multiple times.\n\n### Similar Questions\n* Medium - [17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)\n* Medium - [40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)\n* Medium - [77. Combinations](https://leetcode.com/problems/combinations/)\n* Medium - [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/)\n* Medium - [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/)\n\n## Solution\nThe solution to this question is a classical backtracking algorithm. I will have another post to talk about backtracking in a lot more details. For this particular question, what we need to do is:\n* Keep adding numbers to result set. Until:\n  * The sum equals the target \n  * Or the sum is greater than the target\n* Either way, we remove the last added number and continue adding next number\n\nFor example, if the input array is `[2, 3, 6, 7]` and target is `7`, the alroghtim runs as follows:\n* Add `2`. Result = `[2]`, Sum = `2`\n* Add `2`. Result = `[2, 2]`, Sum = `4`\n* Add `2`. Result = `[2, 2, 2]`, Sum = `6`\n* Add `2`. Result = `[2, 2, 2, 2]`, Sum = `8`. As Sum is greater than target, remove the last added number `2`, new result = `[2, 2, 2]`\n* Add `3`. Result = `[2, 2, 2, 3]`, Sum = `9`. As Sum is greater than target, remove the last added number `3`, new result = `[2, 2, 2]`\n* Add `6`. Result = `[2, 2, 2, 6]`, Sum = `12`. As Sum is greater than target, remove the last added number `6`, new result = `[2, 2, 2]`\n* Add `7`. Result = `[2, 2, 2, 7]`, Sum = `13`. As Sum is greater than target, remove the last added number `7`, new result = `[2, 2, 2]`\n* No more numbers left in the array, so further remove the last number in the result, get new result = `[2, 2]`\n* Add `3`. Result = `[2, 2, 3]`, Sum = `7`. As Sum equals to target, we add this result to the final list. And remove the last added number `3`, new result = `[2, 2]`\n* Add `6`. Result = `[2, 2, 6]`, Sum = `10`. As Sum is greater than target, remove the last added number `6`, new result = `[2, 2]`\n* Add `7`. Result = `[2, 2, 7]`, Sum = `11`. As Sum is greater than target, remove the last added number `7`, new result = `[2, 2]`\n* No more numbers left in the array, so further remove the last number in the result, get new result = `[2]`\n* Add `6`. Result = `[2, 6]`, Sum = `8`. As Sum is greater than target, remove the last added number `6`, new result = `[2]`\n* Add `7`. Result = `[2, 7]`, Sum = `9`. As Sum is greater than target, remove the last added number `7`, new result = `[2]`\n* No more numbers left in the array, so further remove the last number in the result, get new result = `[]`\n* Add `3`. Result = `[3]`, Sum = `3`\n* .....so on and so forth\n\n``` Java\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> results = new ArrayList<>();\n\n    backtrack(results, new ArrayList<>(), candidates, target, 0);\n\n    return results;\n}\n\nprivate static void backtrack(List<List<Integer>> results,\n                                List<Integer> tempList,\n                                int[] candidates,\n                                int remaining, \n                                int start) {\n    if (remaining < 0) {\n        return;\n    } else if (remaining == 0) {\n        results.add(new ArrayList<>(tempList));\n    } else {\n        for (int i = start; i < candidates.length; i++) {\n            tempList.add(candidates[i]);\n\n            backtrack(results, tempList, candidates, remaining - candidates[i], i);\n\n            // find solution or remaining < 0, backtrack one number in the list\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n```","tags":["Leetcode - Array","Leetcode - Backtracking"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 34. Find First and Last Position of Element in Sorted Array","url":"/Leetcode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nFind the first and last location of target value in a sorted array. Algorithm need to run in O(logn).\n\n### Similar Questions\n* Easy - [278. First Bad Version](https://leetcode.com/problems/first-bad-version/)\n\n## Solution 1 Linear Scan\nNote that the array is sort. So we can make use of that. First scan from left to right. Once target value is found, stop scanning and record the index. Then scan from right to left, and record the index of first occurance of target value.\n\nIf target value is not found when scanning from left to right, then we can directly return `[-1. -1]` as there is no target value in the array.\n\nThis algorithm is easy enough. However, time complexity is O(n), so it is not what we really want.\n\n## Solution 2 Binary Search\nSolution referenced from here: [https://leetcode.wang/leetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.html](https://leetcode.wang/leetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.html)\n\nAs we are targeting O(logn), binary search is a good candidate. \n\nIn a normal binary search, our algorith ends as soon as we find the target value. It may not be the leftmost target value. Like in the following case (pic taken from: ):\n\n{% asset_img sample1.png %}\n<br/>\n<br/>\n\nIn this case we need to keep looking for the leftmost target value. So once we found the target value, insted of return, we make `end = mid - 1` to keep searching. Eventually, the `start` will stop at the leftmost target value. \n\nWe can do the same to find the rightmost target value. The `end` will stop at the rightmost target value\n\nCode:\n``` Java\nint start = 0;\nint end = nums.length - 1;\n\n// array to record the result\nint[] result = new int[]{-1, -1};\n\nif (nums.length == 0) {\n    return result;\n}\n\n// first, try to find target, and keep search left part\n// when this loop exit, start must point to the leftmost target, or target not exist\nwhile (start <= end) {\n    int mid = (start + end) / 2;\n\n    // find target, keep search left\n    if (nums[mid] == target) {\n        end = mid - 1;\n    } else if (nums[mid] > target) {\n        end = mid - 1;\n    } else {\n        start = mid + 1;\n    }\n}\n\nif (start == nums.length || nums[start] != target) {\n    // didn't find target\n    return result;\n} else {\n    result[0] = start;\n}\n\n// search rightmost target\nstart = 0;\nend = nums.length - 1;\n\nwhile (start <= end) {\n    int mid = (start + end) / 2;\n\n    // find target, keep search right part\n    if (nums[mid] == target) {\n        start = mid + 1;\n    } else if (nums[mid] > target) {\n        end = mid - 1;\n    } else {\n        start = mid + 1;\n    }\n}\n\n// we already know that target exist\n// end will convergence to target\nresult[1] = end;\n\nreturn result;\n```\n\nTime complexity O(logn), and space complexity O(1).","tags":["Leetcode - Array","Leetcode - Binary Search"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 33. Search in Rotated Sorted Array","url":"/Leetcode-33-Search-in-Rotated-Sorted-Array/","content":"## Question\n{% asset_img question.png %}\n<br/>\n<br/>\nThe original array is sorted, but rotated at some pivot index. We need to find the target value in the rotated array in O(logn). As we are looking for an O(logn) solution, we need to make use of binary search.\n\n### Similar Questions\n* Medium - [81. Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)\n* Medium - [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)\n\n## Solution\nObserve that for a given array, if we split it into half, at least one half is sorted. For example `[4 5 6 7 8 1 2 3]`, split from `7` and get `[4 5 6 7]` and `[8 1 2 3]`. The first half is sorted. \n\nBased on this observation, we can first find out which half is sorted (by comparing the end point values). Then check if target value is in this half. If it is, then discard the other half. If not, discard this half.\n\nCode:\n``` Java\nint start = 0;\nint end = nums.length - 1;\n\nwhile (start <= end) {\n    // get the mid point\n    int mid = (start + end) / 2;\n\n    // find the target!\n    if (target == nums[mid]) {\n        return mid;\n    }\n\n    // check which side is in order by comparing end points value\n    if (nums[start] <= nums[mid]) {\n        // left side is in order\n\n        // check if target in sorted half\n        // because this half is sorted, just check to see if target is in range\n        if (target >= nums[start] && target < nums[mid]) {\n            // in this case, target in left side\n            end = mid - 1;\n        } else {\n            // in this case, target in right side\n            start = mid + 1;\n        }\n    } else {\n        // right side is in order\n        if (target > nums[mid] && target <= nums[end]) {\n            start = mid + 1;\n        } else {\n            end = mid - 1;\n        }\n    }\n}\n\n// target no found\nreturn -1;\n```\n\nTime complexity O(logn), and space complexity O(1).","tags":["Leetcode - Array","Leetcode - Binary Search"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 31: Next Permutation","url":"/Leetcode-31-Next-Permutation/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nThis problem is a bit hard to understand. Suppose we have number 123, then the permutation has 132，213，231，312，321. Sort them in order gives us: **123** 132 213 231 312 321. So what we are looking for is `132`.\n\n### Similar Questions\n* Medium - [46. Permutations](https://leetcode.com/problems/permutations/)\n* Medium - [47. Permutations II](https://leetcode.com/problems/permutations-ii/)\n* Medium - [60. Permutation Sequence](https://leetcode.com/problems/permutation-sequence/)\n\n## Solution\nSolution referenced from here: [31. Next Permutation](https://leetcode.com/articles/next-permutation/)\n\nIn normal cases, to make the number bigger, we need any digit to become larger. If we want to get a number that is just larger than the original one, we need to change the ones digit. For example, change 123 to 124.\n\nSince we are dealing with permutation, we can only exchange the digits.\n\nIf we start from the ones digit and proceed from right to left, find a larger one than the ones digit, and exchange them. The ones digit are exchanged to a higher position. After exchange the number become smaller because the ones digit is smaller. For example, number 132, we swap 2 and 3 and get 123, the ones digit become larger, but the overall number becomes smaller.\n\nSo ones digit is a no-go. Lets look at tens digti. If we exchange the first larger number that is left to the tens digit, the situation is the same. We will have a smaller number. For example, number 4123, we exchange 2 and 4, get 2143, smaller number!\n\nIf for a digit, we proceed from left to right, and exhange a number to the right that is larger. For 4123, we exchange 2 and 3, get 4132 which is larger. If for a certain digit (i.e tens digit), there is no digit to the right that is larger than it, then we move towards left until we get a number that has a digit to the right that is larger.\n\nAnother question is what if there are many digits to the right that are larger than it? In this case we want the one that is just larger to make sure the final number is as small as possible.\n\nAt this point we have a rough algorithm:\n1. Scan from right to left, find the digit that is smaller than it's right digit. We make the index of this digit `i`\n2. Scan from `i` to `end`, find the digit that is just larger than `i` digit. We make the index of this digit `j`\n3. Exhange `i` and `j`\n\nBut is it over? No. Although the number is larger, it may not be the next larger number. For example `158476531`, we start from tens digit `3`, no number to the right of `3` is larger than it. We move to `5`, `6`, `7`, the same. Until `4`. Then we look back from, and find `5` that is just larger than `4`. Exchange `5` and `4`, get `158576431`. We have a larger number, but it's not the one that is just larger. We need to reverse the digits that is right to `5` and get `158513467`, which is the just larger number.\n\nLook at the gif from [Leetcode](https://leetcode.com/problems/next-permutation/solution/) might help to understand to process:\n{% asset_img example.gif %}\n<br/>\n<br/>\nNow we have our algorithm:\n\n1. Scan from right to left, find the first digit that is smaller than it's right digit\n* index `i`\n* `num[i] < num[i+1]`\n2. Scan from `i` to `end`, find the element that is immediately bigger than `nums[i]`\n* index `j`\n* From `i` to `end`, the order is guaranteed to be descending\n3. Exchange `nums[i]` and `nums[j]`\n4. Reverse elements from `i + 1` to `end`\n\nCode:\n``` Java\npublic void nextPermutation(int[] nums) {\n    // start from tens digit\n    int firstSmallerIndex = nums.length - 2;\n\n    // find the first element that is smaller than it's right element\n    while (firstSmallerIndex >= 0 && nums[firstSmallerIndex + 1] <= nums[firstSmallerIndex]) {\n        firstSmallerIndex--;\n    }\n\n    // in this case all digit are in descending order (87654321), we just need to reverse all\n    if (firstSmallerIndex == -1) {\n        reverse(nums, 0);\n        return;\n    }\n\n    // from firstSmallerIndex to nums.length - 1, it's guaranteed to be in descending order\n    // find the index that is just bigger than firstSmallerIndex\n    int j = nums.length - 1;\n    while (j >= 0 && nums[j] <= nums[firstSmallerIndex]) {\n        j--;\n    }\n\n    // swap firstSmallerIndex and j\n    swap(nums, firstSmallerIndex, j);\n\n    // reverse elements to the right of firstSmallerIndex\n    reverse(nums, firstSmallerIndex + 1);\n}\n\n// helper method to swap 2 digits in the array\nprivate void swap(int[] nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}\n\n// helper method to reverse all elements starting from start, in the array\nprivate void reverse(int[] nums, int start) {\n    int i = start;\n    int j = nums.length - 1;\n\n    while (i <= j) {\n        swap(nums, i, j);\n        i++;\n        j--;\n    }\n}\n```\n\nTime Complexity: the wrost case is to scan all digit, so that is O(n). Space complexity: O(1)\n\nTo be honest, I think this question should be a `hard` level rather than a `medium`.","tags":["Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Java 8 Optional","url":"/Java-8-Optional/","content":"Java 8 introduced `Optional` class to avoid `NullPointerException`. Basically `Optional` class is a container to represent if an object exist or not. Use `Optional` make `null` value handling more elegant. See the example:\n\n``` Java\npublic String getUsername(User user) {\n    if(user == null)\n    {\n        return \"Unkown\";\n    }\n    \n    return user.getUsername();\n}\n```\n\nWith `Optional`:\n``` Java\npublic String getUsername(User user) {\n    return Optional.ofNullable(user).map(u -> u.getUsername()).orElse(\"Unkown\");\n}\n```\n\n## Create Optional object\nThere are 3 ways to create an `Optional` object:\n1. Create an `Optional` that has no value\n``` Java\nOptional<String> optional = Optional.empty();\n```\n\n2. Create an `Optional` that the object must not be null\n``` Java\nOptional<String> optional1 = Optional.of(\"optional object\");\n```\n\n3. Create an `Optional`. The object could be null. In this case the `Optional` has no value\n``` Java\nOptional<String> optional2 = Optional.ofNullable(null);\n```\n\n## get() Method\nIt is used to return the value of the wrapper object. But if the wrapper object value is null, a `NoSuchElementException` will be thrown.\n\n## isPresent() Method\nUsed to determined the if the object is not null. Using it is not a good behavior as the logic would be excatly the same if we do a null check. And we are introducing an extra step to wrap the object with `Optional`\n\n## ifPresent() Method\nThe `ifPresent()` accept a `Consumer Interface` as parameter. If the object is not null then the `Consumer Interface` will be called to perform a specific action.\n``` Java\nOptional<User> optionalUser = Optional.ofNullable(user);\n\n// if user exist then print the username\noptionalUser.ifPresent(user -> System.out.println(user.getUsername()));\n```\n\n## filter() Method\nThe `filter() `method accepts a `Predicate` interface, which is used to filter the `Optional` object. If the condition of `Predicate` is met, the `Optional` object itself is returned. Otherwise, an empty `Optional` object is returned.\n``` Java\nOptional.ofNullable(item).filter( i -> i.getPrice() > 100).ifPresent(i ->  System.out.println(\"The item cost over $100\"));\n```\n\n## map() Method\nThe `map()` method takes a `Function` object. It uses the `Function` to the `Optional` and wrap it into a new `Optional` object (the type of the wrapper object may change).\n``` Java\nOptional.ofNullable(user).map(u -> u.getUsername()); \n```\n\n## orElse() Method\nIf the `Optional` object is not null, then return it's value. Otherwise return the default value specified as the function parameter.\n``` Java\nOptional.ofNullable(user).map(u -> u.getUsername()).orElse(\"Unkown\");\n```\n\n## orElseGet() Method\nSimilar to `orElse()`, except that the parameter of the `orElseGet()` is a `Supplier` object. The return value of the `get()` of the `Supplier` object is used as the default value.\n``` Java\nOptional.ofNullable(user).map(u -> u.getUsername()).orElseGet(() -> \"Unkown\");  \n```\n\n## orElseThrow() Method\nSimilar to `orElseGet()`. The parameters are all `Supplier` objects, except that the `Supplier` object of `orElseThrow()` must return a `Throwable` exception. The `orElseThrow()` method is useful for scenarios where a specific exception needs to be thrown when the wrapped object value is null.\n``` Java\nOptional.ofNullable(user).map(u -> u.getUsername()).orElseThrow(() -> new RuntimeException(\"Unkown\"))\n```","tags":["Java 8 New Features"],"categories":["Java"]},{"title":"Leetcode 18: 4Sum","url":"/Leetcode-18-4Sum/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nSimilar to {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}. This time we want to find all 4 numbers that add up to the target  value.\n\n### Similar Questions\n* Easy - [1. Two Sum](https://leetcode.com/problems/two-sum/)\n* Medium - {% post_link Leetcode-15-3Sum '15: 3Sum' %}\n* Medium - [454. 4Sum II](https://leetcode.com/problems/4sum-ii/)\n\n## Soultion\nThe idea is excatly same with {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}. Just adding another layer of for loop.\n\n1. Sort the array\n2. First for loop to get the first number. (0 - num.length - 3)\n3. Use an If statement to avoid duplicate. (Skip the same number)\n4. Second for loop to get second number. (i + 1 to num.length - 2)\n5. Another If statement to avoid duplicate. (Skip the same number)\n6. Now we use 2 pointers `head` and `tail` to find remaining 2 numbers\n7. `sum = target - num[i] - num[j]`\n8. Depending on the comparison of sum and target:\n  8.1 sum = target: add to the result list, and move inward `head` and `tail` until all same number are skipped\n  8.2 sum < target: `head++`\n  8.3 sum > target: `tail--`\n\n``` Java\n        List<List<Integer>> results = new ArrayList<>();\n\n        Arrays.sort(nums);\n\n        // first for loop to get first number\n        for (int i = 0; i < nums.length; i++) {\n            // to avoid duplicate\n            if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n                // second for loop to get second number\n                for (int j = i + 1; j < nums.length; j++) {\n                    // to avoid duplicate\n                    if (j == i + 1 || (j > 0 && nums[j] != nums[j - 1])) {\n                        int low = j + 1;\n                        int high = nums.length - 1;\n\n                        int sum = target - nums[i] - nums[j];\n\n                        // find remaining 2 numbers\n                        while (low < high) {\n                            // find the results\n                            if (nums[low] + nums[high] == sum) {\n                                results.add(Arrays.asList(nums[i], nums[j], nums[low], nums[high]));\n\n                                low++;\n                                high--;\n\n                                // skip same number\n                                while (low < high && nums[low] == nums[low - 1]) {\n                                    low++;\n                                }\n\n                                // skip same number\n                                while (low < high && nums[high] == nums[high + 1]) {\n                                    high--;\n                                }\n                            } else if (nums[low] + nums[high] > sum) {\n                                high--;\n                            } else {\n                                low++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return results;\n```\n\nTime complexity O(n<sup>3</sup>), and space complexity O(1).","tags":["Leetcode - Array","Leetcode - Two Pointers","Leetcode - Hash Table"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 16: 3Sum Closest","url":"/Leetcode-16-3Sum-Closest/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nSimilar to {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}. This time we want to find the 3 sum that is closest to the target value.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-15-3Sum '15: 3Sum' %}\n\n## Solution 1\nBrute force. We need 3 nested loop to get all possible sums, and then get the sum that is closest to the target. Time  complexity is O(n<sup>3</sup>). Space complexity O(1).\n\n## Solution 2\nWe can make use of the similar idea of {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}.\n1. Sort the array\n2. Loop the array to get the first number `nums[i]`\n3. Use 2 pointers `head` and `tail` to loop the remaining array (`head = i + 1`)\n4. `sum = nums[i] + nums[head] + nums[tail]`\n5. Depending on the comparison of sum and target:\n  5.1 sum = target: then we can return the value as it as closest to the target\n  5.2 sum < target: `head++`\n  5.3 sum > target: `tail--`\n6. Use a variable to keep track of the smallest distance\n\nCode:\n``` Java\n    // keep trakc of minimun distance\n    int distance = Integer.MAX_VALUE;\n    int result = 0;\n\n    // sort the array\n    Arrays.sort(nums);\n\n    for (int i = 0; i < nums.length; i++) {\n        int low = i + 1;\n        int high = nums.length - 1;\n\n        // another loop with 2 pointers\n        while (low < high) {\n            int tempSum = nums[i] + nums[low] + nums[high];\n            if (tempSum == target) {\n                return tempSum;\n            } else if (tempSum > target) {\n                high--;\n            } else {\n                low++;\n            }\n\n            if (Math.abs(tempSum - target) < distance) {\n                distance = Math.abs(tempSum - target);\n                result = tempSum;\n            }\n        }\n    }\n\n    return result;\n```\n\nWe are running 2 loops (O(n<sup>2</sup>)), and space complexity O(1).","tags":["Leetcode - Array","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 15: 3Sum","url":"/Leetcode-15-3Sum/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven an array, find all unique triplets that add up to 0\n\n### Similar Questions\n* Easy - [1. Two Sum](https://leetcode.com/problems/two-sum/)\n* Medium - {% post_link Leetcode-16-3Sum-Closest '16: 3Sum Closest' %}\n* Medium - {% post_link Leetcode-18-4Sum '18: 4Sum' %}\n\n## Solution 1\nBrute force solution. We need 3 nested for loops. If we found that `nums[i] + nums[j] + nums[k] == target`, then need to check if the solution already exist (which takes O(n)). So the overall complexity is O(n<sup>3</sup>). Space complexity O(1).\n\n## Solution 2\nReference [https://leetcode.com/problems/3sum/discuss/7380/Concise-O(N2)](https://leetcode.com/problems/3sum/discuss/7380/Concise-O(N2)) as a O(n<sup>2</sup>) solution.\n\nThe main idea is to iterate through the array, fix one number as sum, and find another 2 numbers that add up to -sum. The clever thing is how to find the other two numbers in O(n).\n\nThe achieve that, first we need to sort the array.\n\nThen we get `num[i]` as target , and try to find if there are 2 element add up to `-num[i]`. As the array is sorted, we can use 2 pointers (low and high) at head and tail, so find 2 elements takes O(n).\n* `num[low] + num[high] > target`, high = high -1. As we are greater than target, we need to decrease the high pointer to make sum smaller.\n* `num[low] + num[high] < target`, low++. As we are smaller than target, we need to increase the low pointer to make sum larger.\n\nTo avoid add duplicate result, we need to move the pointer to point to different number with `num[low]` and `num[high]`. For example, let's say the array is `[-2, -1, 0, 0, 1, 1, 2, 3]`. The `num[i] = -2`. We found that `num[1] + num[5] + num[i] = 0`. To continue the loop, we need to move `high = 5` to `high = 3`. If we don't have this step, then when the loop continues, we will have `num[1] + num[4] + num[i] = 0` and this result is duplicate with the result we already have.\n\nCode:\n``` Java\nList<List<Integer>> results = new ArrayList<>();\n\n// sort the array\nArrays.sort(nums);\n\nfor (int i = 0; i < nums.length; i++) {\n    // skip the same number in array when we choose the number as sum target\n    if (i > 0 && nums[i] == nums[i - 1]) {\n        continue;\n    }\n\n    // start the loop to find remaining 2 numbers\n    int low = i + 1;\n    int high = nums.length - 1;\n\n    int target = -nums[i];\n\n    while (low < high) {\n        // find the 2 numbers\n        if (nums[low] + nums[high] == target) {\n            results.add(Arrays.asList(nums[low], nums[high], nums[i]));\n\n            low++;\n            high--;\n\n            // skip same number to avoid duplicate\n            while (low < high && nums[low] == nums[low - 1]) {\n                low++;\n            }\n\n            // skip same number to avoid duplicate\n            while (low < high && nums[high] == nums[high + 1]) {\n                high--;\n            }\n        } else if (nums[low] + nums[high] > target) {\n            high--;\n        } else {\n            low++;\n        }\n    }\n}\n\nreturn results;\n```\n","tags":["Leetcode - Array","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"How to deserialize Json content with unknown property when using Jackson","url":"/How-to-deserialize-Json-content-with-unknown-property-when-using-Jackson/","content":"When using Jackson to deserialize a Json string, if the Java object does't include all the fields in the Json, Jackson will complain about unknown properties. In this post I will show how to ignore the properties if it is not defined in our Java object.\n\nSuppose we have the following Json string:\n```\n{\n    \"name\": \"name1\", \n    \"studentId\": \"12345\",\n    \"major\": \"computer science\"\n}\n```\n\nAnd the Java object:\n``` Java\nclass Student {\n    String name;\n    int studentId;\n\n    // getters and setters\n}\n```\n\nWhen we map the Json to the Java object, will see the following exception:\n```\ncom.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: \nUnrecognized field \"major\" (class com.experiment.jackson.JacksonDeserialize$Student), \nnot marked as ignorable (2 known properties: \"name\", \"studentId\"])\n```\n\nThere are 2 ways to deal with this problem:\n1. Configure the ObjectMapper to ignore unknown properties\n``` Java\nObjectMapper mapper = new ObjectMapper();\nmapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n```\n\n2. Mark the Java object to ignore unknown field. This way we only specify to ignore unknown properties when deserialize this particular class.\n``` Java\n@JsonIgnoreProperties (ignoreUnknown = true)\nclass Student {\n    String name;\n    int studentId;\n    \n    // getters and setters\n}\n```","tags":["Jackson"],"categories":["Java"]},{"title":"Leetcode 11: Container With Most Water","url":"/Leetcode-11-Container-With-Most-Water/","content":"\n## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nEach element of the array represents a height of a column. We want to pick 2 columns that can hold the most amount of water (shorter column height * distance between 2 columns).\n\n### Similar Questions\n* Hard - [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n\n## Solution 1\nThe most naive method is brute force. Check each pair of elements and calculate the result. Use a variable to store the largest one. We need 2 for loops, so the time complexity is O(n<sup>2</sup>). The good thing is that no extra space required. Thus space complexity is O(1).\n\n## Solution 2\nThe amount of water is determined by shorter column height and distance between 2 columns. If we start from maximun distance (in the following example, index 0 and 8). Then the height is column 0 as we are getting the shorter column height.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nIf we want to have a larger area, we can only reduce the distance and increase the height. So do we move the column 0 to column 1 ? Or column 8 to column 7? Of course, we will move the column that is shorter, so that the height might be increased.\n\nIn this example, if we change the column 8 to column 7, the distance is reduced, but the height is still unchanged (column 0 is still shorter), so the area will be reduced. But if we move column 0 to column 1, then column 8 becomes the shorter column and the area may increase.\n\nWhat if 2 columns have the same height? Well, in this case it doesn't matter which one we move. There will be 2 Circumstances.\n\n* There are 0 or 1 column between the 2 columns that is higher. Then the maximun area is when we choose these 2 same height column. As no matter how we move, the height is always less than these 2 columns, and distance is also smaller.\n* There are 2 or more columns between the 2 columns that is higher. These 2 columns will move to higher columns eventually, no matter which one moves first. \n\nSo the algorithm goes as follows:\n1. Have 2 pointers. one at start of array and one at the end of array.\n2. Each time move one pointer with smaller height inward\n3. Use a variable to record the area each time\n4. Loop until 2 pointers cross\n\nCode\n``` Java\nint result = 0;\nint left = 0;\nint right = height.length - 1;\n\nwhile (left < right) {\n    result = Math.max(result, (right - left) * Math.min(height[left], height[right]));\n\n    if (height[left] < height[right]) {\n        left++;\n    } else {\n        right--;\n    }\n}\n\nreturn result;\n```\n\nWe only loop the array once, so time complexity O(n). Space complexity O(1)","tags":["Leetcode - Array","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"How to force Github Pages rebuild","url":"/How-to-force-Github-Pages-rebuild/","content":"Github Pages has a nice feature that whenever you made a new commit, it will automatically build the page and publish the new changes. However, I ran into a strange situation that Github Pages didn't build my new commit. I could have just make another commit to trigger the build, but I'd rather have a nicer solution which can force Github Pages to build my site. After a bit of google search, turned out that Github provides an API to request a page build. Let's look at how to do this.\n\n## How to check the build status of Github Pages\nFirstly, let's look at how to check the build status of Github Pages. The easiest way is to check the commit history of your repository:\n{% asset_img commit.png %}\n<br/>\n<br/>\nIf the build fails due to some errors, then you will see something like this:\n{% asset_img commit-fail.png %}\n<br/>\n<br/>\nThen you should be able to check the error message by click on the red cross\n{% asset_img check.gif %}\n\n(GIF taken from [https://github.blog/2019-09-13-github-pages-builds-now-use-the-checks-api/](https://github.blog/2019-09-13-github-pages-builds-now-use-the-checks-api/))\n\n## Use Github API to force Github Pages rebuild site\nI found the solution here: [https://stackoverflow.com/questions/24098792/how-to-force-github-pages-build](https://stackoverflow.com/questions/24098792/how-to-force-github-pages-build)\n\n### Create a personal access token\nFollow the instructions here: [https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line](https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line)\n\nLog in Github account and navigate to: *Settings* -> *Developer settings* -> *Personal access tokens* -> *Generate new token*\n\nSelect *repo* scope\n{% asset_img repo.png %}\n\n### Call the Github API\nRun the script from command line or terminal:\n\n``` bash\ncurl -u username:token -X POST https://api.github.com/repos/username/reponame/pages/builds -H \"Accept: application/vnd.github.mister-fantastic-preview+json\"\n```\n\nReplace `username` with Github username\nReplace `token` with access token\nReplace `reponame` with repository name\n\nCheck detailed API documentation here: [https://developer.github.com/v3/repos/pages/#request-a-page-build](https://developer.github.com/v3/repos/pages/#request-a-page-build)\n\nYou should be able to see the result like this:\n{% asset_img result.png %}","categories":["how-to-guide"]},{"title":"Use Intellij to visualize debugging Stream operation","url":"/Use-Intellij-to-visualize-debugging-Stream-operation/","content":"Last time I talked about the stream API feature in Java 8. It is a very good new feature, but unlike previously looping code, single-step debugging does not work for stream API. Luckily, IntelliJ IDEA provides a tool for us to visualize the stream code.\n\nExample code:\n``` Java\nList<Integer> numbers2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\n\nnumbers2.stream()\n    .map(x -> x * x)\n    .filter(x -> x % 3 == 0)\n    .forEach(System.out::println);\n```\n\n<br/>\nAdd a break point at the last line of stream\n{% asset_img breakpoint.png %}\n<br/>\n<br/>\nStart debug, and find the button in debug interface\n{% asset_img button.png %}\n<br/>\n<br/>\nWait for a few seconds, you can see the results of each step of the stream operation\n{% asset_img result.png %}","tags":["Stream API","Intellij"],"categories":["Java"]},{"title":"Java 8 Streams Operations","url":"/Java-8-Streams-Operations/","content":"Stream operation is one of the main feature of Java 8. I have met these code a lot recently in the work. So I thought it would be good to write it up and summarize the key point of the knowledge.\n\n## Creation of stream\nThere are multiple different ways to create steams:\n\n### Stream.of()\n``` Java\nstatic <T> Stream<T> of(T... values)\n```\nExample:\n``` Java\nStream<String> stringStream = Stream.of(\"a\", \"b\", \"c\", \"d\");\n\nstringStream.forEach(System.out::println);\n\n// ============== Output：===============\n// a\n// b\n// c\n// d\n```\n\n### Stream.iterate()\n``` Java\nstatic <T> Stream<T> iterate(T seed, UnaryOperator<T> f)\n```\nCreate a stream start with a value, and iterate through by a certain operator.\n\nExample:\n``` Java\nStream.iterate(10, n -> n + 1)\n    .limit(5)\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// 10\n// 11\n// 12\n// 13\n// 14\n```\n\n### Stream.generate()\n``` Java\nstatic <T> Stream<T> generate(Supplier<T> s)\n```\nCreate a stream based on the value generate function. The generate function returns 1 value each time\n\nExample:\n``` Java\nStream.generate(Math::random)\n    .limit(5)\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// 0.09623470299238657\n// 0.8470095359492898\n// 0.20505426293183482\n// 0.8112754654328852\n// 0.009673283068063365\n```\n\n### Create a stream from an existing collection\n``` Java\nList<String> strings = Arrays.asList(\"hello\", \"world\", \"Java8\");\n\nstrings.stream().forEach(System.out::println);\n\n// ============== Output：===============\n// hello\n// world\n// Java8\n```\n\n## Stream operation\nNow we know how to create stream, let's look at what operations can be applied to stream\n\n### Filter and slice\n#### filter()\nThe filter method accepts a function that returns a boolean as a parameter, and returns a stream containing all the elements that match the condition. \n\nFor example, you can select all words starting with the letter w and print them like this:\n\n``` Java\nList<String> words = Arrays.asList(\"random\", \"hello\", \"wow\", \"world\", \"java\");\n\nwords.stream()\n    .filter(word -> word.startsWith(\"w\"))\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// wow\n// world\n```\n\nOr you can get the list that match those condition like this:\n``` Java\nList<String> words = Arrays.asList(\"random\", \"hello\", \"wow\", \"world\", \"java\");\n\nList<String> filtered = words.stream()\n    .filter(word -> word.startsWith(\"w\"))\n    .collect(Collectors.toList());\n```\n\n#### distince()\nThe distinct method will return a stream of elements that are unique. \n\nFor example, the following code returns the list that has no duplicates:\n``` Java\nList<Integer> numbers = Arrays.asList(1, 2, 1, 3, 2, 1, 3, 4);\n\nnumbers.stream()\n    .distinct()\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// 1\n// 2\n// 3\n// 4\n```\n\n#### skip()\nThe skip(n) method returns a stream that throws away the first n elements. If there are fewer than n elements in the stream, an empty stream is returned.\n\n### Mapping\nA very common data processing method is to select information from certain objects. For example, in SQL, you can select a column from the table, and the Stream API also provides similar tools through the `map` and `flatMap` methods.\n\n#### map()\nBefore Java8, we  need to take out one field of a collection object and then save it to another collection. With stream map, we can simply use map function to map out the field we want, then use collect them to new collection\n\n``` Java\npublic static void main(String[] args) {\n    List<Person> persons = Arrays.asList(new Person(20, \"Nick Li\"),\n        new Person(30, \"Mike\"), new Person(40, \"Peter\"));\n\n    persons.stream()\n        .map(Person::getAge)\n        .forEach(System.out::println);\n}\n\n// ============== Output：===============\n// 20\n// 30\n// 40\n\nprivate static class Person {\n    private int age;\n    private String name;\n\n    public int getAge() {\n        return age;\n    }\n\n    // skip constructor and other set, get methods\n}\n```\n\n#### flatMap()\nIf we want to know how many unique character in a list of words,  what should we do?\n\n``` Java\nList<String> words = Arrays.asList(\"Hello\", \"World\");\n\nwords.stream()\n    .map(s -> s.split(\"\"))\n    .distinct()\n    .collect(Collectors.toList())\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// [Ljava.lang.String;@312b1dae\n// [Ljava.lang.String;@7530d0a\n```\n\nThis is wrong because the map function returns a `String[]`. So we get a `Stream<String[]>` instead of `Stream<String>`. To solve this problem, we can use flatMap:\n``` Java\nList<String> words = Arrays.asList(\"Hello\", \"World\");\n\nwords.stream()\n     .map(s -> s.split(\"\"))\n     .flatMap(Arrays::stream)\n     .distinct()\n     .forEach(System.out::println);\n\n// ============== Output：===============\n// H\n// e\n// l\n// o\n// W\n// r\n// d\n```\n\nThe effect of using flatMap method is that each array is not mapped to a stream, but to the contents of the stream. In a nutshell, flatMap lets you convert each value in a stream to another stream, then join all the streams into one stream.\n\n### Find and match\nAnother common data processing method is to see if certain elements in the dataset match a given condition. The Stream API provides such tools through `allMatch`, `anyMatch`, `noneMatch`, `findFirst`, and `findAny` methods.\n\nThe function name is very self-explanatory. Let see some examples\n\nTo check if a collection contains even numbers:\n``` Java\nList<Integer> numbers = Arrays.asList(1, 2, 3);\n\nif (numbers.stream().anyMatch(x -> x % 2 == 0)) {\n    System.out.println(\"Yes\");\n} else {\n    System.out.println(\"No\");\n}\n\n// ============== Output：===============\n// Yes\n```\n\nTo find the first number in the list that it's square can be divided by 3\n``` Java\nList<Integer> numbers2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\n\nOptional<Integer> goodNumber = numbers2.stream()\n    .map(x -> x * x)\n    .filter(x -> x % 3 == 0)\n    .findFirst();\n\nSystem.out.println(goodNumber.get()); \n\n// ============== Output：===============\n// 9\n```\n\n### Reduce\nWe might need to complete more complext task, such as “Choose the longest word in a word” or “Calculate the total length of all words”. Such queries need to repeatedly combine the elements in the stream to get the final value. Such a query can be classified as a reduction operation (reducing the stream to a value).\n\nTo calculate the sum of an array:\n``` Java\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\nint sum = numbers.stream().reduce(0, (a, b) -> a + b);\n        \n// ============== Output：===============\n// 15\n```\n\nReduce returns the result every time and operates the result with the next element, such as the first time when traversing to element 1, returning the initial value 0 + 1 = 1, then using the return value of 1 and the second element 2, and so on, until the summation of the list of numbers is completed.\n\n### Intermediate and terminal operation\nAll operations on the Stream API fall into two categories: intermediate operations and terminal operations. The intermediate operation is just a kind of markup, and only the terminal operation will trigger the actual calculation.\n\n**Intermediate operations** can be divided into *stateless* and *stateful*. *Stateless* intermediate operations mean that the processing of elements is not affected by the previous elements, and *stateful* intermediate operations must wait until all elements are processed. For example, sorting is a stateful operation, and the sorting result cannot be determined until all elements are read.\n\n**The terminal operation** can be divided into *short-circuit* operation and *non-short-circuit* operation. The short-circuit operation means that the result can be returned without processing all the elements, such as finding the first element that satisfies the condition.\n\nA stream pipeline consists of a stream source, followed by zero or more intermediate operations, and a terminal operation.\n\n## To summarize the Stream API:\nA stream pipeline consists of a stream source, followed by zero or more intermediate operations, and a terminal operation.\n\n<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg .tg-axxb{font-weight:bold;background-color:#c0c0c0;color:#000000;border-color:inherit;text-align:center;vertical-align:top}\n.tg .tg-n9g5{background-color:#ffffff;color:#000000;border-color:inherit;text-align:left;vertical-align:middle}\n.tg .tg-x5q1{background-color:#ffffff;color:#000000;border-color:inherit;text-align:center;vertical-align:middle}\n.tg .tg-mq6t{background-color:#ffffff;color:#000000;border-color:inherit;text-align:left;vertical-align:middle}\n</style>\n<table class=\"tg\">\n  <tr>\n    <th class=\"tg-axxb\" colspan=\"4\">Stream API</th>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"11\">Intermediate<br>Operation</td>\n    <td class=\"tg-x5q1\" rowspan=\"7\">Stateless</td>\n    <td class=\"tg-n9g5\">unordered()<br></td>\n    <td class=\"tg-n9g5\">If order doesn't matter, then can use unordered() together with parallel() to speed up</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">filter()</td>\n    <td class=\"tg-n9g5\">Filter out elements in the stream based on a filter function</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">map()</td>\n    <td class=\"tg-n9g5\">Map stream to another stream based on a map function</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">mapToInt()<br>mapToLong()<br>mapToDouble()</td>\n    <td class=\"tg-mq6t\">Map to int, long or double</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">flatMap()</td>\n    <td class=\"tg-n9g5\">Make [[\"ABC\", \"DEF\"], [\"FGH\", \"IJK\"]] into [\"ABC\", \"DEF\", \"FGH\", \"IJK\"]：</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">flatMapToInt()<br>flatMapToLong()<br>flatMapToDouble()</td>\n    <td class=\"tg-mq6t\">Similar to mapToInt(), mapToLong(), mapToDouble()</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">peek()</td>\n    <td class=\"tg-n9g5\">Performs specified operation on each element of the stream and returns a new stream which can be used further.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"4\">Stateful</td>\n    <td class=\"tg-n9g5\">distinct()</td>\n    <td class=\"tg-n9g5\">Filter out duplicate element in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">sorted()</td>\n    <td class=\"tg-n9g5\">Sort the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">limit()</td>\n    <td class=\"tg-n9g5\">Limit the number of elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">skip()</td>\n    <td class=\"tg-n9g5\">Skip certain number of elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"13\">Terminal<br>Operation</td>\n    <td class=\"tg-x5q1\" rowspan=\"5\">short-circuit<br></td>\n    <td class=\"tg-n9g5\">anyMatch()</td>\n    <td class=\"tg-n9g5\">Return if any element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">allMatch()</td>\n    <td class=\"tg-n9g5\">Return if all element in the stream that satisfies the condition </td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">noneMatch()</td>\n    <td class=\"tg-n9g5\">Return if no element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">findFirst()</td>\n    <td class=\"tg-n9g5\">Find first element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">findAny()</td>\n    <td class=\"tg-n9g5\">Find any element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"8\">non-short-circuit</td>\n    <td class=\"tg-n9g5\">forEach()</td>\n    <td class=\"tg-n9g5\">Iterate all elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">forEachOrdered()</td>\n    <td class=\"tg-n9g5\">Iterate all elements in the stream by order. Can't make use of parallel()</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">toArray()</td>\n    <td class=\"tg-n9g5\">Return an array of all elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">reduce()</td>\n    <td class=\"tg-n9g5\">Reduce all elements to one results based on given function</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">collect()</td>\n    <td class=\"tg-n9g5\">Process the elements in the stream and get all values</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">max()</td>\n    <td class=\"tg-n9g5\">Find max element in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">min()</td>\n    <td class=\"tg-n9g5\">Find min element in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">count()</td>\n    <td class=\"tg-n9g5\">Get number of element in the stream</td>\n  </tr>\n</table>","tags":["Java 8 New Features"],"categories":["Java"]},{"title":"How to deploy Hexo blog to Github pages","url":"/How-to-deploy-Hexo-blog-to-Github-pages/","content":"\nHexo provides fast and easy one-click deployment, supporting [Github Pages](https://pages.github.com), [Netlify](https://www.netlify.com), [OpenShift](https://www.openshift.com) etc. In this post, I will walk through the process of deploying Hexo blog site to [Github Pages](https://pages.github.com).\n\n## Folder structure of Hexo \nBefore discussing the process, I think it is important to understand the folder structure of Hexo. Basically, a Hexo blog site contains the following folders:\n\n* **scaffolds:** Template folder. When you create a new post, Hexo will create a \".md\" file under `source` based on scaffold.\n* **source:** The Resource folder. It is where the user resources are stored. It stores all \".md\" files which would be rendered to html pages.\n* **themes:** Stores all theme files.\n* **public** This is where all rendered files comes in. When deploying, we need this folder to get to the Github repository so that Github pages can host it.\n\nNow let's look at how to deploy the blog site to Github Pages.\n\n## Install hexo-deployer-git\n``` bash\nnpm install hexo-deployer-git --save\n```\n\n## Setup Github repository\nLogin GitHub account and create a new repository named username.github.io, where username is the username on GitHub.\n \n * Note that the first part of the repository must exactly match the username, otherwise it won’t work.\n\nRefer to [https://pages.github.com](https://pages.github.com) for more details.\n\n## Change config file\nAdd the following lines to `_config.yml`:\n\n```\ndeploy:\n  type:    git\n  repo:    <repository url> #e.g. https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io\n  branch:  [branch]         #branch name, default is 'master'\n  message: [message]        #commit message, default is 'Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}'\n```\n\n## Generate site files and push to remote repository\n``` bash\nhexo clean\nhexo deploy\n```\n\nWait for a couple of minutes, then visit username.github.io, the blog site should be visiable!\n\n## How does it works\nWhen hexo deploy is executed, Hexo pushes the files and directories in the `public` folder to the remote repositories and branches specified in `_config.yml` and completely overwrites the existing content under that branch.","tags":["hexo"],"categories":["how-to-guide"]},{"title":"How to build a blog with hexo","url":"/How-to-build-a-blog-with-hexo/","content":"\nHexo is a blog framework powered by Node.js. I recently built my blog with it and found it extremely easy and fast. The posts are written in Markdown and Hexo will generates static files in seconds. \n\nIn this post I will walk through the steps to setup a blog running locally. There will be another post discussing deploy the blog site to Github page. Here I will only discuss how to install Hexo blog on MacOS. For installation on other platforms such as Windows, please refer to other online posts like [https://www.how2shout.com/how-to/install-hexo-nodejs-blog-on-windows-10-with-github.html](https://www.how2shout.com/how-to/install-hexo-nodejs-blog-on-windows-10-with-github.html)\n\n## Requirems to install Hexo\n* [Node.js](https://nodejs.org/en/)\n* [Git](https://git-scm.com)\n\n## Install Node.js\nRun this script in the terminal:\n``` bash\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | sh\n```\n\nEdit zsh config to load nvm each time:\n\n``` bash\nvi ~/.zshrc\n```\n\nAdd: `[[ -s $HOME/.nvm/nvm.sh ]] && . $HOME/.nvm/nvm.sh` to the end of the file\n\nThen run the command to install node.js\n``` bash\nnvm install node\n```\n\nAfter the script finishes running, you should see the following output, which means node.js is all set. Great!\n\n{% asset_img node-success.png %}\n\n## Install Git\nNext is install Git so you can checkout code from source repositry. On Mac the easiest way is to use [HomeBrew](https://brew.sh). You can install Brew with one line of command:\n\n``` bash\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\nAfter Brew is installed, use it to install Git:\n\n``` bash\nBrew install git\n```\n\n## Install Hexo\nWith Node.js and Git all set, you can install Hexo run the following  command\n\n``` bash\nnpm install -g hexo-cli\n```\n\n## Create a blog site\nNow it comes to the moment when you are able to create the blog site. Simply run:\n\n``` bash\nhexo init my-blog\ncd my-blog\nhexo install\n```\n\nHexo will download and create all necessary files to 'my-blog' folder. \n\n## Run the Hexo server\nEverything is ready and you can run the Hexo server to view your blog site!\n\n``` bash\nhexo server\n```\n\nVisit [http://localhost:4000](http://localhost:4000) and you should be able to see the webpage show up\n\n{% asset_img blog-page.png %}\n\n\nCongraturations! You have a blog site up and running. You can create a post using `hexo new post \"Blog title\"`. You can also change the themes and add plugins to the site.","tags":["hexo"],"categories":["how-to-guide"]}]
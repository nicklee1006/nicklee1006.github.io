[{"title":"Leetcode 18: 4Sum","url":"/Leetcode-18-4Sum/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nSimilar to {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}. This time we want to find all 4 numbers that add up to the target  value.\n\n## Soultion\nThe idea is excatly same with {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}. Just adding another layer of for loop.\n\n1. Sort the array\n2. First for loop to get the first number. (0 - num.length - 3)\n3. Use an If statement to avoid duplicate. (Skip the same number)\n4. Second for loop to get second number. (i + 1 to num.length - 2)\n5. Another If statement to avoid duplicate. (Skip the same number)\n6. Now we use 2 pointers `head` and `tail` to find remaining 2 numbers\n7. `sum = target - num[i] - num[j]`\n8. Depending on the comparison of sum and target:\n  8.1 sum = target: add to the result list, and move inward `head` and `tail` until all same number are skipped\n  8.2 sum < target: `head++`\n  8.3 sum > target: `tail--`\n\n``` Java\n        List<List<Integer>> results = new ArrayList<>();\n\n        Arrays.sort(nums);\n\n        // first for loop to get first number\n        for (int i = 0; i < nums.length; i++) {\n            // to avoid duplicate\n            if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n                // second for loop to get second number\n                for (int j = i + 1; j < nums.length; j++) {\n                    // to avoid duplicate\n                    if (j == i + 1 || (j > 0 && nums[j] != nums[j - 1])) {\n                        int low = j + 1;\n                        int high = nums.length - 1;\n\n                        int sum = target - nums[i] - nums[j];\n\n                        // find remaining 2 numbers\n                        while (low < high) {\n                            // find the results\n                            if (nums[low] + nums[high] == sum) {\n                                results.add(Arrays.asList(nums[i], nums[j], nums[low], nums[high]));\n\n                                low++;\n                                high--;\n\n                                // skip same number\n                                while (low < high && nums[low] == nums[low - 1]) {\n                                    low++;\n                                }\n\n                                // skip same number\n                                while (low < high && nums[high] == nums[high + 1]) {\n                                    high--;\n                                }\n                            } else if (nums[low] + nums[high] > sum) {\n                                high--;\n                            } else {\n                                low++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return results;\n```\n\nTime complexity O(n<sup>3</sup>), and space complexity O(1).","tags":["Leetcode - Array","Leetcode - Two Pointers","Leetcode - Hash Table"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 16: 3Sum Closest","url":"/Leetcode-16-3Sum-Closest/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nSimilar to {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}. This time we want to find the 3 sum that is closest to the target value.\n\n## Solution 1\nBrute force. We need 3 nested loop to get all possible sums, and then get the sum that is closest to the target. Time  complexity is O(n<sup>3</sup>). Space complexity O(1).\n\n## Solution 2\nWe can make use of the similar idea of {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}.\n1. Sort the array\n2. Loop the array to get the first number `nums[i]`\n3. Use 2 pointers `head` and `tail` to loop the remaining array (`head = i + 1`)\n4. `sum = nums[i] + nums[head] + nums[tail]`\n5. Depending on the comparison of sum and target:\n  5.1 sum = target: then we can return the value as it as closest to the target\n  5.2 sum < target: `head++`\n  5.3 sum > target: `tail--`\n6. Use a variable to keep track of the smallest distance\n\nCode:\n``` Java\n    // keep trakc of minimun distance\n    int distance = Integer.MAX_VALUE;\n    int result = 0;\n\n    // sort the array\n    Arrays.sort(nums);\n\n    for (int i = 0; i < nums.length; i++) {\n        int low = i + 1;\n        int high = nums.length - 1;\n\n        // another loop with 2 pointers\n        while (low < high) {\n            int tempSum = nums[i] + nums[low] + nums[high];\n            if (tempSum == target) {\n                return tempSum;\n            } else if (tempSum > target) {\n                high--;\n            } else {\n                low++;\n            }\n\n            if (Math.abs(tempSum - target) < distance) {\n                distance = Math.abs(tempSum - target);\n                result = tempSum;\n            }\n        }\n    }\n\n    return result;\n```\n\nWe are running 2 loops (O(n<sup>2</sup>)), and space complexity O(1).","tags":["Leetcode - Array","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 15: 3Sum","url":"/Leetcode-15-3Sum/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven an array, find all unique triplets that add up to 0\n\n## Solution 1\nBrute force solution. We need 3 nested for loops. If we found that `nums[i] + nums[j] + nums[k] == target`, then need to check if the solution already exist (which takes O(n)). So the overall complexity is O(n<sup>3</sup>). Space complexity O(1).\n\n## Solution 2\nReference [https://leetcode.com/problems/3sum/discuss/7380/Concise-O(N2)](https://leetcode.com/problems/3sum/discuss/7380/Concise-O(N2)) as a O(n<sup>2</sup>) solution.\n\nThe main idea is to iterate through the array, fix one number as sum, and find another 2 numbers that add up to -sum. The clever thing is how to find the other two numbers in O(n).\n\nThe achieve that, first we need to sort the array.\n\nThen we get `num[i]` as target , and try to find if there are 2 element add up to `-num[i]`. As the array is sorted, we can use 2 pointers (low and high) at head and tail, so find 2 elements takes O(n).\n* `num[low] + num[high] > target`, high = high -1. As we are greater than target, we need to decrease the high pointer to make sum smaller.\n* `num[low] + num[high] < target`, low++. As we are smaller than target, we need to increase the low pointer to make sum larger.\n\nTo avoid add duplicate result, we need to move the pointer to point to different number with `num[low]` and `num[high]`. For example, let's say the array is `[-2, -1, 0, 0, 1, 1, 2, 3]`. The `num[i] = -2`. We found that `num[1] + num[5] + num[i] = 0`. To continue the loop, we need to move `high = 5` to `high = 3`. If we don't have this step, then when the loop continues, we will have `num[1] + num[4] + num[i] = 0` and this result is duplicate with the result we already have.\n\nCode:\n``` Java\nList<List<Integer>> results = new ArrayList<>();\n\n// sort the array\nArrays.sort(nums);\n\nfor (int i = 0; i < nums.length; i++) {\n    // skip the same number in array when we choose the number as sum target\n    if (i > 0 && nums[i] == nums[i - 1]) {\n        continue;\n    }\n\n    // start the loop to find remaining 2 numbers\n    int low = i + 1;\n    int high = nums.length - 1;\n\n    int target = -nums[i];\n\n    while (low < high) {\n        // find the 2 numbers\n        if (nums[low] + nums[high] == target) {\n            results.add(Arrays.asList(nums[low], nums[high], nums[i]));\n\n            low++;\n            high--;\n\n            // skip same number to avoid duplicate\n            while (low < high && nums[low] == nums[low - 1]) {\n                low++;\n            }\n\n            // skip same number to avoid duplicate\n            while (low < high && nums[high] == nums[high + 1]) {\n                high--;\n            }\n        } else if (nums[low] + nums[high] > target) {\n            high--;\n        } else {\n            low++;\n        }\n    }\n}\n\nreturn results;\n```\n","tags":["Leetcode - Array","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"How to deserialize Json content with unknown property when using Jackson","url":"/How-to-deserialize-Json-content-with-unknown-property-when-using-Jackson/","content":"When using Jackson to deserialize a Json string, if the Java object does't include all the fields in the Json, Jackson will complain about unknown properties. In this post I will show how to ignore the properties if it is not defined in our Java object.\n\nSuppose we have the following Json string:\n```\n{\n    \"name\": \"name1\", \n    \"studentId\": \"12345\",\n    \"major\": \"computer science\"\n}\n```\n\nAnd the Java object:\n``` Java\nclass Student {\n    String name;\n    int studentId;\n\n    // getters and setters\n}\n```\n\nWhen we map the Json to the Java object, will see the following exception:\n```\ncom.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: \nUnrecognized field \"major\" (class com.experiment.jackson.JacksonDeserialize$Student), \nnot marked as ignorable (2 known properties: \"name\", \"studentId\"])\n```\n\nThere are 2 ways to deal with this problem:\n1. Configure the ObjectMapper to ignore unknown properties\n``` Java\nObjectMapper mapper = new ObjectMapper();\nmapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n```\n\n2. Mark the Java object to ignore unknown field. This way we only specify to ignore unknown properties when deserialize this particular class.\n``` Java\n@JsonIgnoreProperties (ignoreUnknown = true)\nclass Student {\n    String name;\n    int studentId;\n    \n    // getters and setters\n}\n```","tags":["Jackson"],"categories":["Java"]},{"title":"Leetcode 11: Container With Most Water","url":"/Leetcode-11-Container-With-Most-Water/","content":"\n## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nEach element of the array represents a height of a column. We want to pick 2 columns that can hold the most amount of water (shorter column height * distance between 2 columns).\n\n## Solution 1\nThe most naive method is brute force. Check each pair of elements and calculate the result. Use a variable to store the largest one. We need 2 for loops, so the time complexity is O(n<sup>2</sup>). The good thing is that no extra space required. Thus space complexity is O(1).\n\n## Solution 2\nThe amount of water is determined by shorter column height and distance between 2 columns. If we start from maximun distance (in the following example, index 0 and 8). Then the height is column 0 as we are getting the shorter column height.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nIf we want to have a larger area, we can only reduce the distance and increase the height. So do we move the column 0 to column 1 ? Or column 8 to column 7? Of course, we will move the column that is shorter, so that the height might be increased.\n\nIn this example, if we change the column 8 to column 7, the distance is reduced, but the height is still unchanged (column 0 is still shorter), so the area will be reduced. But if we move column 0 to column 1, then column 8 becomes the shorter column and the area may increase.\n\nWhat if 2 columns have the same height? Well, in this case it doesn't matter which one we move. There will be 2 Circumstances.\n\n* There are 0 or 1 column between the 2 columns that is higher. Then the maximun area is when we choose these 2 same height column. As no matter how we move, the height is always less than these 2 columns, and distance is also smaller.\n* There are 2 or more columns between the 2 columns that is higher. These 2 columns will move to higher columns eventually, no matter which one moves first. \n\nSo the algorithm goes as follows:\n1. Have 2 pointers. one at start of array and one at the end of array.\n2. Each time move one pointer with smaller height inward\n3. Use a variable to record the area each time\n4. Loop until 2 pointers cross\n\nCode\n``` Java\nint result = 0;\nint left = 0;\nint right = height.length - 1;\n\nwhile (left < right) {\n    result = Math.max(result, (right - left) * Math.min(height[left], height[right]));\n\n    if (height[left] < height[right]) {\n        left++;\n    } else {\n        right--;\n    }\n}\n\nreturn result;\n```\n\nWe only loop the array once, so time complexity O(n). Space complexity O(1)","tags":["Leetcode - Array","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"How to force Github Pages rebuild","url":"/How-to-force-Github-Pages-rebuild/","content":"Github Pages has a nice feature that whenever you made a new commit, it will automatically build the page and publish the new changes. However, I ran into a strange situation that Github Pages didn't build my new commit. I could have just make another commit to trigger the build, but I'd rather have a nicer solution which can force Github Pages to build my site. After a bit of google search, turned out that Github provides an API to request a page build. Let's look at how to do this.\n\n## How to check the build status of Github Pages\nFirstly, let's look at how to check the build status of Github Pages. The easiest way is to check the commit history of your repository:\n{% asset_img commit.png %}\n<br/>\n<br/>\nIf the build fails due to some errors, then you will see something like this:\n{% asset_img commit-fail.png %}\n<br/>\n<br/>\nThen you should be able to check the error message by click on the red cross\n{% asset_img check.gif %}\n\n(GIF taken from [https://github.blog/2019-09-13-github-pages-builds-now-use-the-checks-api/](https://github.blog/2019-09-13-github-pages-builds-now-use-the-checks-api/))\n\n## Use Github API to force Github Pages rebuild site\nI found the solution here: [https://stackoverflow.com/questions/24098792/how-to-force-github-pages-build](https://stackoverflow.com/questions/24098792/how-to-force-github-pages-build)\n\n### Create a personal access token\nFollow the instructions here: [https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line](https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line)\n\nLog in Github account and navigate to: *Settings* -> *Developer settings* -> *Personal access tokens* -> *Generate new token*\n\nSelect *repo* scope\n{% asset_img repo.png %}\n\n### Call the Github API\nRun the script from command line or terminal:\n\n``` bash\ncurl -u username:token -X POST https://api.github.com/repos/username/reponame/pages/builds -H \"Accept: application/vnd.github.mister-fantastic-preview+json\"\n```\n\nReplace `username` with Github username\nReplace `token` with access token\nReplace `reponame` with repository name\n\nCheck detailed API documentation here: [https://developer.github.com/v3/repos/pages/#request-a-page-build](https://developer.github.com/v3/repos/pages/#request-a-page-build)\n\nYou should be able to see the result like this:\n{% asset_img result.png %}","categories":["how-to-guide"]},{"title":"Use Intellij to visualize debugging Stream operation","url":"/Use-Intellij-to-visualize-debugging-Stream-operation/","content":"Last time I talked about the stream API feature in Java 8. It is a very good new feature, but unlike previously looping code, single-step debugging does not work for stream API. Luckily, IntelliJ IDEA provides a tool for us to visualize the stream code.\n\nExample code:\n``` Java\nList<Integer> numbers2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\n\nnumbers2.stream()\n    .map(x -> x * x)\n    .filter(x -> x % 3 == 0)\n    .forEach(System.out::println);\n```\n\n<br/>\nAdd a break point at the last line of stream\n{% asset_img breakpoint.png %}\n<br/>\n<br/>\nStart debug, and find the button in debug interface\n{% asset_img button.png %}\n<br/>\n<br/>\nWait for a few seconds, you can see the results of each step of the stream operation\n{% asset_img result.png %}","tags":["Stream API","Intellij"],"categories":["Java"]},{"title":"Java 8 Streams Operations","url":"/Java-8-Streams-Operations/","content":"Stream operation is one of the main feature of Java 8. I have met these code a lot recently in the work. So I thought it would be good to write it up and summarize the key point of the knowledge.\n\n## Creation of stream\nThere are multiple different ways to create steams:\n\n### Stream.of()\n``` Java\nstatic <T> Stream<T> of(T... values)\n```\nExample:\n``` Java\nStream<String> stringStream = Stream.of(\"a\", \"b\", \"c\", \"d\");\n\nstringStream.forEach(System.out::println);\n\n// ============== Output：===============\n// a\n// b\n// c\n// d\n```\n\n### Stream.iterate()\n``` Java\nstatic <T> Stream<T> iterate(T seed, UnaryOperator<T> f)\n```\nCreate a stream start with a value, and iterate through by a certain operator.\n\nExample:\n``` Java\nStream.iterate(10, n -> n + 1)\n    .limit(5)\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// 10\n// 11\n// 12\n// 13\n// 14\n```\n\n### Stream.generate()\n``` Java\nstatic <T> Stream<T> generate(Supplier<T> s)\n```\nCreate a stream based on the value generate function. The generate function returns 1 value each time\n\nExample:\n``` Java\nStream.generate(Math::random)\n    .limit(5)\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// 0.09623470299238657\n// 0.8470095359492898\n// 0.20505426293183482\n// 0.8112754654328852\n// 0.009673283068063365\n```\n\n### Create a stream from an existing collection\n``` Java\nList<String> strings = Arrays.asList(\"hello\", \"world\", \"Java8\");\n\nstrings.stream().forEach(System.out::println);\n\n// ============== Output：===============\n// hello\n// world\n// Java8\n```\n\n## Stream operation\nNow we know how to create stream, let's look at what operations can be applied to stream\n\n### Filter and slice\n#### filter()\nThe filter method accepts a function that returns a boolean as a parameter, and returns a stream containing all the elements that match the condition. \n\nFor example, you can select all words starting with the letter w and print them like this:\n\n``` Java\nList<String> words = Arrays.asList(\"random\", \"hello\", \"wow\", \"world\", \"java\");\n\nwords.stream()\n    .filter(word -> word.startsWith(\"w\"))\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// wow\n// world\n```\n\nOr you can get the list that match those condition like this:\n``` Java\nList<String> words = Arrays.asList(\"random\", \"hello\", \"wow\", \"world\", \"java\");\n\nList<String> filtered = words.stream()\n    .filter(word -> word.startsWith(\"w\"))\n    .collect(Collectors.toList());\n```\n\n#### distince()\nThe distinct method will return a stream of elements that are unique. \n\nFor example, the following code returns the list that has no duplicates:\n``` Java\nList<Integer> numbers = Arrays.asList(1, 2, 1, 3, 2, 1, 3, 4);\n\nnumbers.stream()\n    .distinct()\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// 1\n// 2\n// 3\n// 4\n```\n\n#### skip()\nThe skip(n) method returns a stream that throws away the first n elements. If there are fewer than n elements in the stream, an empty stream is returned.\n\n### Mapping\nA very common data processing method is to select information from certain objects. For example, in SQL, you can select a column from the table, and the Stream API also provides similar tools through the `map` and `flatMap` methods.\n\n#### map()\nBefore Java8, we  need to take out one field of a collection object and then save it to another collection. With stream map, we can simply use map function to map out the field we want, then use collect them to new collection\n\n``` Java\npublic static void main(String[] args) {\n    List<Person> persons = Arrays.asList(new Person(20, \"Nick Li\"),\n        new Person(30, \"Mike\"), new Person(40, \"Peter\"));\n\n    persons.stream()\n        .map(Person::getAge)\n        .forEach(System.out::println);\n}\n\n// ============== Output：===============\n// 20\n// 30\n// 40\n\nprivate static class Person {\n    private int age;\n    private String name;\n\n    public int getAge() {\n        return age;\n    }\n\n    // skip constructor and other set, get methods\n}\n```\n\n#### flatMap()\nIf we want to know how many unique character in a list of words,  what should we do?\n\n``` Java\nList<String> words = Arrays.asList(\"Hello\", \"World\");\n\nwords.stream()\n    .map(s -> s.split(\"\"))\n    .distinct()\n    .collect(Collectors.toList())\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// [Ljava.lang.String;@312b1dae\n// [Ljava.lang.String;@7530d0a\n```\n\nThis is wrong because the map function returns a `String[]`. So we get a `Stream<String[]>` instead of `Stream<String>`. To solve this problem, we can use flatMap:\n``` Java\nList<String> words = Arrays.asList(\"Hello\", \"World\");\n\nwords.stream()\n     .map(s -> s.split(\"\"))\n     .flatMap(Arrays::stream)\n     .distinct()\n     .forEach(System.out::println);\n\n// ============== Output：===============\n// H\n// e\n// l\n// o\n// W\n// r\n// d\n```\n\nThe effect of using flatMap method is that each array is not mapped to a stream, but to the contents of the stream. In a nutshell, flatMap lets you convert each value in a stream to another stream, then join all the streams into one stream.\n\n### Find and match\nAnother common data processing method is to see if certain elements in the dataset match a given condition. The Stream API provides such tools through `allMatch`, `anyMatch`, `noneMatch`, `findFirst`, and `findAny` methods.\n\nThe function name is very self-explanatory. Let see some examples\n\nTo check if a collection contains even numbers:\n``` Java\nList<Integer> numbers = Arrays.asList(1, 2, 3);\n\nif (numbers.stream().anyMatch(x -> x % 2 == 0)) {\n    System.out.println(\"Yes\");\n} else {\n    System.out.println(\"No\");\n}\n\n// ============== Output：===============\n// Yes\n```\n\nTo find the first number in the list that it's square can be divided by 3\n``` Java\nList<Integer> numbers2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\n\nOptional<Integer> goodNumber = numbers2.stream()\n    .map(x -> x * x)\n    .filter(x -> x % 3 == 0)\n    .findFirst();\n\nSystem.out.println(goodNumber.get()); \n\n// ============== Output：===============\n// 9\n```\n\n### Reduce\nWe might need to complete more complext task, such as “Choose the longest word in a word” or “Calculate the total length of all words”. Such queries need to repeatedly combine the elements in the stream to get the final value. Such a query can be classified as a reduction operation (reducing the stream to a value).\n\nTo calculate the sum of an array:\n``` Java\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\nint sum = numbers.stream().reduce(0, (a, b) -> a + b);\n        \n// ============== Output：===============\n// 15\n```\n\nReduce returns the result every time and operates the result with the next element, such as the first time when traversing to element 1, returning the initial value 0 + 1 = 1, then using the return value of 1 and the second element 2, and so on, until the summation of the list of numbers is completed.\n\n### Intermediate and terminal operation\nAll operations on the Stream API fall into two categories: intermediate operations and terminal operations. The intermediate operation is just a kind of markup, and only the terminal operation will trigger the actual calculation.\n\n**Intermediate operations** can be divided into *stateless* and *stateful*. *Stateless* intermediate operations mean that the processing of elements is not affected by the previous elements, and *stateful* intermediate operations must wait until all elements are processed. For example, sorting is a stateful operation, and the sorting result cannot be determined until all elements are read.\n\n**The terminal operation** can be divided into *short-circuit* operation and *non-short-circuit* operation. The short-circuit operation means that the result can be returned without processing all the elements, such as finding the first element that satisfies the condition.\n\nA stream pipeline consists of a stream source, followed by zero or more intermediate operations, and a terminal operation.\n\n## To summarize the Stream API:\nA stream pipeline consists of a stream source, followed by zero or more intermediate operations, and a terminal operation.\n\n<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg .tg-axxb{font-weight:bold;background-color:#c0c0c0;color:#000000;border-color:inherit;text-align:center;vertical-align:top}\n.tg .tg-n9g5{background-color:#ffffff;color:#000000;border-color:inherit;text-align:left;vertical-align:middle}\n.tg .tg-x5q1{background-color:#ffffff;color:#000000;border-color:inherit;text-align:center;vertical-align:middle}\n.tg .tg-mq6t{background-color:#ffffff;color:#000000;border-color:inherit;text-align:left;vertical-align:middle}\n</style>\n<table class=\"tg\">\n  <tr>\n    <th class=\"tg-axxb\" colspan=\"4\">Stream API</th>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"11\">Intermediate<br>Operation</td>\n    <td class=\"tg-x5q1\" rowspan=\"7\">Stateless</td>\n    <td class=\"tg-n9g5\">unordered()<br></td>\n    <td class=\"tg-n9g5\">If order doesn't matter, then can use unordered() together with parallel() to speed up</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">filter()</td>\n    <td class=\"tg-n9g5\">Filter out elements in the stream based on a filter function</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">map()</td>\n    <td class=\"tg-n9g5\">Map stream to another stream based on a map function</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">mapToInt()<br>mapToLong()<br>mapToDouble()</td>\n    <td class=\"tg-mq6t\">Map to int, long or double</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">flatMap()</td>\n    <td class=\"tg-n9g5\">Make [[\"ABC\", \"DEF\"], [\"FGH\", \"IJK\"]] into [\"ABC\", \"DEF\", \"FGH\", \"IJK\"]：</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">flatMapToInt()<br>flatMapToLong()<br>flatMapToDouble()</td>\n    <td class=\"tg-mq6t\">Similar to mapToInt(), mapToLong(), mapToDouble()</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">peek()</td>\n    <td class=\"tg-n9g5\">Performs specified operation on each element of the stream and returns a new stream which can be used further.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"4\">Stateful</td>\n    <td class=\"tg-n9g5\">distinct()</td>\n    <td class=\"tg-n9g5\">Filter out duplicate element in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">sorted()</td>\n    <td class=\"tg-n9g5\">Sort the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">limit()</td>\n    <td class=\"tg-n9g5\">Limit the number of elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">skip()</td>\n    <td class=\"tg-n9g5\">Skip certain number of elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"13\">Terminal<br>Operation</td>\n    <td class=\"tg-x5q1\" rowspan=\"5\">short-circuit<br></td>\n    <td class=\"tg-n9g5\">anyMatch()</td>\n    <td class=\"tg-n9g5\">Return if any element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">allMatch()</td>\n    <td class=\"tg-n9g5\">Return if all element in the stream that satisfies the condition </td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">noneMatch()</td>\n    <td class=\"tg-n9g5\">Return if no element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">findFirst()</td>\n    <td class=\"tg-n9g5\">Find first element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">findAny()</td>\n    <td class=\"tg-n9g5\">Find any element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"8\">non-short-circuit</td>\n    <td class=\"tg-n9g5\">forEach()</td>\n    <td class=\"tg-n9g5\">Iterate all elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">forEachOrdered()</td>\n    <td class=\"tg-n9g5\">Iterate all elements in the stream by order. Can't make use of parallel()</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">toArray()</td>\n    <td class=\"tg-n9g5\">Return an array of all elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">reduce()</td>\n    <td class=\"tg-n9g5\">Reduce all elements to one results based on given function</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">collect()</td>\n    <td class=\"tg-n9g5\">Process the elements in the stream and get all values</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">max()</td>\n    <td class=\"tg-n9g5\">Find max element in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">min()</td>\n    <td class=\"tg-n9g5\">Find min element in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">count()</td>\n    <td class=\"tg-n9g5\">Get number of element in the stream</td>\n  </tr>\n</table>","tags":["Stream API"],"categories":["Java"]},{"title":"How to deploy Hexo blog to Github pages","url":"/How-to-deploy-Hexo-blog-to-Github-pages/","content":"\nHexo provides fast and easy one-click deployment, supporting [Github Pages](https://pages.github.com), [Netlify](https://www.netlify.com), [OpenShift](https://www.openshift.com) etc. In this post, I will walk through the process of deploying Hexo blog site to [Github Pages](https://pages.github.com).\n\n## Folder structure of Hexo \nBefore discussing the process, I think it is important to understand the folder structure of Hexo. Basically, a Hexo blog site contains the following folders:\n\n* **scaffolds:** Template folder. When you create a new post, Hexo will create a \".md\" file under `source` based on scaffold.\n* **source:** The Resource folder. It is where the user resources are stored. It stores all \".md\" files which would be rendered to html pages.\n* **themes:** Stores all theme files.\n* **public** This is where all rendered files comes in. When deploying, we need this folder to get to the Github repository so that Github pages can host it.\n\nNow let's look at how to deploy the blog site to Github Pages.\n\n## Install hexo-deployer-git\n``` bash\nnpm install hexo-deployer-git --save\n```\n\n## Setup Github repository\nLogin GitHub account and create a new repository named username.github.io, where username is the username on GitHub.\n \n * Note that the first part of the repository must exactly match the username, otherwise it won’t work.\n\nRefer to [https://pages.github.com](https://pages.github.com) for more details.\n\n## Change config file\nAdd the following lines to `_config.yml`:\n\n```\ndeploy:\n  type:    git\n  repo:    <repository url> #e.g. https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io\n  branch:  [branch]         #branch name, default is 'master'\n  message: [message]        #commit message, default is 'Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}'\n```\n\n## Generate site files and push to remote repository\n``` bash\nhexo clean\nhexo deploy\n```\n\nWait for a couple of minutes, then visit username.github.io, the blog site should be visiable!\n\n## How does it works\nWhen hexo deploy is executed, Hexo pushes the files and directories in the `public` folder to the remote repositories and branches specified in `_config.yml` and completely overwrites the existing content under that branch.","tags":["hexo"],"categories":["how-to-guide"]},{"title":"How to build a blog with hexo","url":"/How-to-build-a-blog-with-hexo/","content":"\nHexo is a blog framework powered by Node.js. I recently built my blog with it and found it extremely easy and fast. The posts are written in Markdown and Hexo will generates static files in seconds. \n\nIn this post I will walk through the steps to setup a blog running locally. There will be another post discussing deploy the blog site to Github page. Here I will only discuss how to install Hexo blog on MacOS. For installation on other platforms such as Windows, please refer to other online posts like [https://www.how2shout.com/how-to/install-hexo-nodejs-blog-on-windows-10-with-github.html](https://www.how2shout.com/how-to/install-hexo-nodejs-blog-on-windows-10-with-github.html)\n\n## Requirems to install Hexo\n* [Node.js](https://nodejs.org/en/)\n* [Git](https://git-scm.com)\n\n## Install Node.js\nRun this script in the terminal:\n``` bash\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | sh\n```\n\nEdit zsh config to load nvm each time:\n\n``` bash\nvi ~/.zshrc\n```\n\nAdd: `[[ -s $HOME/.nvm/nvm.sh ]] && . $HOME/.nvm/nvm.sh` to the end of the file\n\nThen run the command to install node.js\n``` bash\nnvm install node\n```\n\nAfter the script finishes running, you should see the following output, which means node.js is all set. Great!\n\n{% asset_img node-success.png %}\n\n## Install Git\nNext is install Git so you can checkout code from source repositry. On Mac the easiest way is to use [HomeBrew](https://brew.sh). You can install Brew with one line of command:\n\n``` bash\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\nAfter Brew is installed, use it to install Git:\n\n``` bash\nBrew install git\n```\n\n## Install Hexo\nWith Node.js and Git all set, you can install Hexo run the following  command\n\n``` bash\nnpm install -g hexo-cli\n```\n\n## Create a blog site\nNow it comes to the moment when you are able to create the blog site. Simply run:\n\n``` bash\nhexo init my-blog\ncd my-blog\nhexo install\n```\n\nHexo will download and create all necessary files to 'my-blog' folder. \n\n## Run the Hexo server\nEverything is ready and you can run the Hexo server to view your blog site!\n\n``` bash\nhexo server\n```\n\nVisit [http://localhost:4000](http://localhost:4000) and you should be able to see the webpage show up\n\n{% asset_img blog-page.png %}\n\n\nCongraturations! You have a blog site up and running. You can create a post using `hexo new post \"Blog title\"`. You can also change the themes and add plugins to the site.","tags":["hexo"],"categories":["how-to-guide"]}]
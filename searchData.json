[{"title":"Leetcode 19. Remove Nth Node From End of List","url":"/Leetcode-19-Remove-Nth-Node-From-End-of-List/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven a linked list, delete the nth node from the end.\n\n## Solution - 2 Pass\nDeleting a node is nothing more than traversing the linked list and find the node in front of the node to be deleted. However because it is a linked list, we don't know its length. So we have to traverse the list first to get its length, then subtract `n` from the length to find the position of the node to be deleted.\n\n``` Java\npublic ListNode removeNthFromEnd(ListNode head, int n) {\n    int length = 0;\n    ListNode node = head;\n\n    while (node != null) {\n        length++;\n        node = node.next;\n    }\n\n    // only 1 node in the list\n    if (length == 1) {\n        return null;\n    }\n\n    // index to remove, start from 0\n    int indexToRemove = length - n;\n\n    node = head;\n    // move to the previous node\n    for (int i = 0; i < indexToRemove - 1; i++) {\n        node = node.next;\n    }\n\n    node.next = node.next.next;\n\n    return head;\n}\n```\n\nTime complexity: assuming the length of the linked list is `L`, then the first loop is `L` times, and the second loop is `L-n` times, for a total of `2L-n` times, so the time complexity is O (L).\n\nSpace complexity: O (1).\n\n## Solution - 1 Pass\nSo how can we traverse the list only once?\n\nWe set two pointers, let the first pointer traverse forward `n` steps, and then let them both traverse at the same time. In this case, when the first pointer reaches the end, the second pointer is `n` steps from the head. So the position of the second pointer is exactly the nth node from the head.\n\n``` Java\npublic  ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode dummyNode = new ListNode(0);\n    dummyNode.next = head;\n\n    ListNode pointer1 = dummyNode;\n    ListNode pointer2 = dummyNode;\n\n    // move first pointer ahead n steps\n    for (int i = 0; i <= n; i++) {\n        pointer1 = pointer1.next;\n    }\n\n    while (pointer1 != null) {\n        pointer1 = pointer1.next;\n        pointer2 = pointer2.next;\n    }\n\n    // now pointer2 is the node before the node to be delete\n    pointer2.next = pointer2.next.next;\n\n    return dummyNode.next;\n}\n```\n\nTime complexity:\n\nThe first pointer goes from 0 to n, then \"the first pointer goes from n to the end\" and \"the second pointer goes from 0 to the position of the n-th node down\" simultaneously.\n\nThe previous solution is nothing more than going from 0 to the end, and then going from 0 to the position of the n-th node.\n\nSo in fact, the number of times their statements are executed is the same. The position of the n-th node from 0 to the penultimate point is traversed twice, so the total is `2L-n` times. It's just that this solution combines the two loops of solution one, so that the second pointer seems to traverse by the way, the idea is very nice.\n\nSo in essence, they are actually the same, and the time complexity is still O(n).\n\nSpace complexity: O (1).","tags":["Leetcode - Two Pointers","Leetcode - Linked List"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 9: Distributed Tracing Solution - Sleuth","url":"/Spring-Cloud-9-Distributed-Tracing-Solution-Sleuth/","content":"When we develop microservice application, we usually divide microservices according to business logic, and call each business through REST. A user operation may require the cooperation of many microservices to complete. If any microservice has problems or the network times out, it will cause the function to fail. With more and more services, the analysis of the call chain between microservices will become more and more complicated.\n\n`Spring Cloud Sleuth` provides link tracking for calls between services. Through `Sleuth`, you can clearly understand which services a request has passed, and how long each service process takes, so that we can easily sort out the calling relationship between microservices. In addition `Sleuth` can help us:\n\n* Time-consuming analysis: with `Sleuth` we can easily understand the time-consuming of each sampling request, so as to analyze which service calls are time-consuming;\n* Errors visualization: for exceptions not caught by the program, you can see them through the integrated `Zipkin` service interface;\n* Link optimization: For services that are called frequently, some optimization measures can be implemented for these services.\n\n## Sleuth+Log Example\nWe first integrate `Sleuth` in the simplest way and output the information tracked by `Sleuth` to the log.\n\n### Modify Product-Service-Consumer\n#### Add bootstrap.properties file\nIn order to enable the log file to obtain the service name, we need to move part of the original configuration in `application.properties` into the `bootstrap.properties` configuration file. This is because Spring Boot will preferentially scan the bootstrap configuration source when starting, so that the log can get the service name.\n\n``` Xml\nserver.port=9090\n\nspring.application.name=PRODUCT-SERVICE-CONSUMER\n```\n\n#### Modify application.properties\n``` Xml\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n\nfeign.hystrix.enabled=true\n\nmanagement.endpoints.web.exposure.include=hystrix.stream\n\nlogging.level.org.springframework=INFO\nlogging.level.org.springframework.web.servlet.DispatcherServlet=DEBUG\n```\n\nNote here to modify the log level of `DispatcherServlet` to `DEBUG`.\n\n#### Modify Logback configuration file\nAdd a file named `logback-spring.xml` to the `resources` directory with the following content:\n``` Xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<configuration>\n    <include resource=\"org/springframework/boot/logging/logback/defaults.xml\"/>\n    ​\n    <springProperty scope=\"context\" name=\"springAppName\" source=\"spring.application.name\"/>\n\n    <!-- Example for logging into the build folder of your project -->\n    <property name=\"LOG_FILE\" value=\"${BUILD_FOLDER:-build}/${springAppName}\"/>​\n\n    <property name=\"CONSOLE_LOG_PATTERN\"\n              value=\"%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p})\n            %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}\"/>\n\n    <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <layout class=\"ch.qos.logback.classic.PatternLayout\">\n            <Pattern>\n                %d{yyyy-MM-dd HH:mm:ss SSS} [%thread] %-5level %logger{36} - %msg%n\n            </Pattern>\n        </layout>\n    </appender>\n\n    <!-- Appender to log to console -->\n    <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\">\n            <!-- Minimum logging level to be presented in the console logs-->\n            <level>DEBUG</level>\n        </filter>\n        <encoder>\n            <pattern>${CONSOLE_LOG_PATTERN}</pattern>\n            <charset>utf8</charset>\n        </encoder>\n    </appender>\n\n    <!-- Appender to log to file -->​\n    <appender name=\"flatfile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <file>${LOG_FILE}</file>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            <fileNamePattern>${LOG_FILE}.%d{yyyy-MM-dd}.gz</fileNamePattern>\n            <maxHistory>7</maxHistory>\n        </rollingPolicy>\n        <encoder>\n            <pattern>${CONSOLE_LOG_PATTERN}</pattern>\n            <charset>utf8</charset>\n        </encoder>\n    </appender>\n    ​    ​\n    <root level=\"INFO\">\n        <appender-ref ref=\"console\"/>\n        <!-- uncomment this to have also JSON logs -->\n        <!--<appender-ref ref=\"logstash\"/>-->\n        <!--<appender-ref ref=\"flatfile\"/>-->\n    </root>\n</configuration>\n```\n\n#### Add dependency\n``` Xml\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-sleuth</artifactId>\n</dependency>\n```\n\n> As mentioned in the SpringCloud reference manual: `SLF4J MDC` is always set automatically, and if logback is used, the trace/span id is immediately displayed in the log. Other log systems need to be configured to achieve this effect. The default `logging.pattern.level` is set to%clr(% 5p)%clr([${spring.application.name:},%X{X-B3-TraceId:-},%X{X-B3-SpanId: -},% X {X-Span-Export:-}]) {yellow} (This is also a feature of `Spring Boot` when integrating logback). This means that if you do not need to manually configure the format when using SLF4J, other log systems must be manually configured, otherwise they will not be output.\n\n### Modify Product-Service\nSame as above\n\n### Test\nStart the `Service-discovery`, `Product-Service`, and `Product-Service-Consumer` in order. Visit: http://localhost:9090/products. Then we observe the log output in the `Product-Service-Consumer` and `Product-Service` consoles, and we can see output similar to the following:\n\n```\n2020-02-16 22:14:14.937 DEBUG [PRODUCT-SERVICE,71fb907c61436aff,d572b78867aa38a1,false]             3422 --- [nio-2100-exec-2] o.s.web.servlet.DispatcherServlet        : GET \"/products\", parameters={}\n```\n\n```\n2020-02-16 22:14:15.012 DEBUG [PRODUCT-SERVICE-CONSUMER,71fb907c61436aff,71fb907c61436aff,false]             3428 --- [nio-9090-exec-1] o.s.web.servlet.DispatcherServlet        : Completed 200 OK\n```\n\nThe format of the log content is: [appname, traceId, spanId, exportable], which is `Sleuth`'s trace data. among them:\n* **appname**: the service name of the microservice;\n* **traceId/spanId**: Two terms for Sleuth link tracking. We will introduce them in detail later.\n* **whether exportable is sent to Zipkin**.\n\n## Sleuth Terminology\nBecause Sleuth is based on Google’s [Dapper](https://research.google/pubs/pub36356/)’s paper, it also borrows Dapper in terminology.\n\n* **Span**: The most basic unit of work. For example: Sending an RPC is a new `span`, and so is an RPC response. `Span` uses a unique 64-bit ID for identification. In addition, a 64-bit ID is used for service call tracking. `Span` can also carry other data, such as: description, timestamp, tag of key-value pair, ID of starting `Span`, and processing ID (usually using IP address), etc. `Span` has start and end, they are used to track time information. `Span` should appear in pairs, beginning and ending, so once a `span` is created, it must be ended at some point in the future.\n\n> Note: The starting span is usually called the: `root span`. Its id is usually used as the id of a track record.\n\n* **Trace**: A tree-structured `Span` collection. For example: In a distributed big data store, each request may be a tracked record.\n\n* **Annotation**: Used to record the time information of an event. Some basic core annotations are used to record the start and end time of the request, for example:\n\n    * **cs**: short for `Client Sent`. This annotation indicates the start of a span;\n    * **sr**: short for `Server Received`. Indicates that the server receives the request and starts processing. The network transmission time can be calculated by subtracted the `cs` \n    * **ss**: the server completes the request processing, and the response information is sent back to the client (abbreviation of `Server Sent`). If you subtract the `sr` timestamp, you can calculate the time it takes for the server to process the request.\n    * **cr**: short for `Client Received`. Marks the end of `Span`. The client successfully received the response from the server. The response time of the request can be calculated by subtract the `cs`.\n\nThe following figure(https://cloud.spring.io/spring-cloud-sleuth/reference/html/) describes the concepts of `Span` and `Trace` in a visual way:\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nEach color in the picture represents a `span` (a total of 7 spans, from A to G). They all have the following data information:\n```\nTrace Id = X\nSpan Id = D\nClient Sent\n```\n\nWhich means he `Trace-Id` of the Span is `X`, and `Span-Id` of the Span is `D`, The corresponding event is `Client Sent`.\n\nThe subordinate relationships of these spans can be represented by the following figure (https://cloud.spring.io/spring-cloud-sleuth/reference/html/):\n{% asset_img 2.png %}\n<br/>\n<br/>\n\n## Integrate Zipkin services\n`Zipkin` is a distributed tracking system dedicated to collecting time data for distributed services. It mainly involves the following four components:\n* **collector**: data collection;\n* **storage**: data storage;\n* **search**: data query;\n* **UI**: Data display.\n\n`Zipkin` provides pluggable data storage methods: `In-Memory`, `MySql`, `Cassandra`, and `Elasticsearch`. The next test is to conveniently use the `In-Memory` method for storage. I personally recommend `Elasticsearch`, especially when we need to integrate `ELK` in the future.\n\n`Zipkin`'s source code on Github is: https://github.com/openzipkin/zipkin.\n\n> `Zipkin` requires JDK8 support.\n\nIn this article, we only provide tracking data to `Zipkin` through Http. I will explain it later when we talk about `Spring Cloud Bus` using the stream method.\n\n### 1. Zipkin-Server\nNote that now custom `zipkin` server is no longer supported. Refer to [Quick-start](https://github.com/openzipkin/zipkin) for starting the `zipkin` server instance.\n\n```\ncurl -sSL https://zipkin.io/quickstart.sh | bash -s\njava -jar zipkin.jar\n```\n\nThe default address is: http://localhost:9411/zipkin/.\n\n### 2. Modify Product-Service-Consumer\n#### Modify pom.xml\n\nAdd dependency:\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-zipkin</artifactId>\n</dependency>\n```\n\nAnd remove:\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-sleuth</artifactId>\n</dependency>\n```\n\nThis is because `spring-cloud-starter-sleuth` dependency is already included in `spring-cloud-starter-zipkin`.\n\n#### Modify application.properties\nAdd the following to application.properties:\n```\nspring.zipkin.base-url=http://localhost:9411\nspring.sleuth.sampler.percentage=1.0\n```\n\n`spring.zipkin.base-url` specifies the address of the `Zipkin` server, `spring.sleuth.sampler.percentage` sets the sampling ratio to 1.0, which is all required. About sampling can refer to the later description.\n\n### Modify Product-Service\nSame as above\n\n### Test\nStart the `Service-discovery`, `Zipkin-Server`, `Product-Service`, and `Product-Service-Consumer` projects in order.\n\n#### Check Zipkin server\nVisit: http://localhost:9411, can see the following:\n{% asset_img 3.png %}\n<br/>\n<br/>\n\n#### Visit Product-Service-Consumer to generate service calls\nWe visit the service provided by Mall-Web several times in the browser, and then go to the Zipkin server, you can see the following interface:\n{% asset_img 4.png %}\n<br/>\n<br/>\n\nWe can see that `Zipkin` has obtained several service call tracking information. We can click on one of these requests and see the following interface:\n{% asset_img 5.png %}\n<br/>\n<br/>\n\nThis interface presents the request in more detail. Similarly, we can click again to view more detailed data, we can see the following interface:\n{% asset_img 6.png %}\n<br/>\n<br/>\n\nIn this interface we can see the various time tracking information mentioned earlier.\n\nIn the Zipkin interface, we can also click `Dependencies` to view the dependencies between services, as shown below:\n{% asset_img 7.png %}\n<br/>\n<br/>\n\n#### Error message\n`Zipkin` can display error messages in trace records. When the exception is thrown and not caught, `Zipkin` will automatically change colors. In the list of trace records, when you see the red record, it means that an exception was thrown. As shown in the first figure above, the error message is displayed based on the data. We can also click into it for more detailed error information.\n\nCheck out the source code here: [Sleuth demo](https://github.com/nicklee1006/SpringCloudDemo/tree/sleuth-demo)","categories":["Spring Cloud"]},{"title":"Leetcode 49. Group Anagrams","url":"/Leetcode-49-Group-Anagrams/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven multiple strings, categorize them. As long as the strings contain exactly the same characters, they are counted as the same class, regardless of order.\n\n### Similar Questions\n* Easy - [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)\n\n## Solution \nWe can sort each string alphabetically, then we can map `eat`, `tea`, `ate` to `aet`. Others are similar.\n\n``` Java\nHashMap<String, List<String>> map = new HashMap<>();\n\n// loop all strings\nfor (String str : strs) {\n    char[] charArray = str.toCharArray();\n\n    // sort\n    Arrays.sort(charArray);\n\n    String key = new String(charArray);\n\n    if (map.containsKey(key)) {\n        map.get(key).add(str);\n    } else {\n        List<String> tempList = new ArrayList<>();\n        tempList.add(str);\n\n        map.put(key, tempList);\n    }\n}\n\nreturn new ArrayList<>(map.values());\n```","tags":["Leetcode - Hash Table","Leetcode - String"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 98. Validate Binary Search Tree","url":"/Leetcode-98-Validate-Binary-Search-Tree/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven a tree, determine if the tree is a valid binary search tree. The binary search tree is defined as follows:\n\n* If the left subtree of any node is not empty, the values of all nodes on the left subtree are less than the value of its root node;\n* If the right subtree of any node is not empty, the value of all nodes on the right subtree is greater than the value of its root node;\n* The left and right subtrees of any node are also binary search trees;\n* There are no nodes with equal key values.\n\n### Similar Question\n* Medium - {% post_link Leetcode-94-Binary-Tree-Inorder-Traversal '94. Binary Tree Inorder Traversal' %}\n* Easy - [501. Find Mode in Binary Search Tree](https://leetcode.com/problems/find-mode-in-binary-search-tree/)\n\n## Solution - Recursion\nThe idea is that the left subtree is a legal binary search tree, the right subtree is a legal binary search tree, and the root node is larger than the largest number in the left subtree and smaller than the smallest number in the right subtree, then the current tree is a legal binary search tree\n\n## Solution - DFS\nIn previous solution, we are judging whether the root node is legal and found the largest number in the left subtree and the smallest number in the right subtree. The left and right subtrees determine whether the current root node is valid.\n\nBut normally, the root node comes first, it is reasonable to say that the root node could be any number rather than limited by the left and right subtrees. On the contrary, the root node determines the legal value range of the left and right subtree.\n\nTherefore, we can do DFS from the root node, then calculate the value range that each node should take, and return false if the current node does not match.\n\n```\n      10\n    /    \\\n   5     15\n  / \\    /  \n 3   6  7 \n\nConsider 10's range\n    10(-inf,+inf)\n\nConsider 5's range\n    10(-inf,+inf)\n    /\n5(-inf,10)\n\nConsider 3's range\n    10(-inf,+inf)\n     /\n   5(-inf,10)\n    /\n  3(-inf,5)  \n\nConsider 6's range\n    10(-inf,+inf)\n     /\n   5(-inf,10)\n    /       \\\n3(-inf,5)  6(5,10)\n\nConsider 15's range\n    10(-inf,+inf)\n    /          \\\n   5(-inf,10) 15(10,+inf）\n    /       \\\n3(-inf,5)  6(5,10)  \n\nConsider 7's range, if not match return false\n        10(-inf,+inf)\n         /           \\\n    5(-inf,10)     15(10,+inf）\n  /       \\           /\n3(-inf,5)  6(5,10)  7（10,15）\n```\n\nIt can be observed that the range of the left child is (left boundary of the parent node, the value of the parent node), and the range of the right child is (value of the parent node, the right boundary of the parent node).\n\nWe can pass Integer object, then null means negative infinity and positive infinity. Then use JAVA's auto boxing and unboxing, the value comparison can be directly used inequality sign.\n\n``` Java\npublic boolean isValidBST(TreeNode root) {\n    return isValid(root, null, null);\n}\n\n// every number has a valid range\n// For node on left tree: (min of parent node, value of parent node)\n// For node on right tree: (value of parent node, max of parent node)\nprivate boolean isValid(TreeNode node, Integer min, Integer max) {\n    if (node == null) {\n        return true;\n    }\n\n    if (min != null && node.val <= min) {\n        return false;\n    }\n\n    if (max != null && node.val >= max) {\n        return false;\n    }\n\n    return isValid(node.left, min, node.val) && isValid(node.right, node.val, max);\n}\n```","tags":["Leetcode - Tree","Leetcode - Depth First Search"],"categories":["Data Structure and Algorithms"]},{"title":"Java Bit Operations","url":"/Java-Bit-Operations/","content":"All data is stored in binary form in the computer. Bit operations are actually operations on the binary data in memory, so the data processing speed is very fast.\n\n## Bit operation basics\nThere are 6 basic bit operators: `And`, `Or`, `XOR`, `Complement`, `Left Shift`, and `Right Shift`. Their operation rules are as follows:\n\n<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle}\n.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n</style>\n<table class=\"tg\">\n  <tr>\n    <th class=\"tg-c3ow\">Symbol</th>\n    <th class=\"tg-c3ow\">Description</th>\n    <th class=\"tg-c3ow\">Rule</th>\n  </tr>\n  <tr>\n    <td class=\"tg-9wq8\">&amp;</td>\n    <td class=\"tg-9wq8\">And</td>\n    <td class=\"tg-0pky\">The result is 1 when both bits are 1</td>\n  </tr>\n  <tr>\n    <td class=\"tg-9wq8\">|</td>\n    <td class=\"tg-9wq8\">Or</td>\n    <td class=\"tg-0pky\">The result is 0 when both bits are 0</td>\n  </tr>\n  <tr>\n    <td class=\"tg-9wq8\">^</td>\n    <td class=\"tg-9wq8\">Xor</td>\n    <td class=\"tg-0pky\">0 if both bits are the same, 1 if they are different</td>\n  </tr>\n  <tr>\n    <td class=\"tg-9wq8\">~</td>\n    <td class=\"tg-9wq8\">Complement</td>\n    <td class=\"tg-0pky\">0 becomes 1, 1 becomes 0</td>\n  </tr>\n  <tr>\n    <td class=\"tg-9wq8\">&lt;&lt;</td>\n    <td class=\"tg-9wq8\">Left shift</td>\n    <td class=\"tg-0pky\">Each binary is shifted to the left by several bits, the high bits are discarded, and the low bits are padded with 0.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-9wq8\">&gt;&gt;</td>\n    <td class=\"tg-9wq8\">Right shift</td>\n    <td class=\"tg-0pky\">Each binary bit is shifted to the right by several bits. <br>Unsigned numbers, high-order bits are complemented with 0, and signed numbers. <br>Each compiler handles the method differently. <br>Some complement bits (arithmetic right shift), and some complement 0 (logical right shift).</td>\n  </tr>\n</table>\n\nNote:\n* Of these 6 operators, only `~` complement is a monocular operator, and the other 5 are binocular operators.\n* Bit operations can only be used for integer data. Bit operations on float and double types will be reported by the compiler as errors.\n* The bit operator has a lower precedence, so try to use parentheses to ensure the order of operations, otherwise you may get some inexplicable results. For example, to get `2^i + 1` numbers like 1, 3, 5, and 9. It is wrong to write `int a = 1 << i + 1`; Should be written as `int a = (1 << i) + 1`;\n\n### And (&)\n``` Java\nSystem.out.println(5 & 3);\n\n// Output: 1\n```\n\n5 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0101\n3 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0011\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------------------------\n1 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0001\n\n### Or (|)\n``` Java\nSystem.out.println(5 | 3);\n\n// Output: 7\n```\n\n5 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0101\n3 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0011\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------------------------\n7 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0111\n\n### Xor(^)\n``` Java\nSystem.out.println(5 ^ 3);\n\n// Output: 6\n```\n\n5 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0101\n3 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0011\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------------------------\n6 convert to binary: 0000 0000 0000 0000 0000 0000 0000 0110\n\n### Complement (~)\n``` Java\nSystem.out.println(~5);\n\n// Output: -6\n```\n\n5 convert to binary: &nbsp;&nbsp;0000 0000 0000 0000 0000 0000 0000 0101\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------------------------\n-6 convert to binary: 1111 1111 1111 1111 1111 1111 1111 1010\n\n### Left shift (<<)\n``` Java\nSystem.out.println(5<<2);\n\n// Output: 20\n```\n\n5 convert to binary: &nbsp;&nbsp;0000 0000 0000 0000 0000 0000 0000 0101\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------------------------\n20 convert to binary: 0000 0000 0000 0000 0000 0000 0001 0100\n\n### Right shift (>>)\n``` Java\nSystem.out.println(5>>2);\n\n// Output: 1\n```\n\n5 convert to binary: &nbsp;&nbsp;0000 0000 0000 0000 0000 0000 0000 0101\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----------------------------------------------------------\n1 convert to binary: `00`00 0000 0000 0000 0000 0000 0000 0001\n\n## Common bit manipulation tips\n### Judging parity\nJust need to check the least significant bit is 0 or 1, 0 is even and 1 is odd. So we can use `if((a & 1) == 0)` instead of `if(a% 2 == 0)` to determine whether `a` is even. The following program will output all even numbers between 0 and 100:\n``` Java\nfor (int i = 0; i < 100; i ++) {\n    if ((i & 1) == 0) {\n        System.out.println(i);\n    }\n}\n```\n\n### Exchange two numbers\n``` Java\nint a = 1, b = 2;\na ^= b;\nb ^= a;\na ^= b;\n\nSystem.out.println(\"a  = \" + a);\nSystem.out.println(\"b = \" + b);\n\n// output\n// a = 2\n// b = 1\n```\n\n1. The first step `a^ = b` is `a = (a^b)`;\n2. The second step `b^ = a` is `b = b^(a^b)`. Since the OR operation satisfies the commutative law, `b^(a^b)` = `b^b^a`. Since the result of OR of a number and itself is 0 and the OR of any number and 0 is unchanged, `b` is assigned the value of `a`\n3. The third step `a^ = b` is `a = a^b`. Since the previous two steps show that `a = (a^b)` and `b = a`, `a = a^b` is `a = (a^b)^a`. So `a` is assigned the value of `b`.\n\n### Changing the sign\nChanging the sign means that positive numbers become negative numbers, and negative numbers become positive numbers. For -11 and 11, you can use the following transformation method to change -11 to 11\n\n```\n/ 11\n[0000 1011] Complement(~)-> [1111 0100]-> Add 1-> [1111 0101] (-11)\n\n// -11\n[1111 0101] Complement(~)-> [0000 1010]-> Add 1-> [0000 1011] (11)\n```\n\nSo we only need to complement the number and add 1.\n\n``` Java\nint a = -15, b = 15;\nSystem.out.println(~a + 1);\nSystem.out.println(~b + 1);\n```\n\n### Bit manipulation tips\n``` Java\n// 1. Get int max\nSystem.out.println((1 << 31) - 1); \nSystem.out.println(~(1 << 31));\n\n// 2. Get int min\nSystem.out.println(1 << 31);\nSystem.out.println(1 << -1);\n\n// 3. Get long max\nSystem.out.println(((long)1 << 127) - 1);\n\n// 4. times 2 operation\nSystem.out.println(10<<1);\n\n// 5. Divide by 2 (negative and odd operations are not available)\nSystem.out.println(10>>1);\n\n// 6. Multiplied by 2 to the power of m\nSystem.out.println(10<<2);\n\n// 7. Divide by 2 to the power of m\nSystem.out.println(16>>2);\n\n// 8. Determine the parity of a number\nSystem.out.println((10 & 1) == 1);\nSystem.out.println((9 & 1) == 1);\n\n// 9. Exchange two variables without temporary variables (interview quiz)\na ^= b;\nb ^= a;\na ^= b;\n\n// 10. Take the absolute value (on some machines, the efficiency is higher than n > 0? n: -n)\nint n = -1;\nSystem.out.println((n ^ (n >> 31)) - (n >> 31));\n/* \nn >> 31 gets the sign of n, if n is positive, n >> 31 is equal to 0, if n is negative, n >> 31 is equal to -1\nIf n is a positive number, n ^ 0-0 is unchanged. If n is a negative number n ^ -1, the complement of n and -1 needs to be calculated.\nResult n changes sign and subtracts 1 from the absolute value, minus -1 is the absolute value \n*/\n\n// 11. Take the maximum of two numbers (on some machines, the efficiency is higher than a > b? a : b)\nSystem.out.println(b&((a-b)>>31) | a&(~(a-b)>>31));\n\n// 12. Take the minimum of two numbers (on some machines, the efficiency is higher than a > b? b : a)\nSystem.out.println(a&((a-b)>>31) | b&(~(a-b)>>31));\n\n// 13. Determines whether the signs are the same (true means x and y have the same sign, false means x, y have the opposite sign.)\nSystem.out.println((a ^ b) > 0);\n\n// 14. Calculate the nth power of 2> 0\nSystem.out.println(2<<(n-1));\n\n// 15. Determine whether a number n is a power of two\nSystem.out.println((n & (n - 1)) == 0);\n/* If it is a power of 2, n must be 100 ... n-1 is 1111 ....So the result of the AND operation is 0 */\n\n// 16. Average two integers\nSystem.out.println((a+b) >> 1);\n\n// 17. From low to high, take the mth bit of n\nint m = 2;\nSystem.out.println((n >> (m-1)) & 1);\n\n// 18. From low to high. Set the mth bit of n to 1.\nSystem.out.println(n | (1<<(m-1)));\n/*\nShift 1 to the left by m-1 bits to find the mth bit, and get 000 ... 1 ... 000\nOr n with this number\n*/\n\n// 19. From low to high, set the mth bit of n to 0\nSystem.out.println(n & ~(0<<(m-1)));\n/* \nShift 1 to the left by m-1 bits to find the m-th bit, and invert it to 111 ... 0 ... 1111\nAND n and the number again\n*/\n```\n","categories":["Java"]},{"title":"Leetcode 94. Binary Tree Inorder Traversal","url":"/Leetcode-94-Binary-Tree-Inorder-Traversal/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nIn-order traversal of a binary tree.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-98-Validate-Binary-Search-Tree '98. Validate Binary Search Tree' %}\n* Medium - [144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\n* Medium - [145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)\n* Medium - [173. Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)\n* Medium - [230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)\n* Medium - [783. Minimum Distance Between BST Nodes](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)\n\n## Solution - Recursive\nUsing recursion to traverse a binary tree. This is one of the standard approach.\n\n``` Java\npublic List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n\n    getAnswer(root, result);\n\n    return result;\n}\n\n// standard way to traverse tree inorder. Recursive\nprivate static void getAnswer(TreeNode node, List<Integer> result) {\n    if (node == null) {\n        return;\n    }\n\n    getAnswer(node.left, result);\n    result.add(node.val);\n    getAnswer(node.right, result);\n}\n```\n\nTime complexity: O(n), traverse each node.\n\nSpace complexity: O(h), stack consumption, h is the height of the binary tree.\n\n## Solution - Stack\nUse the stack to simulate recursion.\n\nLet's look at an example:\n```\n        1\n      /   \\\n     2     3\n    / \\   /\n   4   5 6\n\n push   push   push   pop     pop    push     pop     pop \n|   |  |   |  |_4_|  |   |   |   |  |   |    |   |   |   |  \n|   |  |_2_|  |_2_|  |_2_|   |   |  |_5_|    |   |   |   |\n|_1_|  |_1_|  |_1_|  |_1_|   |_1_|  |_1_|    |_1_|   |   |\nans                  add 4   add 2           add 5   add 1\n[]                   [4]     [4 2]           [4 2 5] [4 2 5 1]\n \n push   push   pop          pop \n|   |  |   |  |   |        |   |  \n|   |  |_6_|  |   |        |   |  \n|_3_|  |_3_|  |_3_|        |   |\n              add 6        add 3\n              [4 2 5 1 6]  [4 2 5 1 6 3]\n```\n\nCode:\n``` Java\nList<Integer> result = new ArrayList<>();\nStack<TreeNode> stack = new Stack<>();\n\nTreeNode current = root;\nwhile (current != null || !stack.isEmpty()) {\n    // node is not null, push to stack\n    // push left first\n    while (current != null) {\n        stack.push(current);\n\n        current = current.left;\n    }\n\n    // node is null, pop\n    current = stack.pop();\n\n    // add to result\n    result.add(current.val);\n\n    // consider right tree\n    current = current.right;\n}\n\nreturn result;\n```\n\nTime complexity: O(n), traverse each node.\n\nSpace complexity: O(h), stack consumption, h is the height of the binary tree.\n\n## Solution - Morris traversal\n[Morris traversal](https://www.geeksforgeeks.org/morris-traversal-for-preorder/)","tags":["Leetcode - Hash Table","Leetcode - Stack","Leetcode - Tree"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 8: API Gateway - Zuul Part 2","url":"/Spring-Cloud-8-API-Gateway-Zuul-Part-2/","content":"The first impression of `Zuul` is usually like this: it includes two functions: `routing` and `filtering` requests. The routing function is responsible for forwarding external requests to specific microservice instances, which is the basis for achieving a unified entrance to external access. The filter function is responsible for intervening in the processing of requests, and is the basis for implementing functions such as request verification and service aggregation. However, in reality, when the routing function is running, its routing mapping and request forwarding are completed by several different filters. Among them, the route mapping is mainly completed by a `PRE` type filter, which matches the request path with the configured routing rule to find the destination address that needs to be forwarded. The part of the request forwarding is completed by the `Route` type filter, which forwards the routing address obtained by the `PRE` type filter. Therefore, the filter can be said to be the most important core component of `Zuul`'s API gateway. Every request entering `Zuul` will go through a series of filter processing chains to get the request response and return it to the client.\n\n## Filter Introduction\n### 1. Filter characteristics\nThe key features of `Zuul` filters are:\n\n* **Type**: Defines when to be executed during request execution;\n* **Execution Order**: When there are multiple filters, it is used to indicate the order of execution. The smaller the value, the earlier the execution;\n* **Criteria**: the conditions under which the filter will be triggered;\n* **Action**: The specific action.\n\nFilters do not communicate directly, but share information through `RequestContext`, which is `thread-safe`.\n\nCorresponding to the characteristics of the `Zuul` filter above, the methods we need to implement when implementing a custom filter are:\n\n``` Java\npublic class PreTypeZuulFilter extends ZuulFilter {\n    @Override\n    public String filterType() {\n        return PRE_TYPE;\n    }\n\n    @Override\n    public int filterOrder() {\n        return PRE_DECORATION_FILTER_ORDER - 1;\n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    @Override\n    public Object run() {\n        this.logger.info(\"This is pre-type zuul filter.\");\n        return null;\n    }\n}\n```\n\namong them:\n\n* The **filterType()** method is the type of the filter;\n* The **filterOrder()** method returns the execution order;\n* The **shouldFilter()** method is to determine whether the filter needs to be executed;\n* **run()** is the specific filtering action to be performed.\n\n### 2. Filter type\n`Zuul` defines four standard filter types, which correspond to the typical life cycle of a request.\n\n* **PRE filter**: called before the request is routed, it can be used to implement authentication, select the requested microservice in the cluster, record debugging information, etc;\n* **ROUTING filter**: called when routing requests;\n* **POST filter**: It is executed after routing to the microservice, and can be used to add standard HTTP headers to the response, collect statistics and indicators, send the response from the microservice to the client, etc;\n* **ERROR filter**: Called when an error occurs while processing the request.\n\nThe types of `Zuul` filters are actually the life cycle of `Zuul` filters. Use the following diagram to understand their execution process.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nIn addition to the 4 default filter types given above, `Zuul` allows us to create custom filter types. For example, we can customize a STATIC type filter to generate a response directly in `Zuul` without forwarding the request to the microservices on the backend.\n\n### 3. Custom filter example code\nTake a look at a few examples given by the official：\n\n#### PRE type example\n\n[QueryParamServiceIdPreFilter](https://github.com/spring-cloud-samples/sample-zuul-filters/blob/master/src/main/java/org/springframework/cloud/samplezuulfilters/QueryParamServiceIdPreFilter.java)\n\n``` Java\npublic class QueryParamPreFilter extends ZuulFilter { \n    public int filterOrder() {\n\t\t// run before PreDecorationFilter\n\t\treturn PRE_DECORATION_FILTER_ORDER - 1;\n\t}\n\n\tpublic String filterType() {\n\t\treturn \"pre\";\n\t}\n\n\t@Override\n\tpublic boolean shouldFilter() {\n\t\tRequestContext ctx = getCurrentContext();\n\t\treturn ctx.getRequest().getParameter(\"service\") != null;\n\t}\n\n\tpublic Object run() {\n\t\tRequestContext ctx = getCurrentContext();\n\t\tHttpServletRequest request = ctx.getRequest();\n\t\t// put the serviceId in `RequestContext`\n\t\tctx.put(\"serviceId\", request.getParameter(\"service\"));\n\t\treturn null;\n\t}\n}\n```\n\nThis example obtains the `serviceID` to be forwarded from the request parameter `service`. Of course, it's not recommended, here is just an example.\n\n#### ROUTE type example\n\n[OkHttpRoutingFilter](https://cloud.spring.io/spring-cloud-static/Dalston.SR5/multi/multi__router_and_filter_zuul.html)\n\n``` Java\npublic class OkHttpRoutingFilter extends ZuulFilter {\n    @Autowired\n    private ProxyRequestHelper helper;\n\n    @Override\n    public String filterType() {\n        return ROUTE_TYPE; \n    }\n\n    @Override\n    public int filterOrder() {\n        return SIMPLE_HOST_ROUTING_FILTER_ORDER - 1; \n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return RequestContext.getCurrentContext().getRouteHost() != null && RequestContext.getCurrentContext().sendZuulResponse();\n    }\n    \n    @Override\n    public Object run() {\n        OkHttpClient httpClient = new OkHttpClient.Builder() \n            // customize\n            .build();\n\n        RequestContext context = RequestContext.getCurrentContext(); \n        HttpServletRequest request = context.getRequest();\n        \n        String method = request.getMethod();\n\n        String uri = this.helper.buildZuulRequestURI(request);\n\n        Headers.Builder headers = new Headers.Builder(); \n        Enumeration<String> headerNames = request.getHeaderNames(); \n        while (headerNames.hasMoreElements()) {\n            String name = headerNames.nextElement(); \n            Enumeration<String> values = request.getHeaders(name);\n\n            while (values.hasMoreElements()) { \n                String value = values.nextElement(); \n                headers.add(name, value);\n            }\n        }\n\n        InputStream inputStream = request.getInputStream();\n\n        RequestBody requestBody = null;\n        if (inputStream != null && HttpMethod.permitsRequestBody(method)) {\n            MediaType mediaType = null;\n            if (headers.get(\"Content-Type\") != null) {\n                mediaType = MediaType.parse(headers.get(\"Content-Type\")); \n            }\n            requestBody = RequestBody.create(mediaType, StreamUtils.copyToByteArray(inputStream)); \n        }\n\n        Request.Builder builder = new Request.Builder()\n            .headers(headers.build())\n            .url(uri)\n            .method(method, requestBody);\n\n        Response response = httpClient.newCall(builder.build()).execute();\n\n        LinkedMultiValueMap<String, String> responseHeaders = new LinkedMultiValueMap<>();\n        for (Map.Entry<String, List<String>> entry : response.headers().toMultimap().entrySet()) { \n            responseHeaders.put(entry.getKey(), entry.getValue());\n        }\n\n        this.helper.setResponse(response.code(), response.body().byteStream(), responseHeaders);\n        context.setRouteHost(null); // prevent SimpleHostRoutingFilter from running\n        return null; \n    }\n}\n```\n\nThis example converts an HTTP request to an OkHttp3 request, and converts the server's return into a servlet's response.\n\n#### POST type example\n\n[AddResponseHeaderFilter](https://github.com/spring-cloud-samples/sample-zuul-filters/blob/master/src/main/java/org/springframework/cloud/samplezuulfilters/AddResponseHeaderFilter.java)\n\n``` Java\npublic class AddResponseHeaderFilter extends ZuulFilter {\n\tpublic String filterType() {\n\t\treturn \"post\";\n\t}\n\n\tpublic int filterOrder() {\n\t\treturn 999;\n\t}\n\n\tpublic boolean shouldFilter() {\n\t\treturn true;\n\t}\n\n\tpublic Object run() {\n\t\tRequestContext context = RequestContext.getCurrentContext();\n\t\tHttpServletResponse servletResponse = context.getResponse();\n\t\tservletResponse.addHeader(\"X-Foo\", UUID.randomUUID().toString());\n\t\treturn null;\n\t}\n}\n```\n\nThis example is just adding a randomly generated X-Foo to the returned header.\n\n### 4. Disable filter\nOnly need to configure the filter to be disabled in `application.properties`(or yml), the format is: \n```\nzuul. [Filter-name]. [Filter-type] .disable = true\n```\n\nSuch as:\n```\nzuul.FormBodyWrapperFilter.pre.disable=true\n```\n\n### 5. A little supplement about Zuul filter Error\nWhen `Zuul` throws an exception during execution, the error filter is executed. `SendErrorFilter` will only execute if `RequestContext.getThrowable()` is not empty. It sets the error information into the requested `javax.servlet.error.*` properties and forwards to Spring Boot's error page.\n\nThe specific class implemented by `Zuul` filters is `ZuulServletFilter`, whose core code is as follows:\n``` Java\n@Override\npublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n    try {\n        init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);\n        try {\n            preRouting();\n        } catch (ZuulException e) {\n            error(e);\n            postRouting();\n            return;\n        }\n        \n        // Only forward onto to the chain if a zuul response is not being sent\n        if (!RequestContext.getCurrentContext().sendZuulResponse()) {\n            filterChain.doFilter(servletRequest, servletResponse);\n            return;\n        }\n        \n        try {\n            routing();\n        } catch (ZuulException e) {\n            error(e);\n            postRouting();\n            return;\n        }\n        try {\n            postRouting();\n        } catch (ZuulException e) {\n            error(e);\n            return;\n        }\n    } catch (Throwable e) {\n        error(new ZuulException(e, 500, \"UNCAUGHT_EXCEPTION_FROM_FILTER_\" + e.getClass().getName()));\n    } finally {\n        RequestContext.getCurrentContext().unset();\n    }\n}\n```\n\nIt can be seen from this code that error can be executed after catching exceptions in all stages, but if an exception occurs in the post stage and is handled by error, it will not be returned to the post stage for execution, which means that there should be no exceptions in the post stage. Because once there is an exception, other post filters behind this filter will no longer be executed.\n\nA simple method for global exception handling is: Add a filter of type error and write the error information to the `RequestContext` so that `SendErrorFilter` can get the error information. Code show as below:\n``` Java\npublic class GlobalErrorFilter extends ZuulFilter { \n    @Override\n    public String filterType() { \n        return ERROR_TYPE;\n    }\n    \n    @Override\n    public int filterOrder() {\n        return 10; \n    }\n\n    @Override\n    public boolean shouldFilter() {\n        return true; \n    }\n\n    @Override\n    public Object run() {\n        RequestContext context = RequestContext.getCurrentContext();\n        Throwable throwable = context.getThrowable();\n        this.logger.error(\"[ErrorFilter] error message: {}\", throwable.getCause().getMessage());\n        context.set(\"error.status_code\", HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        context.set(\"error.exception\", throwable.getCause());\n        return null;\n    }\n}\n```\n\n## @EnableZuulServer VS @EnableZuulProxy\n`Zuul` provides us with two main application annotations: `@EnableZuulServer` and `@EnableZuulProxy`, where `@EnableZuulProxy` contains the functionality of `@EnableZuulServer`, and `@EnableCircuitBreaker` and `@EnableDiscoveryClient` are also added. When we need to run a `Zuul` service without proxy function, or selectively switch some proxy functions, then we need to use `@EnableZuulServer` instead of `@EnableZuulProxy`. At this time we can add any `ZuulFilter` type entity class. They will be automatically loaded, which is the same as the previous article using `@EnableZuulProxy`, but it will not automatically load any proxy filters.\n\n### 1 @EnableZuulServer's default filter\nWhen we use `@EnableZuulServer`, the filters loaded by default are:\n\n#### PRE type filter\n* ServletDetectionFilter\nThis filter is executed first. It is mainly used to check whether the current request is processed through Spring's `DispatcherServlet` or processed through `ZuulServlet`. The result is stored in `isDispatcherServletRequest`, and the value type is Boolean.\n\n* FormBodyWrapperFilter\nThe purpose of this filter is to wrap the request body that meets the requirements into a `FormBodyRequestWrapper` object for subsequent processing.\n\n* DebugFilter\nPRE type filter. When the debug parameter is set in the request parameter, this filter will set `RequestContext.setDebugRouting()` and `RequestContext.setDebugRequest()` to true in the current request context, so that subsequent filters can define some debug information based on these two parameters. When there is a problem in the production environment, we can add the parameter to print debugging information in the background to help us analyze the problem. For the name of the debug parameter in the request, we can customize it through `zuul.debug.parameter`.\n\n#### Route type filter\n* SendForwardFilter\nThis filter only processes requests with the `forward.to`(FilterConstants.FORWARD_TO_KEY) parameter in the request context. That is, the local forward of the forward in our routing rule is processed.\n\n#### POST type filter\n* SendResponseFilter\nThe filter is to encapsulate the response returned by the proxy request, and then send it back to the requester as the corresponding request.\n\n#### ERROR type filter\n* SendErrorFilter\nThe filter is to determine if there is any exception information in the current request context (`RequestContext.getThrowable ()` is not empty), and if there is, it is forwarded to the `/error` page by default. We can also customize the error page by setting `error.path`.\n\n### 2 @EnableZuulProxy's default filter\n`@EnableZuulProxy` adds the following filters to the above:\n\n#### PRE type filter\n* PreDecorationFilter\nThis filter determines the route to the route and how to route based on the provided `RouteLocator`. The router can also set various proxy-related headers for back-end requests.\n\n#### ROUTE type filter\n* RibbonRoutingFilter\nThis filter will process the request with `serviceId` (can be obtained through `RequestContext.getCurrentContext().Get (\"serviceId\"))` in the context, use `Ribbon`, `Hystrix` and pluggable HTTP client to send the request, and return the result of the request. That is to say that `Ribbon` and `Hystrix` only take effect when we use the `serviceId` to configure routing rules.\n\n* SimpleHostRoutingFilter\nWhen this filter detects that the `routeHost` parameter (available through `RequestContext.getRouteHost()`) is set, it will send a request to the specified URL through Apache HttpClient. At this point, the request is not wrapped with `Hystrix` commands, so this type of request does not have thread isolation and circuit breaker protection.","categories":["Spring Cloud"]},{"title":"Leetcode 93. Restore IP Addresses","url":"/Leetcode-93-Restore-IP-Addresses/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nGive a string and output all possible IP addresses. Note that results like 01.1.001.1 which starts with 0 is an illegal string.\n\n## Solution - Brute Force\nBecause we know that the string needs to be divided into 4 parts, we directly use three loops to force the string into four parts, traverse all the divisions, and then choose a valid solution.\n\n``` Java\npublic List<String> restoreIpAddresses(String s) {\n    List<String> results = new ArrayList<>();\n\n    if (s.length() > 12 || s.length() < 4) {\n        return results;\n    }\n\n    // first field 1,2,3 digit\n    for (int i = 0; i < 4 && i < s.length() - 2; i++) {\n        // second field 1,2,3 digit\n        for (int j = i + 1; j < i + 4 && j < s.length() - 1; j++) {\n            // third field 1,2,3 digit\n            for (int k = j + 1; k < j + 4 && k < s.length(); k++) {\n                String s1 = s.substring(0, i);\n                String s2 = s.substring(i, j);\n                String s3 = s.substring(j, k);\n                String s4 = s.substring(k);\n\n                if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\n                    results.add(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4);\n                }\n            }\n        }\n    }\n\n    return results;\n}\n\n// 1 <= length <= 3\n// between 0 - 255\n// or 0\nprivate boolean isValid(String subString) {\n    return subString.length() != 0 && subString.length() <= 3 && Integer.parseInt(subString) <= 255 && (subString.charAt(0) != '0' || subString.length() <= 1);\n}\n```\n\n## Solution - Backtracking\nThis question is actually dividing a string, and the number of divisions has been determined, which is 4 parts. So we can use the idea of backtracking directly. The first part may be 1 digit, and then enter the recursion. The first part may be 2 digits and then go into recursion. The first part might be 3 digits and then go into recursion.\n\n``` Java\npublic List<String> restoreIpAddresses(String s) {\n    List<String> results = new ArrayList<>();\n\n    getResults(s, 0, new StringBuilder(), results, 0);\n\n    return results;\n}\n\n/**\n * @param:  start start of string\n * @param:  temp already partitioned part\n * @param:  ans results\n * @param:  count how many parts\n */\nprivate void getResults(String s, int start, StringBuilder temp, List<String> result, int count) {\n    // If remaining length >= remaining part * 3\n    // e.g. s = 121231312312, length = 12\n    // current start = 1，count = 1\n    // remaining length 11，remaining part 4 - count = 3，at most 3 * 3 = 9\n    // so it's impossible\n    if ((s.length() - start) > (3 * (4 - count))) {\n        return;\n    }\n\n    // reaching the end\n    if (start == s.length()) {\n        // already formed 4 parts\n        if (count == 4) {\n            result.add(temp.substring(0, temp.length() - 1));\n        }\n\n        return;\n    }\n\n    if (start > s.length() || count == 4) {\n        return;\n    }\n\n    // save current\n    StringBuilder before = new StringBuilder(temp);\n\n    // add 1 digit\n    temp.append(s.charAt(start) + \"\" + '.');\n    getResults(s, start + 1, temp, result, count + 1);\n\n    // if start with 0\n    if (s.charAt(start) == '0') {\n        return;\n    }\n\n    // add 2 digit\n    if (start + 1 < s.length()) {\n        // restore to before\n        temp = new StringBuilder(before);\n\n        temp.append(s.substring(start, start + 2) + \"\" + '.');\n\n        getResults(s, start + 2, temp, result, count + 1);\n    }\n\n    // add 3 digit\n    if (start + 2 < s.length()) {\n        // restore to before\n        temp = new StringBuilder(before);\n\n        int num = Integer.parseInt(s.substring(start, start + 3));\n\n        // check if numbber is valid\n        if (num >= 0 && num <= 255) {\n            temp.append(s.substring(start, start + 3) + \"\" + '.');\n            getResults(s, start + 3, temp, result, count + 1);\n        }\n    }\n}\n```","tags":["Leetcode - String","Leetcode - Backtracking"],"categories":["Data Structure and Algorithms"]},{"title":"Java PriorityQueue","url":"/Java-PriorityQueue/","content":"## PriorityQueue\nThe `PriorityQueue` class was introduced in `Java 1.5`.\n\n`PriorityQueue` is an unbounded queue based on the `priority heap`. Elements in the priority queue can be sorted naturally by default or provided `Comparator` when the queue is instantiated. When `Comparator` is not specified, it is default to a `minimum` heap.\n\n`PriorityQueue` does not allow `null` values and does not support non-comparable objects, such as user-defined classes. Priority queues require Java `Comparable` and `Comparator` interfaces to sort objects, and the elements in them are processed according to priority when sorting.\n\nThe size of the `PriorityQueue` is unlimited, but you can specify an initial size when you create it. When we add elements to the priority queue, the queue size will automatically increase.\n\n`PriorityQueue` is **not thread-safe**, so Java provides `PriorityBlockingQueue` (implements the `BlockingQueue` interface) for Java multi-threaded environments.\n\nExample:\n\n``` Java\npublic class PriorityQueueExample {\n    public static void main(String[] args) {\n        Queue<Integer> priorityQueue = new PriorityQueue<Integer>();\n        priorityQueue.add(2);\n        priorityQueue.add(1);\n        priorityQueue.add(3);\n\n        while (!priorityQueue.isEmpty()) {\n            Integer i = priorityQueue.poll();\n            System.out.println(i);\n        }\n\n        Comparator<Item> comparator = new Comparator<Item>() {\n            @Override\n            public int compare(Item o1, StuItemdent o2) {\n                return (o1.price - o2.price);\n            }\n        };\n\n        Queue<Item> priorityQueue2 = new PriorityQueue<Item>(comparator);\n        priorityQueue2.add(new Item(\"B\", 2));\n        priorityQueue2.add(new Item(\"A\", 1));\n        priorityQueue2.add(new Item(\"C\", 3));\n\n        while (!priorityQueue2.isEmpty()) {\n            Item s = priorityQueue2.poll();\n            System.out.println(s.toString());\n        }\n    }\n\n    public static class Item {\n        private String name;\n        private double price\n\n        public Item(String name, double price) {\n            this.name = name;\n            this.price = price;\n        }\n\n        public String toString() {\n            return name + \"-\" + price;\n        }\n    }\n}\n```\n\nOutput:\n```\n1\n2\n3\nA-1\nB-2\nC-3\n```\n\n## How PriorityQueue is implemented\n> Implemented through the heap, specifically a small top heap implemented through a complete binary tree (the weight of any non-leaf node is not greater than the weight of its left and right child nodes), which means that array can be used as the underlying implementation of `PriorityQueue`.\n\n``` Java\n/**\n * Priority queue represented as a balanced binary heap: the two\n * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The\n * priority queue is ordered by comparator, or by the elements'\n * natural ordering, if comparator is null: For each node n in the\n * heap and each descendant d of n, n <= d.  The element with the\n * lowest value is in queue[0], assuming the queue is nonempty.\n */\ntransient Object[] queue; // non-private to simplify nested class access\n\n/**\n * The number of elements in the priority queue.\n */\nint size;\n```\n\nThe relationship between the index of parent and child nodes is as follows:\n* leftNo   = parentNo * 2 + 1\n* rightNo  = parentNo * 2 + 2\n* parentNo = (nodeNo-1) / 2\n\nThe time complexity of the `add(E e)` and `offer(E e)` operations is log(N):\n``` Java\npublic boolean add(E e) {\n    return offer(e);\n}\n    \npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n        \n    modCount++;\n    int i = size;\n\n    if (i >= queue.length)\n        grow(i + 1);\n\n    siftUp(i, e);\n    size = i + 1;\n\n    return true;\n}\n```\n\nThe time complexity of the `poll()` operation is log (N):\n\n``` Java\npublic E poll() {\n    final Object[] es;\n    final E result;\n\n    if ((result = (E) ((es = queue)[0])) != null) {\n        modCount++;\n        final int n;\n        final E x = (E) es[(n = --size)];\n        es[n] = null;\n        if (n > 0) {\n            final Comparator<? super E> cmp;\n            if ((cmp = comparator) == null)\n                siftDownComparable(0, x, es, n);\n            else\n                siftDownUsingComparator(0, x, es, n, cmp);\n        }\n    }\n    return result;\n}\n```","tags":["Java Collections"],"categories":["Java"]},{"title":"Leetcode 3. Longest Substring Without Repeating Characters","url":"/Leetcode-3-Longest-Substring-Without-Repeating-Characters/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven a string, find the longest substring without repeated characters and return its length.\n\n### Similar Questions\n* Hard - [992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/)\n\n## Solution - Brute Force\nThe most straightforward method. We use two loops to exhaust all substrings, and then use a function to determine whether there are duplicate characters in the substring.\n\nTime complexity: two loops, plus the loop in the function that determines whether the substring satisfies the conditions, O(n<sup>3</sup>).\n\nSpace complexity: A set is used to determine whether there are duplicate characters in the substring. Since there are no repeated characters in the set, the longest possible one is the entire character set. Assuming the size of the character set is `m`, then the longest length of the set is `m`. On the other hand, if the length of the string is less than `m`, it is `n`. Then the longest set is `n`. In summary, the space complexity is O(min(m, n)).\n\n## Solution - Sliding Window\nIn the above solution, we assume that when `i` takes 0,\n\n`j` is set to `1`, to determine whether there are duplicate characters in the string `str[0,1)`.\n\n`j` is set to `2` to determine whether there are duplicate characters in the string `str[0,2)`.\n\n`j` is set to `3` to determine if there are any duplicate characters in the string `str[0,3)`.\n\n`j` is set to `4` to determine whether there are duplicate characters in the string `str[0,4)`.\n\nThere are a lot of repetitive work, because if there are no repeated characters in `str[0,3)`, we don't need to determine whether there are repeated characters in the entire string `str[0,4)`, but only need to determine whether `str[3]` is in `str[0,3)` or not. \n\nIf it's not, it means that there are no duplicate characters in `str[0,4)`.\n\nIf it is, then `str[0,5)`, `str[0,6)`, `str[0,7)` must have duplicate characters. So at this time, there is not need to continue loop with `j`, just `i++` to enter the next loop.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nWe can see the process as the orange window moving to the right.\n\nTo determine whether a character is in the string, we can put the char in the `map`. The char is the key and it's index is the value. So that we know the last occurance of a char in the string.\n\nWe can further optimize it. Let's look at the example.\n\n{% asset_img 2.png %}\n<br/>\n<br/>\n\nWhen the `c` pointed to by `j` exists in the preceding substring `abcd`, `i` is moved forward to `b` at this time, and the substring still contains `c`, and `i` must continue to move, so it can be optimized here. We can move `i` directly to the next position of `c`!\n\n``` Java\nint result = 0;\n\nMap<Character, Integer> tempMap = new HashMap<>();\n\nfor (int i = 0, j = 0; j < s.length(); j++) {\n    // find repeat, skip i - j'\n    if (tempMap.containsKey(s.charAt(j))) {\n        i = Math.max(tempMap.get(s.charAt(j)), i);\n    }\n\n    result = Math.max(result, j - i + 1);\n    // j + 1 means next time i will be move directly to here\n    tempMap.put(s.charAt(j), j + 1);\n}\n\nreturn result;\n```\n\nBecause `i` is jumping, the characters stored before map are not removed, so `Math.max(map.get(s.charAt(j)), i)` is used to make sure that the obtained index is not in front of `i`.\n\n`j` is incremented by 1 for each loop, because the jump of `i` already guarantees that there are no duplicate in `str[i, j]`.","tags":["Leetcode - Two Pointers","Leetcode - Hash Table","Leetcode - String","Leetcode - Sliding Window"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 60. Permutation Sequence","url":"/Leetcode-60-Permutation-Sequence/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven an n, not to output its full permutation, but to arrange all combinations from small to large, and output the kth.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-31-Next-Permutation '31. Next Permutation' %}\n* Medium - [46. Permutations](https://leetcode.com/problems/permutations/)\n\n## Solution\nTake `n = 4` as an example. Because it is arranged from small to large, the highest digit must be from 1 to 4. Then it can be seen as a group, we only need to look for the group number to know what the highest digit is. And the number of each group is the `(n-1)!`.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nWhen calculating the `group number`, 1 to 5 divided by 6 is 0, 6 divided by 6 is 1, and 6 belongs to group 0, so we need to subtract 1 from k. By doing this, the division results are all 0.\n\n``` Java\nint perGroupNum = factorial(n - 1); \nint groupNum = (k - 1) / perGroupNum;\n```\n\nOf course, there is also the question of what `k` is next time. Divide the group number, and the remainder is the next `k`. Because `k` is counted from 1, if `k` is exactly equal to a multiple of `perGroupNum`, the remainder obtained at this time is 0. In fact, since we subtract 1 when we ask for `groupNum`, `k` should be updated to `perGroupNum` at this time.\n\n``` Java\nk = k % perGroupNum; \nk = k == 0 ? perGroupNum : k;\n```\n\nFor example, if `k = 6`, then `groupNum = (k-1) / 6 = 0`, `k % perGroupNum = 6% 6 = 0`, and the next `k` can be seen from the above figure, it is obviously `perGroupNum`, which is still 6.\n\nAfter determining that the highest digit belongs to `group 0`, then the next is the same as the above process. The only difference is that the highest digit is `2 3 4` and there is no `1`. How to get the highest digit of `groupNum` needs to be considered.\n\nWe can use a list to save 1 to n from small to large, and remove one digit each time, so that we can get the number corresponding to `groupNum`.\n\nCombine then together, we get the following solution.\n\n``` Java\n// record `n!`, keep it here to speed up\nprivate Map<Integer, Integer> factorialTable = new HashMap<>();\n\npublic String getPermutation(int n, int k) {\n    List<Integer> nums = new ArrayList<>();\n\n    // put 1 - n to a list\n    for (int i = 1; i <= n; i++) {\n        nums.add(i);\n    }\n\n    return getResult(nums, n, k);\n}\n\n// nums initially is '1,2,3,4,5,....n'\nprivate String getResult(List<Integer> nums, int n, int k) {\n    StringBuilder stringBuilder = new StringBuilder();\n\n    while (n > 1) {\n        // permutation starting with the same number is a group\n        // how many number in each group? n!\n        // e.g. if n = 3, each group has 2 numbers\n        int numPerGroup = factorial(n - 1);\n        // which group is our target number in\n        int groupNum = (k - 1) / numPerGroup;\n\n        stringBuilder.append(nums.get(groupNum));\n\n        k = k % numPerGroup;\n        k = k == 0 ? numPerGroup : k;\n\n        nums.remove(groupNum);\n        n--;\n    }\n\n    stringBuilder.append(nums.get(0));\n\n    return stringBuilder.toString();\n}\n\nprivate int factorial(int n) {\n    if (n == 1) {\n        factorialTable.put(n, 1);\n        return 1;\n    } else {\n        if (factorialTable.containsKey(n - 1)) {\n            int result = n * factorialTable.get(n - 1);\n            factorialTable.put(n, result);\n            return result;\n        } else {\n            int result = n * factorial(n - 1);\n            factorialTable.put(n, result);\n            return result;\n        }\n    }\n}\n```","tags":["Leetcode - Backtracking","Leetcode - Math"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 7: API Gateway - Zuul Part 1","url":"/Spring-Cloud-7-API-Gateway-Zuul-Part-1/","content":"With microservices architecture, each microservice exposes a set of fine-grained services to the outside. The client's request may involve a series of service calls. If all these microservices are exposed to the client, the client needs to request different microservices multiple times to complete a business process, increasing the code complexity at the client side. In addition, for microservices, we may also need unified authentication and verification of service calls and so on. Although the microservice architecture can divide our development unit into smaller pieces and reduce the development difficulty, if we cannot effectively deal with the problems mentioned above, it may cause the implementation of the microservice architecture to fail.\n\n`Zuul` refers to the `Facade pattern` in the GOF design pattern, and combines fine-grained services to provide a coarse-grained service. All requests are imported into a unified entrance. Then the entire service only needs to expose an API, which shields the server-side implementation details. It also reduces the number of client-server network calls. This is the `API Gateway` service. We can think of the `API Gateway` as an intermediate layer between the client and the server. All external requests will first pass through the `API Gateway`. Therefore, the `API Gateway` has almost become a must choice when implementing a microservice architecture.\n\nThe `Zuul` component of `Spring Cloud Netflix` can be used as `a reverse proxy`, forwarding requests to coarse-grained services on the back end through `routing addressing`, and doing some general logic processing.\n\nWith `Zuul` we can complete the following functions:\n* **Dynamic routing**\n* **Monitoring and review**\n* **Authentication and security**\n* **Stress test**: gradually increase the traffic of a service cluster to understand the service performance;\n* **Canary test**\n* **Service migration**\n* **Load tailoring**: Allocate the corresponding capacity for each load type and discard requests that exceed the limit;\n* **Static response processing**\n\n# *Why we need API Gateway*\n\n## Simplify client call complexity\nUnder microservice architecture, the number of instances of the backend service is generally dynamic, and it is difficult for the client to find the address information of the dynamically changed service instance. Therefore, in order to simplify the front-end call logic in microservice-based projects, `API Gateway` is usually introduced as a lightweight gateway. At the same time, `API Gateway` will also implement related authentication logic to simplify the complexity of mutual calls between internal services.\n\n## Data clipping and aggregation\nGenerally speaking, different clients have inconsistent requirements for data during display, such as mobile phones or Web terminals, or in low-latency network environments or high-latency network environments.\n\nTherefore, in order to optimize the client's experience, `API Gateway` can tailor the general response data to meet the needs of different clients. At the same time, multiple API calls can be aggregated to reduce the number of client requests and optimize the client user experience.\n\n## Multi-channel support\nOf course, we can also provide different `API Gateways` for different channels and clients. The use of this mode is another well-known method called `Backend for front-end`. In `Backend for front-end` mode, we can target different client to create its `BFF` separately. For more information about `BFF`, please refer to this article: [Pattern: Backends For Frontends](https://samnewman.io/patterns/architectural/bff/)\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\n# *Example Project*\n## Zuul-Server\n### 1. pom.xml\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-zuul</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\n</dependency>\n```\n\n### 2. Main class\n``` Java\n@EnableZuulProxy\n@SpringBootApplication\npublic class ZuulServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ZuulServerApplication.class, args);\n    }\n}\n```\n\nAdded `@EnableZuulProxy` annotation to the main application class to start Zuul's routing service.\n\n### 3. application.properties\n``` Java\nserver.port=8280\n\nspring.application.name=ZUUL-PROXY\n\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n\nmanagement.endpoints.web.exposure.include=hystrix.stream\n```\n\n## User-Service\nWe add another service: `User-Service` here.\n\n### 1. pom.xml\n``` Xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n### 2. Main class\n``` Java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class UserServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(UserServiceApplication.class, args);\n    }\n}\n```\n\nThis is the same as `Product-Service`.\n\n### 3. User entity\n``` Java\npublic class User {\n    private String loginName;\n    private String name;\n    private String avatar;\n    private String memos;\n\n    public User(String loginName, String name, String avatar, String memos) {\n        this.loginName = loginName;\n        this.name = name;\n        this.avatar = avatar;\n        this.memos = memos;\n    }\n\n    public String getLoginName() {\n        return loginName;\n    }\n\n    public void setLoginName(String loginName) {\n        this.loginName = loginName;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getAvatar() {\n        return avatar;\n    }\n\n    public void setAvatar(String avatar) {\n        this.avatar = avatar;\n    }\n\n    public String getMemos() {\n        return memos;\n    }\n\n    public void setMemos(String memos) {\n        this.memos = memos;\n    }\n}\n```\n\n### 4. User service\n``` Java\n@RestController\n@RequestMapping(\"/users\")\npublic class UserEndpoint {\n    private static final Logger LOGGER = LoggerFactory.getLogger(UserEndpoint.class);\n\n    @Value(\"${server.port:2200}\")\n    private int serverPort = 2200;\n\n    @RequestMapping(value = \"/{loginName}\", method = RequestMethod.GET)\n    public User detail(@PathVariable String loginName) {\n        String memos = \"I come form \" + this.serverPort;\n        return new User(loginName, loginName, \"/avatar/default.png\", memos);\n    }\n}\n```\n\nThe interface is very simple, just  query a user's information based on the given login name.\n\n### 5. application.properties\n``` Java\nserver.port=2200\n\nspring.application.name=USER-SERVICE\n\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n```\n\n## Testing\n### 1. Launch services\nStart each server in the following order:\n1. Service-discovery\n2. User-Service(2200)\n3. User-Service(2300): `java -jar user-service-1.0.0-SNAPSHOT.jar --server.port=2300`\n4. Zuul-Server\n\nWe can see the eureka admin page:\n{% asset_img 2.png %}\n<br/>\n<br/>\n\n### 2. Test routing\nVisit: http://localhost:8280/user-service/users/admin\n{% asset_img 4.png %}\n<br/>\n<br/>\n\nNote that here we used service name to retrieve the relevant servicie.\n\n### 3. Load balance testing\nLet's test if load balancing works. Earlier we have started two `User-Service` microservices, the ports are: 2200 and 2300. Try visit: http://localhost:8280/user-service/users/admin to make a request, we will see that the following information will be output alternately on the screen:\n\n{% asset_img 4.png %}\n<br/>\n<br/>\n\n{% asset_img 3.png %}\n<br/>\n<br/>\n\n### 4. Hystrix fault tolerance and monitoring test\nWe have integrated `Hystrix` monitoring in `Zuul-Server`. Visit: http://localhost:8280/hystrix/ and enter: http://localhost:8280/actuator/hystrix.stream to start monitor.\n\n{% asset_img 5.png %}\n<br/>\n<br/>\n\nThis means that `Zuul` has integrated `Hystrix`.\n\n> `Spring-cloud-starter-netflix-zuul` itself has integrated `hystrix` and `ribbon`, so `Zuul` is inherently equipped with `thread isolation` and `circuit breaker` self-protection capabilities, as well as `client load balancing` for service calls. However, we need to note that when using the mapping relationship between `path` and `url` to configure routing rules, requests for routing will not be wrapped with `HystrixCommand`, so this type of routing request has no thread isolation and circuit breaker protection functions, and also there will be no load balancing capabilities. Therefore, when using `Zuul`, we try to use a combination of `path` and `serviceId` to configure. This not only can ensure the robustness and stability of the API gateway, but also can use `Ribbon`'s client load balancing function.\n\n# *Zuul Configuration*\n## Routing configuration\nMaybe you think it’s strange that we didn’t configure anything, but can access service through http://localhost:8280/user-service/users/admin. This is the default route mapping function of `Zuul`, so let's take a look at how to configure routing in `Zuul`.\n\n### 1. Service routing default rules\nWhen we used `Eureka` to built the `API gateway`, `Zuul` will automatically create a default routing rule for each service: the access path is prefixed with the service name configured by `serviceId`, which is why we were able to use:\n```\nhttp://localhost:8280/user-service/users\n```\n\nto access the `users` endpoint provided in `User-Service`.\n\n### 2. Customized microservice access path\nThe configuration format is: `zuul.routes.Microservice Id = specified path`, such as:\n```\nzuul.routes.user-service = /user/**\n```\n\nIn this way, we can access the services provided by `user-service` through `/user/`. For example, the previous access can be changed to: http://localhost:8280/user/users/admin.\n\nThe path to be configured can specify a regular expression to match the path. Therefore, `/user/*` can only match the first-level path, but `/user/**` can match all paths starting with `/user/`.\n\n### 3. Ignore specified microservices\nFormat: `zuul.ignored-services = Micro service Id1, Micro service Id2 ...`, multiple micro services are separated by commas. Such as:\n```\nzuul.ignored-services=user-service,product-service\n```\n\n### 4. Specify the microservice Id and the corresponding path at the same time\n```\nzuul.routes.api-a.path=/api-a/**\nzuul.routes.api-a.serviceId=service-A\n\nzuul.routes.api-b.path=/api-b/**\nzuul.routes.api-b.serviceId=service-B\n```\n\n### 5. Specify microservice URL and corresponding path at the same time\n```\nzuul.routes.api-a.path=/api-a/**\nzuul.routes.api-a.url=http://localhost:8080/api-a\n```\n\nAs mentioned before, the routing configured through the URL will not be executed by `HystrixCommand`. As a result, `Ribbon`'s `load balancing`, `downgrading`, and `circuit breaker` functions will not be obtained. Therefore, try to use `serviceId` for configuration, you can also use the following configuration.\n\n### 6. Specify multiple service instances and load balancing\nIf multiple service instances need to be configured, the configuration is as follows:\n```\nzuul.routes.user.path: /user/**\nzuul.routes.user.serviceId: user\n\nribbon.eureka.enabled=false\nuser.ribbon.listOfServers: http://192.168.1.10:8081, http://192.168.1.11:8081\n```\n\n### 7. Forward to local url\n```\nzuul.routes.user.path=/user/**\nzuul.routes.user.url=forward:/user\n```\n\n### 8. Route prefix\nYou can add a uniform prefix to all mappings through `zuul.prefix`. For example: /api. By default, the proxy will automatically strip this prefix before forwarding. If you need to prefix with forwarding, you can configure: `zuul.stripPrefix = false` to turn off this default behavior. E.g:\n```\nzuul.routes.users.path=/myusers/**\nzuul.routes.users.stripPrefix=false\n```\n\n> Note: `zuul.stripPrefix` only works on the prefix of `zuul.prefix`. Does not work for prefix specified by path.\n\n### 9. Routing configuration order\nIf you want to control the routing rules according to the configured order, you need to use `YAML`. If you use the property file, the order will be lost. E.g:\n```\nzuul:\n  routes:\n    users:\n      path: /myusers/**\n    legacy:\n      path: /**\n```\n\nIf the above example is configured using a properties file, the `legacy` may be effective, so the users have no effect.\n\n### 10. Custom transformation\nWe can also have a converter that uses a regular expression between the `serviceId` and the `route` to automatically match. E.g:\n``` Java\n@Bean\npublic PatternServiceRouteMapper serviceRouteMapper() {\n    return new PatternServiceRouteMapper(\n        \"(?<name>^.+)-(?<version>v.+$)\",\n        \"${version}/${name}\");\n}\n```\n\nIn this way, the service whose serviceId is `users-v1` will be mapped to the route of `/v1/users/`. Any regular expression is fine, but all named groups must include `servicePattern` and `routePattern`. If `servicePattern` does not match a `serviceId`, then the default is used. In the above example, a service with serviceId `users` will be mapped to the route `/users/ `(without version information). This feature is off by default and only applies to services that have been discovered.\n\n## Zuul Header Settings\n### Sensitive header settings\nIt is not a problem to share information through headers between services in the same system, but if you don't want some sensitive information in headers to leak out with HTTP forwarding, you need to specify a list of headers to be ignored in the routing configuration.\n\nBy default, when `Zuul` requests routing, it will filter some sensitive information in the HTTP request header information. The default sensitive header information is defined through `zuul.sensitiveHeaders`, including `Cookie`, `Set-Cookie`, and `Authorization`. The configured sensitiveHeaders can be separated by commas.\n\nThe specified routes can be configured with:\n```\nzuul.routes.[route].customSensitiveHeaders=true \nzuul.routes.[route].sensitiveHeaders=[set headers here]\n```\n\nSet global:\n```\nzuul.sensitiveHeaders=[set headers here]\n```\n\n### Ignore Header settings\nIf you need to configure some additional sensitive headers for each route, you can use `zuul.ignoredHeaders` to uniformly set the headers to be ignored. Such as:\n```\nzuul.ignoredHeaders=[set Header to ignore]\n```\n\nThere is no such configuration by default. If `Spring Security` is introduced in the project, then `Spring Security` will automatically add this configuration. The default values are: `Pragma`, `Cache-Control`, `X-Frame-Options`, `X-Content-Type- Options`, `X-XSS-Protection`, `Expries`.\n\nIf you also need to use the `Spring Security Header` of the downstream microservice, you can add the following settings:\n```\nzuul.ignoreSecurityHeaders=false\n```\n\n## Zuul Http Client\n`Zuul`'s Http client supports `Apache Http`, Ribbon's `RestClient`, and `OkHttpClient`. By default, the `Apache HTTP` client is used. The corresponding clients can be enabled in the following ways:\n```\n# Enable Ribbon'RestClient\nribbon.restclient.enabled=true\n\n# Enable OkHttpClient\nribbon.okhttp.enabled=true\n```\n\n> If you need to use `OkHttpClient`, please note that `com.squareup.okhttp3` related packages are already included in your project.\n\n# *Zuul fault tolerance and fallback*\nLet's take a look at the previous monitoring interface of Hystrix:\n\n{% asset_img 5.png %}\n<br/>\n<br/>\n\nPlease note that the granularity of `Zuul`'s `Hystrix monitoring` is microservices, not an API, that is, all requests passing `Zuul` will be protected by `Hystrix`. If we shut down the `User-Service` service now, what will happen when we visit it again?\n\n{% asset_img 6.png %}\n<br/>\n<br/>\n\nSo how do we implement fault tolerance and fallback for `Zuul`? `Zuul` provides a `ZuulFallbackProvider` interface. By implementing this interface, we can implement fallback functions for `Zuul`. So let's transform `Zuul-Server` before.\n``` Java\n\n```\n\nNote that:\n* The `getRoute` method returns that we want to provide a fallback for that microservice. Note that the returned value is the name of the route, not the name of the service, and cannot be written as: `USER-SERVICE`, otherwise the fallback will not work;\n* The `fallbackResponse` method returns a `ClientHttpResponse` object as our fallback response.\n\nNow do a test, stop `User-Service` and visit:http://localhost:8280/user-service/users/admin\n{% asset_img 7.png %}\n<br/>\n<br/>\n\nNote that the fallback method has worked. If it doesn't work, double check that `getRoute` returns correctly.\n\nCheck out the source code here: [zuul part 1 demo](https://github.com/nicklee1006/SpringCloudDemo/tree/zuul-demo-part-1)","categories":["Spring Cloud"]},{"title":"Dynamic Programming","url":"/Dynamic-Programming/","content":"## Basic Concept\nThe process of dynamic programming is: each decision depends on the current state, and then causes a state transition. A decision sequence is generated in a changing state. Therefore, this multi-stage optimization decision-making process is called dynamic programming.\n\n> Initial state → │Decision 1│ → │Decision 2│ →… → │Decision n│ → End state\n\n## Scope of application\nThe problems that can be solved by dynamic programming generally have three properties:\n\n1. **<font color=\"orange\">Optimization principle</font>**: If the solution of the sub-problem contained in the optimal solution of the problem is also optimal, the problem is said to have an optimal sub-structure, that is, to satisfy the optimization principle.\n\n2. **<font color=\"orange\">No aftereffect</font>**: once the state of a certain stage is determined, it will not be affected by the future decisions. In other words, the process after a certain state will not affect the previous state, only the current state.\n\n3. There are **<font color=\"orange\">overlapping sub-problems</font>**: that is, the sub-problems are not independent, and a sub-problem may be used multiple times in the next stage of decision-making. **<font color=\"orange\">(This property is not a necessary condition for dynamic programming, but without this property, dynamic programming algorithms have no advantage over other algorithms)</font>**\n\n## Basic ideas and strategies\nThe basic idea is similar to the divide-and-conquer method, which decomposes the problem into several sub-problems (stages), and solves the sub-problems in order. The solution of the former sub-problem provides useful information for the solution of the latter sub-problem. When solving any sub-problem, list all possible local solutions, retain those that are likely to reach the optimal local solution through decision-making, and discard other local solutions. Solve each sub-problem in turn. The last sub-problem is the solution of the initial problem.\n\nSince most of the problems solved by dynamic programming have overlapping sub-problems, in order to reduce repeated calculations, each sub-problem is solved only once, and different states at different stages are stored in a two-dimensional array.\n\nThe biggest difference from the divide-and-conquer method is that for problems that are suitable for dynamic programming, **<font color=\"orange\">the sub-problems obtained after decomposition are often not independent of each other (that is, the solution of the next sub-stage is based on the solution of the previous sub-stage)</font>**.\n\n## Steps to solve problems using dynamic programming\nThe problems dealt with by dynamic programming is **<font color=\"orange\">a multi-stage decision-making problem</font>**, which generally starts from the initial state and reaches the end state through the selection of intermediate-stage decisions. These decisions form a sequence of decisions, and determine an activity route (usually the optimal activity route) to complete the entire process. \n\n> Initial state → │Decision 1│ → │Decision 2│ →… → │Decision n│ → End state\n\nThere are certain patterns in the design of dynamic programming solution. Generally, the following steps are required.\n\n1. **<font color=\"orange\">Division</font>**: According to the time or space characteristics of the problem, the problem is divided into several stages. In the division stage, pay attention that **<font color=\"orange\">the order of the stages must be ordered or sortable</font>**, otherwise the problem cannot be solved.\n\n2. **<font color=\"orange\">Determining the state and state variables</font>**: The various situations in which the problem develops into various stages are represented by different states. Of course, the choice of state must satisfy no aftereffect.\n\n3. **<font color=\"orange\">Determine the decision and write the state transition equation</font>**: Because decision and state transition have a connection, **<font color=\"orange\">state transition is to derive the state of this stage according to the state of previous stage and the decision</font>**. So if a decision is made, the state transition equation can be written. But in reality, it is often done the other way around, and the decision-making method and state transition equation are **<font color=\"orange\">determined according to the relationship between the states of two adjacent stages</font>**.\n\n4. **<font color=\"orange\">Finding the boundary conditions</font>**: The given state transition equation is a recursive formula, which requires a recursive termination condition or boundary condition.\n\nIn general, as long as the problem's **<font color=\"orange\">stage</font>**, **<font color=\"orange\">state</font>**, and **<font color=\"orange\">state transition decision</font>** are determined, the state transition equation (including boundary conditions) can be written.\n\nIn practical applications, you can design according to the following simplified steps:\n1. Analyze the nature of the optimal solution and characterize its structure.\n2. Recursive definition of optimal solution.\n3. Calculate the optimal value by bottom-up or top-down memorization method (memorandum method)\n4. Construct the optimal solution of the problem based on the information obtained when calculating the optimal value\n\n## Algorithm design\nThe main difficulty of dynamic programming is the theoretical design, which is the determination of the above 4 steps. Once the design is completed, the implementation part will be very simple.\n\nUsing dynamic programming to solve problems, the most important thing is to determine the **<font color=\"orange\">three elements of dynamic programming</font>**:\n1. Problem stage\n2. State of each stage\n3. Recursive relationship from the previous stage to the later stage.\n\nThe recursive relationship must be a conversion from the smaller problem to the larger one. From this perspective, dynamic programming can often be implemented using recursion, but because dynamic programming can make use of the previously saved sub-problems solution to reduce repeated calculations. So for large-scale problems, dynamic programming have advantages compared with recursion, which is the core of dynamic programming algorithms.\n\nAfter determining these three elements of dynamic programming, **<font color=\"orange\">the entire solution process can be described by an optimal decision table. The optimal decision table is a two-dimensional table, where the rows represent the stages of decision-making, and the columns represent the problem state</font>**. Generally speaking, **<font color=\"orange\">the cell value corresponds to the optimal value (such as the shortest path, longest common subsequence, maximum value, etc.) at a certain stage and state</font>**. The process of filling the form is based on the recursive relationship, starting from Row 1 and Column 1, in the order of row or column first, and finally obtain the optimal solution of the problem by simple rounding or calculation based on the data of the entire form.\n\n```\nf(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}\n```\n\n## Algorithm basic framework\n``` Java\n// Initial stage\nfor(j = 1; j <= m; j++) {\n   xn[j] = initial value;\n}\n\n// Other n-1 stage\nfor(i = n-1; i >= 1; i--) {\n    // f(i) is expression related to i\n    for(j = 1; j >= f(i); j--) {\n        xi[j]=j=max（or min）{g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])};\n    }\n}\n\n// Get optimal solution to the problem from the optimal to the sub-problems\nt = g(x1[j1:j2]); \n\nprint(x1[j1]);\n\nfor(i = 2; i <= n-1; i++）{  \n     t = t-xi-1[ji];\n\n     for(j=1; j>=f(i); j=j+1) {\n        if(t=xi[ji]) {\n            break;\n        }\n     }\n}\n```","tags":["Leetcode - Dynamic Programming"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 96. Unique Binary Search Trees","url":"/Leetcode-96-Unique-Binary-Search-Trees/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nSimilar to {% post_link Leetcode-95-Unique-Binary-Search-Trees-II '95. Unique Binary Search Trees II' %}. This time just need to count the number of unique binary search tree.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-95-Unique-Binary-Search-Trees-II '95. Unique Binary Search Trees II' %}\n\n## Solution\nThe following is the analysis for {% post_link Leetcode-95-Unique-Binary-Search-Trees-II '95. Unique Binary Search Trees II' %}:\n>Example: `1....n`\nTake `1` as the root node, `[]` as the left subtree, and all of `[2 ... n]` as the right subtree.\nTake `2` as the root node, `[1]` as the left subtree, `[3 ... n]` as the right subtree.\nTake `3` as the root node, `[1 2]` as the left subtree, `[4 ... n]` as the right subtree. Then pair the left and right subtrees.\nTake `4` as the root node, `[1 2 3]` as the left subtree, `[5 ... n]` as the right subtree. Then pair the left and right subtrees.\n...\nTake `n` as the root node, `[1 ... n]` as the left subtree, `[]` as the right subtree.\nIf there is only one number, then there is only 1 case, using that number as a tree. If it is [], it returns null.\n\nFor this problem, it will be simpler, we only need to return the number of trees. To find the number of subtrees of current roots, just multiply the number of left subtrees by the right subtree.\n\nAs there are many repeated calculations, we can save the results obtained during the recursion, and it can be taken directly when needed for the second time.\n\n``` Java\n// dynamic programming values, map n -> number of valid trees\nMap<Integer, Integer> map = new HashMap<>();\n\npublic int numTrees(int n) {\n    // initialize values\n    map.put(0, 1);\n    map.put(1, 1);\n    map.put(2, 2);\n\n    return getAnswer(n);\n}\n\nprivate int getAnswer(int n) {\n    if (n == 0 || n == 1) {\n        return 1;\n    }\n\n    if (n == 2) {\n        return 2;\n    }\n\n    int result = 0;\n\n    for (int i = 1; i <= n; i++) {\n        // root element is i, \n        // number of left node = i - i\n        // number of right node = n - i\n        int left;\n        if (map.containsKey(i - 1)) {\n            left = map.get(i - 1);\n        } else {\n            left = getAnswer(i - 1);\n            map.put(i - 1, left);\n        }\n\n        int right;\n        if (map.containsKey(n - i)) {\n            right = map.get(n - i);\n        } else {\n            right = getAnswer(n - i);\n            map.put(n - i, right);\n        }\n\n        result += left * right;\n    }\n\n    map.put(n, result);\n    return result;\n}\n```","tags":["Leetcode - Dynamic Programming","Leetcode - Tree"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 95. Unique Binary Search Trees II","url":"/Leetcode-95-Unique-Binary-Search-Trees-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven n, use these numbers 1 ... n to generate all possible binary search trees.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-96-Unique-Binary-Search-Trees '96. Unique Binary Search Trees' %}\n* Medium - [241. Different Ways to Add Parentheses](https://leetcode.com/problems/different-ways-to-add-parentheses/)\n\n## Solution\nOne of the most important property of binary tree: all values of the left subtree are smaller than the root node, and all values of the right subtree are larger than the root node. We could use it to solve this problem\n\nExample: `1....n`\n\nTake `1` as the root node, `[]` as the left subtree, and all of `[2 ... n]` as the right subtree.\n\nTake `2` as the root node, `[1]` as the left subtree, `[3 ... n]` as the right subtree.\n\nTake `3` as the root node, `[1 2]` as the left subtree, `[4 ... n]` as the right subtree. Then pair the left and right subtrees.\n\nTake `4` as the root node, `[1 2 3]` as the left subtree, `[5 ... n]` as the right subtree. Then pair the left and right subtrees.\n\n...\n\nTake `n` as the root node, `[1 ... n]` as the left subtree, `[]` as the right subtree.\n\nIf there is only one number, then there is only 1 case, using that number as a tree. If it is [], it returns null.\n\n``` Java\npublic List<TreeNode> generateTrees(int n) {\n    if (n == 0) {\n        return Collections.emptyList();\n    }\n\n    return getResults(1, n);\n}\n\n// recursive\nprivate static List<TreeNode> getResults(int start, int end) {\n    List<TreeNode> results = new ArrayList<>();\n\n    if (start > end) {\n        results.add(null);\n\n        return results;\n    }\n\n    // only 1 node\n    if (start == end) {\n        TreeNode node = new TreeNode(start);\n        results.add(node);\n\n        return results;\n    }\n\n    for (int i = start; i <= end; i++) {\n        // i is the root node\n        List<TreeNode> leftNodes = getResults(start, i - 1);\n        List<TreeNode> rightNodes = getResults(i + 1, end);\n\n        // combine all possible left and right tree\n        for (TreeNode leftNode : leftNodes) {\n            for (TreeNode rightNode : rightNodes) {\n                TreeNode root = new TreeNode(i);\n\n                root.left = leftNode;\n                root.right = rightNode;\n\n                results.add(root);\n            }\n        }\n    }\n\n    return results;\n}\n```","tags":["Leetcode - Dynamic Programming","Leetcode - Tree"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 91. Decode Ways","url":"/Leetcode-91-Decode-Ways/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nEach number corresponds to a letter. Given a string of numbers, need to know how many decoding methods. For example, 226 can have three decode ways, 2|2|6, 22|6, 2|26.\n\n### Similar Questions\n* Hard - [639. Decode Ways II](https://leetcode.com/problems/decode-ways-ii/)\n\n## Solution 1 - Recursion\nIt is easy to think of using recursion, turning big problems into smaller problems.\n\nFor example, `232232323232`.\n\nFor the first letter we have two divisions.\n\n`2|32232323232` and `23|2232323232`\n\nTherefore, if we know that the decoding result of the right part `32232323232` is `ans1` and that of `2232323232` is `ans2`, then the overall `232232323232` decoding result is `ans1` + `ans2`.\n\nIf it is too hard to understand, think about this analogy. \n\nIf there are two roads from Melbourne to Brisbane, via Sydney and Canberra. There are 8 roads from Sydney to Brisbane, and 6 roads from Canberra to Brisbane. So there are 8 + 6 = 14 routes from Melbourne to Brisbane.\n\n``` Java\npublic int numDecodings(String s) {\n    return getResult(s, 0);\n}\n\n// start is the index of the char in 's'\nprivate int getResult(String s, int start) {\n    // reaching the end\n    if (start == s.length()) {\n        return 1;\n    }\n\n    if (s.charAt(start) == '0') {\n        return 0;\n    }\n\n    // answer if divide the first index\n    // e.g. if input （123）\n    // answer1 is 1 + answer(2,3)\n    // answer2 is 12 + answer(3)\n    int answer1 = getResult(s, start + 1);\n    int answer2 = 0;\n\n    // only have answer2 if first 2 digit <= 26\n    if (start < s.length() - 1) {\n        int ten = (s.charAt(start) - '0') * 10;\n        int one = s.charAt(start + 1) - '0';\n\n        if (ten + one <= 26) {\n            answer2 = getResult(s, start + 2);\n        }\n    }\n\n    return answer1 + answer2;\n}\n```\n\n## Solution 2 - Recursion + Dynamic Programming\nIn solution 1, after calculating `ans1` and then calculate `ans2`, some already calculated results will be recalculated, so we can use the memoization technique to calculate a result and save it.\n\n``` Java\npublic int numDecodings(String s) {\n    // map startIndex -> result\n    HashMap<Integer, Integer> cache = new HashMap<>();\n    return getResult(s, 0, cache);\n}\n\n// start is the index of the char in 's'\nprivate int getResult(String s, int start, HashMap<Integer, Integer> cache) {\n    // reaching the end\n    if (start == s.length()) {\n        return 1;\n    }\n\n    if (s.charAt(start) == '0') {\n        return 0;\n    }\n\n    // check if calculated before\n    int tempResult = cache.getOrDefault(start, -1);\n    if (tempResult != -1) {\n        return tempResult;\n    }\n\n    // answer if divide the first index\n    // e.g. if input （123）\n    // answer1 is 1 + answer(2,3)\n    // answer2 is 12 + answer(3)\n    int answer1 = getResult(s, start + 1, cache);\n    int answer2 = 0;\n\n    // only have answer2 if first 2 digit <= 26\n    if (start < s.length() - 1) {\n        int ten = (s.charAt(start) - '0') * 10;\n        int one = s.charAt(start + 1) - '0';\n\n        if (ten + one <= 26) {\n            answer2 = getResult(s, start + 2, cache);\n        }\n    }\n\n    // cache the result\n    cache.put(start, ans1 + ans2);\n\n    return answer1 + answer2;\n}\n```","tags":["Leetcode - Dynamic Programming","Leetcode - String"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 5. Longest Palindromic Substring","url":"/Leetcode-5-Longest-Palindromic-Substring/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nDind the longest palindromic substring in a given string s\n\n### Similar Questions\n* Hard - [214. Shortest Palindrome](https://leetcode.com/problems/shortest-palindrome/)\n* Hard - [336. Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/)\n* Medium - [516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)\n* Medium - [647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)\n\n## Solution 1 - Brute Force\nEnumerate all substrings, determine whether it is a palindrome string, and save the longest palindrome string.\n\nTime complexity: need 2 for loop to enumerate all substring O(n<sup>2</sup>), and 1 for loop to determine if a string is palindrome. Thus overall time complexity O(n<sup>3</sup>).\n\n## Solution 2 - Expand from central\nWe know that the palindrome string must be symmetrical, so we can select a center each time, expand left and right, and determine whether the left and right characters are equal.\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nBecause there are strings with odd length and even length, we need to expand from one central or from two central, so there are n + n-1 central in total.\n\n``` Java\npublic String longestPalindrome(String s) {\n    if (s.length() == 1) {\n        return s;\n    }\n\n    String result = \"\";\n\n    for (int i = 0; i < s.length() - 1; i++) {\n        // central is 1 char\n        int length = expand(s, i, i);\n        // central is 2 chars\n        int length2 = expand(s, i, i + 1);\n\n        int longer = Math.max(length, length2);\n\n        if (longer > result.length()) {\n            result = s.substring(i - (longer - 1) / 2, i + longer / 2 + 1);\n        }\n    }\n\n    return result;\n}\n\n// given string s, expand from given central\nprivate int expand(String s, int start, int end) {\n    int left = start;\n    int right = end;\n\n    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n        left--;\n        right++;\n    }\n\n    return right - left - 1;\n}\n```\n\nTime complexity: O(n<sup>2</sup>)\n\n## Solution 3 - Manacher’s Algorithm\n> Manacher's Algorithm is a linear algorithm used to find the longest palindrome substring of a string. It was invented by a man named Manacher in 1975. The biggest contribution of this algorithm is to decrease the time complexity to Linear.\n\nSee: [Manacher’s Algorithm](https://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-1/). I will have a separate blog takling about this algothm in the future.","tags":["Leetcode - Dynamic Programming","Leetcode - String"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 6: Fault Tolerant - Hystrix","url":"/Spring-Cloud-6-Fault-Tolerant-Hystrix/","content":"When implementing the microservice architecture, we usually split the services into individual microservices, and the microservices communicate through the network and call each other, resulting in a dependency relationship between them. We know that due to network issues, the service does not guarantee 100% availability. If there is a problem with a single service, there will be network delay or even call failure when calling this service, and the call failure will cause the user to refresh the page and try again. This, coupled with other service calls, increase the load on the server, causing the service to be unavailable, and eventually lead to a crash of the entire service.\n\nTo solve this problem `Netflix` created `Hystrix` library based on the circuit breaker pattern. \"Circuit breaker\" itself is a switching device. When a service fails, the fault monitoring of the circuit breaker (similar to a blown fuse) returns the service caller with an expected, manageable alternative response (`FallBack`), rather than waiting for a long time or throwing an exception that the caller cannot handle. This guarantees that the thread of service caller will not be occupied for a long time and needlessly, thereby preventing the fault from spreading in the whole distributed system.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nOf course, when the frequency of request failures is low, `Hystrix` will still return the failure directly to the client. Only when the number of failures reaches the threshold (defaults to 5 failures within 20 seconds), the circuit breaker opens and does not perform subsequent communication, but directly returns a fallback response.\n\n## Example Project\n`Feign` integrates the `Ribbon` and `Hystrix` by default, so we modify the code based on the previous article {% post_link Spring-Cloud-6-Fault-Tolerant-Hystrix 'Spring-Cloud-6-Fault-Tolerant-Hystrix' %}.\n\nIt is the service consumer that implements the microservice fault tolerance protection, which is the `service-product-consumer` project. Our code are mainly changing the `service-product-consumer` project, the code of other projects will remain unchanged.\n\n### 1. Hystrix Dependency\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n```\n\n### 2. Main Application\n``` Java\n@EnableFeignClients\n@EnableDiscoveryClient\n@SpringBootApplication\n@EnableCircuitBreaker\npublic class ConsumerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsumerApplication.class, args);\n    }\n}\n```\n\nAdd `@EnableCircuitBreaker` annotation to enable circuit breaker support.\n\n### 3. Implement ProductService Fallback\nAdd a concrete class to implement `ProductService` interface.\n\n``` Java\n@Component\npublic class ProductServiceFallback implements ProductService {\n    @Override\n    public List<Product> findAll() {\n        return Collections.emptyList();\n    }\n\n    @Override\n    public Product loadByItemCode(String itemCode) {\n        return new Product(\"error\", \"Unknown\", \"Unknown\", 0);\n    }\n}\n```\n\n### 4. Enable ProductService to have fault tolerance\n``` Java\n@FeignClient(value = \"PRODUCT-SERVICE\", fallback = ProductServiceFallback.class)\npublic interface ProductService {\n    @RequestMapping(value = \"/products\", method = RequestMethod.GET)\n    List<Product> findAll();\n\n    @RequestMapping(value = \"/products/{itemCode}\", method = RequestMethod.GET)\n    Product loadByItemCode(@PathVariable(\"itemCode\") String itemCode);\n}\n```\n\nJust need to add fallback configuration to `@FeignClient` annotation, and set it to the fallback class `ProductServiceFallback`.\n\n### Enable Hystrix on Feign \nAdd the following configuration to application.properties.\n\n``` Java\nfeign.hystrix.enabled=true\n```\n\n### 5. Fault Tolerance Testing\n1. First, we start `Eureka Server`, two `PRODUCT-SERVICE` and `PRODUCT-SERVICE-CONSUMER`. After starting, we can see the registered services in the monitoring interface of `Eureka Server`:\n{% asset_img 2.png %}\n<br/>\n<br/>\n\n2. Visit: http://localhost:9090/products/item-3.\n{% asset_img 3.png %}\n<br/>\n<br/>\nMeans our service call is success.\n\n3. Now We stopped the `PRODUCT-SERVICE` service with port 2100. At this time, we can see that the registered services are as follows in the monitoring interface of `Eureka Server`, indicating that one of the `PRODUCT-SERVICE` has been down, and at this time, we can still get the correct response by visiting: http://localhost:9090/products/item-3:\n{% asset_img 4.png %}\n<br/>\n<br/>\n\n4. We continue to stop the `PRODUCT-SERVICE` service with port 2200. At this time, we can see that the registered services are as follows. Note that all `PRODUCT-SERVICE` services have been down. At this time, if we visit: http://localhost:9090/products/item-3, we will see the fallback response:\n{% asset_img 5.png %}\n<br/>\n<br/>\n{% asset_img 6.png %}\n\nIt can be seen that FallBack has been activated. When all `PRODUCT-SERVICE` does not work, the `ProductService` in `PRODUCT-SERVICE-CONSUMER` has entered a fallback process.\n\n## Hystrix Fault Tolerance Principle\n**Request encapsulation:** Whether it is `HystrixCommand` or `HystrixObervableCommand`, you can see from the class name that `Hystrix` actually uses \"command mode\". The command mode is used to encapsulate service call, and each command is executed in a separate thread;\n\n**Trip mechanism:** When the error rate of a service exceeds a certain threshold (default 5 failures within 20 seconds), `Hystrix` can automatically or manually perform a service trip and stop requesting the service for a period of time;\n\n**Resource isolation:** `Hystrix` maintains a small thread pool for each service dependency. If the thread pool is full, requests to the service will be rejected immediately instead of waiting in a queue, thereby speeding up the determination of service failure;\n\n**Service monitoring:** `Hystrix` can monitor operational indicators and configuration changes in near real time, such as the success, failure, timeout, and rejection of requests;\n\n**Fallback mechanism:** When the request fails, times out, rejected, or when the circuit breaker is opened, the corresponding fallback logic is executed;\n\n**Self-healing:** When the circuit breaker is opened for a period of time, `Hystrix` will enter a \"half open\" state. The circuit breaker will allow a request to try to make a request to the service. If the service can be successfully called, close the circuit breaker, otherwise the circuit breaker will continue turn on.\n\n## Hystrix Monitoring\nIn addition to implementing service fault tolerance, `Hystrix` also provides monitoring of service requests: the number of requests executed per second, the number of successes, and so on. Enabling monitoring of `Hystrix` is very simple. One is to add `spring-cloud-starter-netflix-hystrix`. The other is to add `spring-boot-starter-actuator`, which enables the `/ hystrix-stream` endpoint to obtain monitoring data from `Hystrix`.\n\n### Use Spring Boot Actuator\n#### 1. Add dependency\n``` Xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n#### 2. application.properties\n``` Java\nmanagement.endpoints.web.exposure.include=hystrix.stream\n```\n\n#### 3. Testing Monitor\nAfter starting `PRODUCT-SERVICE-CONSUMER`, and call the service: http://localhost:9090/products/item-3. Then visit: http://localhost:9090/actuator/hystrix.stream:\n{% asset_img 7.png %}\n<br/>\n<br/>\n\nWe can see that the page will repeatedly output some statistics. It is very hard to read the data. Fortunately, `Hystrix`  provides us with a visual interface to view these data.\n\n### Hystrix Dashboard\nWe can integrate `Hystrix Dashboard` with `PRODUCT-SERVICE-CONSUMER`\n\n#### 1. Dependency\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\n</dependency>\n```\n        \n#### 2. Main application\n``` Java\n@EnableFeignClients\n@EnableDiscoveryClient\n@SpringBootApplication\n@EnableCircuitBreaker\n@EnableHystrixDashboard\npublic class ConsumerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsumerApplication.class, args);\n    }\n}\n```\n\nAdd `@EnableHystrixDashboard` annotation to enable `Hystrix Dashboard`.\n\n#### 3. Start service\nStart `PRODUCT-SERVICE-CONSUMER`. Visit: http://localhost:9090/hystrix:\n{% asset_img 8.png %}\n<br/>\n<br/>\n\nThe Dashboard has been started successfully. Then enter the previous address in the interface: http://localhost:9090/actuator/hystrix.stream, and then click `[Monitor Stream]` to see the statistics report page:\n{% asset_img 9.png %}\n<br/>\n<br/>\n\nWe can see statistics for two service interfaces: `findAll` and `loadByItemCode`.\n\nThe statistical information of each method contains two important graphical information: a solid circle and a curve.\n\n**Solid circles:** Two indications. The color indicates the health of the instance, which decreases from green, yellow, orange, and red. The size changes according to the size of the requested traffic. The larger the traffic, the larger the solid circle, and vice versa.\n**Curve:** Statistics about the change of request traffic within 2 minutes, and the curve can be used to analyze the rising and falling trends of the traffic.\n\nThe meaning of the numbers in the interface is as follows (image from https://github.com/Netflix-Skunkworks/hystrix-dashboard/wiki):\n{% asset_img 10.png %}\n<br/>\n<br/>\n\nOn the Dashboard homepage, we know that `Hystrix Dashboard` supports three monitoring methods:\n**Default cluster monitoring:** via http://turbine-hostname:port/turbine.stream, monitor the default cluster;\n**Specified cluster monitoring:** via http://turbine-hostname:port/turbine.stream?Cluster=[clusterName] to monitor the specified `clusterName` cluster;\n**Single-machine application monitoring:** http://hystrix-app:port/hystrix.stream to achieve monitoring of a service instance.\n\nThe above example demonstrated the third way.\n\nCheck out the source code here: [hystrix demo](https://github.com/nicklee1006/SpringCloudDemo/tree/hystrix-demo)","categories":["Spring Cloud"]},{"title":"Leetcode 90. Subsets II","url":"/Leetcode-90-Subsets-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nReturn all subsets of a set of integers (may contain duplicates).\n\n### Similar Questions\n* Medium - {% post_link Leetcode-78-Subsets '78. Subsets' %}\n\n## Solution\nWe can revise the solution of {% post_link Leetcode-78-Subsets '78. Subsets' %}. Let's take a look at what would happen if we followed the idea of {% post_link Leetcode-78-Subsets '78. Subsets' %} directly. The previous idea was to add in first element, then add in second element to the subset formed previous. With n-th element, that is add n-th element to all previously formed subset\n\nFor example, the iteration process of nums[1, 2, 3].\n```\ninitialize empty list:      []\n1st iteration (nums[k] = 1):[[], [1]]\n2nd iteration (nums[k] = 2):[[], [1], [2], [1, 2]]\n3rd iteration (nums[k] = 3):[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n```\n\nBut what happens if there are duplicate numbers?\n\nE.g, nums[1, 2, 2]\n```\n1st iteration (nums[k] = 1):[[], [1]]\n2nd iteration (nums[k] = 2):[[], [1], [2], [1, 2]]\n3rd iteration (nums[k] = 2):[[], [1], [2], [1, 2], [2], [1, 2], [2, 2], [1, 2, 2]]\n```\n\nWe noticed that there are duplicate arrays.\n\nHow to avoid it? We can make a Hashset to store the results, everytime we have a new result, first sort the result, and try to add it to the set. This way we can avoid adding duplicates to the result set. Finally just need to convert the set to a list.\n\n``` Java\n// use set to avoid duplicate results\nSet<List<Integer>> results = new HashSet<>();\n\n// add empty list\nresults.add(new ArrayList<>());\n\nfor (int num : nums) {\n    List<List<Integer>> temp = new ArrayList<>();\n\n    for (List<Integer> existing : results) {\n        List<Integer> newListAppend = new ArrayList<>(existing);\n        newListAppend.add(num);\n\n        // sort the result\n        Collections.sort(newListAppend);\n\n        temp.add(newListAppend);\n    }\n\n    // if duplicate result, then wouldn't add to set\n    results.addAll(temp);\n}\n\nreturn new ArrayList<>(results);\n```","tags":["Leetcode - Array","Leetcode - Backtracking"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 81. Search in Rotated Sorted Array II","url":"/Leetcode-81-Search-in-Rotated-Sorted-Array-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nFollow up question on {% post_link Leetcode-33-Search-in-Rotated-Sorted-Array '33. Search in Rotated Sorted Array' %}. This time the array may contain duplicates\n\n### Similar Questions\n* Medium - {% post_link Leetcode-33-Search-in-Rotated-Sorted-Array '33. Search in Rotated Sorted Array' %}\n\n## Solution\nFor this question we can extend the solution from {% post_link Leetcode-33-Search-in-Rotated-Sorted-Array '33. Search in Rotated Sorted Array' %}. The algorithm is based on the fact that after splitting an array from any position, it is at least half sorted.\n\nFor example, [4 5 6 7 1 2 3], and split from 7, the left is [4 5 6 7], the right is [7 1 2 3]. So the left part is ordered.\n\nWe can find out which part is in order (by comparing the endpoints). Knowing which part is in order, all we need is the normal binary search and check if the target is in this part. If it is, Then discard the other half. If not, discard this half.\n\nThat is the approach we used for {% post_link Leetcode-33-Search-in-Rotated-Sorted-Array '33. Search in Rotated Sorted Array' %}. With this question, we need a slight modification. As for this question, we have duplicates in the array. So when we decide which part is in order, there is a problem. \n\nFor example, `nums = [ 1, 3, 1, 1, 1 ]` and `targer = 3`. The left half is `[1, 3, 1]`. By comparing endpoints `nums [start] <= nums [mid]`, the algorithm thinks that left half is in order, which is not the case.\n\nSo we need to take `nums[start] == nums[mid]` as a special case. The solution is quite simple, just `start++` will do.\n\n``` Java\nint start = 0;\nint end = nums.length - 1;\n\nwhile (start <= end) {\n    int mid = (start + end) / 2;\n\n    // find target\n    if (target == nums[mid]) {\n        return true;\n    }\n\n    // left side is ordered\n    if (nums[start] < nums[mid]) {\n        // target in left side\n        if (target >= nums[start] && target <= nums[mid]) {\n            end = mid - 1;\n        } else {\n            start = mid + 1;\n        }\n    // special case like [1, 3, 1]\n    } else if (nums[start] == nums[mid]) {\n        start++;\n    // right side is ordered    \n    } else {\n        // target in right side\n        if (target >= nums[mid] && target <= nums[end]) {\n            start = mid + 1;\n        } else {\n            end = mid - 1;\n        }\n    }\n}\n\nreturn false;\n```","tags":["Leetcode - Array","Leetcode - Binary Search"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 80. Remove Duplicates from Sorted Array II","url":"/Leetcode-80-Remove-Duplicates-from-Sorted-Array-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nRemove duplicates from a sorted array in-place, such that duplicates appears at most twice.\n\n### Similar Questions\n* Easy - [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\n\n## Solution\nMake use of 2 pointers. `Slow pointer` point to the element that satisfy the condition (appears at most twice). `Fast pointer` always move forward and loop through the array. We can use a variable to record how many times the element of `slow pointer` have occurred.\n\n``` Java\nint slow = 0;\nint fast;\n// count to mark number of same number\nint count = 1;\n\n// fast pointer always increase\nfor (fast = 1; fast < nums.length; fast++) {\n    if (nums[slow] == nums[fast]) {\n        // 2 pointers point to same number, but count = 1\n        // we can increase slow pointer\n        if (count < 2) {\n            slow++;\n            nums[slow] = nums[fast];\n            count++;\n        }\n    // 2 pointers point to different number\n    // reset count = 1\n    } else {\n        slow++;\n        nums[slow] = nums[fast];\n        count = 1;\n    }\n}\n\nreturn slow + 1;\n```","tags":["Leetcode - Array","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 5: Declarative REST Client - Feign","url":"/Spring-Cloud-5-Declarative-REST-Client-Feign/","content":"In the previous blog, we can find that when we call the API through `RestTemplate`, the parameters must be spliced in the request URL. If there are only a few parameters, we may still be able to tolerate it. Once there are multiple parameters, then splicing the request string would be inefficient and seem silly. So is there a better solution? The answer is yes, Netflix has provided us with a framework: `Feign`.\n\n`Feign` is a declarative Web Service client, and its purpose is to make Web Service calls easier. `Feign` provides a template for HTTP requests. By writing a simple interface and annotations, you can define the parameters, format, and address of the HTTP request. `Feign` will proxy HTTP requests, and we only need to call it like a method to complete the service request.\n\n`Feign` integrates `Ribbon` and `Hystrix` (I will talk about `Hystrix` later), so that we no longer need to use these two components explicitly. In addition, `Spring Cloud` also provides Spring MVC annotation support for `Feign`, which also allows us to use the same `HttpMessageConverter` in the Web.\n\nIn summary, Feign has the following characteristics:\n* Annotation support, including `Feign` annotations and `JAX-RS` annotations;\n* Support HTTP encoder and decoder;\n* Support `Hystrix` and its Fallback;\n* Support `Ribbon` load balancing;\n* Supports compression of HTTP requests and responses.\n\n## Example Project\nIn this example we will build an e-mall project. We have a `Product-Service` provides product services. It is an `Eureka Client`, and is a service provider. `Product-Service-Consumer` is also an `Eureka Client`. As a service consumer, it uses `Feign`. The `Service-Discovery` remains unchanged (we can directly reuse the code in previous article).\n\n{% asset_img architecture.png %}\n<br/>\n<br/>\n\n### Product-Service\n#### 1. pom.xml\n`Product-Service` is a standard `Eureka Client`, so `pom.xml` is the same as the previous `Service-Hello`\n``` Xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n    </dependency>\n</dependencies>\n```\n\n#### 2. Main class\n``` Java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class ProductServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ProductServiceApplication.class, args);\n    }\n}\n```\n\nThis is same as previous blogs\n\n#### 3. Product entity\n``` Java\npublic class Product {\n    // ========================================================================\n    // fields =================================================================\n    private String itemCode;\n    private String name;\n    private String brandName;\n    private int price;\n\n    // ========================================================================\n    // constructor ============================================================\n    public Product() {\n    }\n\n    public Product(String itemCode, String name, String brandName, int price) {\n        this.itemCode = itemCode;\n        this.name = name;\n        this.brandName = brandName;\n        this.price = price;\n    }\n\n    public String getItemCode() {\n        return itemCode;\n    }\n\n    public void setItemCode(String itemCode) {\n        this.itemCode = itemCode;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getBrandName() {\n        return brandName;\n    }\n\n    public void setBrandName(String brandName) {\n        this.brandName = brandName;\n    }\n\n    public int getPrice() {\n        return price;\n    }\n\n    public void setPrice(int price) {\n        this.price = price;\n    }\n}\n```\n\n#### 4. Product service\n``` Java\n@RestController\n@RequestMapping(\"/products\")\npublic class ProductEndpoint {\n    private static final Logger LOGGER = LoggerFactory.getLogger(ProductEndpoint.class);\n\n    private List<Product> products;\n\n    @Value(\"${server.port}\")\n    private int serverPort = 0;\n\n    public ProductEndpoint() {\n        products = new ArrayList<>();\n        products.add(new Product(\"item-1\", \"test-1\", \"brand1\", 100));\n        products.add(new Product(\"item-2\", \"test-2\", \"brand2\", 200));\n        products.add(new Product(\"item-3\", \"test-3\", \"brand3\", 300));\n        products.add(new Product(\"item-4\", \"test-4\", \"brand4\", 400));\n        products.add(new Product(\"item-5\", \"test-5\", \"brand5\", 500));\n        products.add(new Product(\"item-6\", \"test-6\", \"brand6\", 600));\n    }\n\n    @RequestMapping(method = RequestMethod.GET)\n    public List<Product> list() {\n        LOGGER.info(\"Server port {}\", serverPort);\n\n        return this.products;\n    }\n\n    @RequestMapping(value = \"/{itemCode}\", method = RequestMethod.GET)\n    public Product detail(@PathVariable String itemCode) {\n        LOGGER.info(\"Server port {}\", serverPort);\n\n        for (Product product : products) {\n            if (product.getItemCode().equalsIgnoreCase(itemCode))\n                return product;\n        }\n        return null;\n    }\n}\n```\n\nThis service provides the following two interfaces:\n* list: get product list;\n* detail: get detailed data of the specified product.\n\n#### 5. application.properties\n``` Java\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n\nserver.port=2100\n\nspring.application.name=PRODUCT-SERVICE\n```\n\n#### 6. Launch Testing\nStart `Service-discovery` and `Product-Service`, we can see that `PRODUCT-SERVICE` has registered in the `Eureka server`.\n{% asset_img admin.png %}\n<br/>\n<br/>\n\n### Product-Service-Consumer\n#### 1. pom.xml\n``` Xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-openfeign</artifactId>\n    </dependency>\n</dependencies>\n```\n\n#### 2. Main class\n``` Java\n@EnableFeignClients\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class MallApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MallApplication.class, args);\n    }\n}\n```\n\nWe added the `@EnableFeignClients` annotation to the startup class to enable `Feign` related functions.\n\n#### 3. Service call class\n`Spring Cloud` creates a proxy class that can be called directly by the application according to this interface. In order to complete the proxy, we need to add some annotations, where `@FeignClient` is the `PRODUCT-SERVICE` defined by the `Product-Service`. `@RequestMapping` is an annotation of SpringMVC, which corresponds to two API interfaces provided in the `Product-Service`.\n``` Java\n@FeignClient(value = \"PRODUCT-SERVICE\")\npublic interface ProductService {\n    @RequestMapping(value = \"/products\", method = RequestMethod.GET)\n    List<Product> findAll();\n\n    @RequestMapping(value = \"/products/{itemCode}\", method = RequestMethod.GET)\n    Product loadByItemCode(@PathVariable(\"itemCode\") String itemCode);\n}\n```\n\n> Note: if your service compiles a jar package separately, you need to specify the value of `basePackages` when using the `@EnableFeignClients` annotation. Otherwise, there will be an error reporting `ProductService` bean cannot be found when autowiring.\n\n``` Java\n@EnableFeignClients(basePackages = \"com.feigndemo.**\")\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class MallApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MallApplication.class, args);\n    }\n}\n```\n\n#### 4. Controller\nThe Controller is a standard SpingMVC Controller, which is used to provide users with specific services.\n``` Java\n@RestController\n@RequestMapping(\"/products\")\npublic class ProductController {\n    @Autowired\n    private ProductService productService;\n\n    @RequestMapping(method = RequestMethod.GET)\n    public List<Product> list() {\n        return this.productService.findAll();\n    }\n\n    @RequestMapping(value = \"/{itemCode}\", method = RequestMethod.GET)\n    public Product detail(@PathVariable String itemCode) {\n        return this.productService.loadByItemCode(itemCode);\n    }\n}\n```\n\n#### 5. application.properties\n``` Java \neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n\nserver.port=9090\n\nspring.application.name=PRODUCT-SERVICE-CONSUMER\n```\n\n#### 6. Launch Testing\nStart `Product-Service-Consumer`, and visit: http://localhost:9090/products\n{% asset_img admin2.png %}\n<br/>\n<br/>\n\nAnd visiting http://localhost:9090/products/item-3\n{% asset_img admin3.png %}\n<br/>\n<br/>\n\n## Parameter Binding\n`Feign` supports a variety of annotations. When using `Feign`, we can use `Feign`'s own annotations or `JAX-RS` annotations as needed. Spring Cloud has enhanced `Feign` so that `Feign` supports Spring MVC annotations. As above code:\n``` Java\n@RequestMapping(value = \"/products\", method = RequestMethod.GET)\nList<Product> findAll();\n\n@RequestMapping(value = \"/products/{itemCode}\", method = RequestMethod.GET)\nProduct loadByItemCode(@PathVariable(\"itemCode\") String itemCode);\n```\n\nWe are using Spring MVC annotations. The annotations we commonly use in Spring MVC are:\n* `@RequestParam` binds a single request parameter value;\n* `@PathVariable` binds the URI template variable value;\n* `@RequestHeader` binds the request header data;\n* `@RequestBody` binds the requested content area data and can perform automatic type conversion, etc.\n\nExample of using `@RequestParam`, `@PathVariable`, and `@RequestHeader`:\n``` Java\n@RequestMapping(value = \"/products/detail\", method = RequestMethod.GET)\nProduct loadByItemCode(@RequestParam(\"itemCode\") String itemCode);\n\n@RequestMapping(value = \"/products/{itemCode}\", method = RequestMethod.GET)\nProduct loadByItemCode(@PathVariable(\"itemCode\") String itemCode);\n\n@RequestMapping(value = \"/products/detail\", method = RequestMethod.GET)\nProduct loadByItemCode(@RequestHeader(\"itemCode\") String itemCode);\n```\n\nOf course, we can also use multiple parameter binding, as follows:\n``` Java\n@RequestMapping(value = \"/products/{itemCode}\", method = RequestMethod.POST)\nProduct changPrice(@PathVariable(\"itemCode\") String itemCode, @RequestParam(\"price\") int price);\n```\n\n### Pass object as parameter\nWhen we define an interface, we often include an object in the parameters. For example, our service interface is as follows:\n``` Java\nUser register(User user);\n```\n\nSo how to pass complex `user` object? Just use the `@RequestBody` as follows:\n``` Java\n@RequestMapping(value = \"/users/register\", method = RequestMethod.POST)\nUser register(@RequestBody User user);\n```\n\n> When using it, you need to pay attention that `User` object must have a default constructor, otherwise `Feign` will not be able to convert to the `User` object according to the JSON string, thereby throwing an exception, causing the call to fail.\n\nCheck out the source code here: [Feign demo](https://github.com/nicklee1006/SpringCloudDemo/tree/feign-demo)","categories":["Spring Cloud"]},{"title":"Leetcode 79. Word Search","url":"/Leetcode-79-Word-Search/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nSearch if adjacent chars in a 2D board can form the given word.\n\n### Similar Questions\n* Hard - [212. Word Search II](https://leetcode.com/problems/word-search-ii/)\n\n## Solution\nWe can think of the matrix as a graph, and then use the DFS traversal.\n\nWhat we need to do is to determine whether the current traversal element corresponds to the word during the DFS process. If there is no match, end the current traversal, return to previous element, and try other paths. Of course, just like ordinary DFS, we need a visited array to mark whether the element has been visited.\n\n``` Java\npublic boolean exist(char[][] board, String word) {\n    int row = board.length;\n    int col = board[0].length;\n\n    if (row == 0) {\n        return false;\n    }\n\n    // mark if the point is visited\n    boolean[][] visited = new boolean[row][col];\n\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            // (i, j) as a start point\n            if (dfs(board, visited, i, j, word, 0)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n// true if start from (row, col), can find a solution\n// charIndex is the index of char in the word\nprivate boolean dfs(char[][] board, boolean[][] visited, int row, int col, String word, int charIndex) {\n    // check index out bound\n    if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) {\n        return false;\n    }\n\n    // check if the grid has been visited\n    // or the char doesn't match\n    if (visited[row][col] || word.charAt(charIndex) != board[row][col]) {\n        return false;\n    }\n\n    // already match the word\n    if (charIndex == word.length() - 1) {\n        return true;\n    }\n\n    // mark current grid as visited\n    visited[row][col] = true;\n\n    // check up\n    boolean up = dfs(board, visited, row - 1, col, word, charIndex + 1);\n    if (up) {\n        return true;\n    }\n\n    // check down\n    boolean down = dfs(board, visited, row + 1, col, word, charIndex + 1);\n    if (down) {\n        return true;\n    }\n\n    // check left\n    boolean left = dfs(board, visited, row , col - 1, word, charIndex + 1);\n    if (left) {\n        return true;\n    }\n\n    // check right\n    boolean right = dfs(board, visited, row, col + 1, word, charIndex + 1);\n    if (right) {\n        return true;\n    }\n\n    visited[row][col] = false;\n    return false;\n}\n```","tags":["Leetcode - Array","Leetcode - Backtracking"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 78. Subsets","url":"/Leetcode-78-Subsets/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nReturn all subsets of a set of distinct integers.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-90-Subsets-II '90. Subsets II' %}\n* Medium - [784. Letter Case Permutation](https://leetcode.com/problems/letter-case-permutation/)\n\n## Solution - Iteration\nFirst consider all subset of 1 element of the given array, then all subset of 2 elements of the array ... and finally all subset of n elements of the array. To find all subset of k elements, just add `nums[k]` to all subset of k-1 element.\n\nFor example, the iteration process of nums[1, 2, 3].\n```\ninitialize empty list:      []\n1st iteration (nums[k] = 1):[[], [1]]\n2nd iteration (nums[k] = 2):[[], [1], [2], [1, 2]]\n3rd iteration (nums[k] = 3):[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n```\n\n``` Java\n// result list\nList<List<Integer>> results = new ArrayList<>();\n\n// add empty list\nresults.add(new ArrayList<>());\n\nfor (int num : nums) {\n    // append nums[i] to all existing list\n    List<List<Integer>> temp = new ArrayList<>();\n\n    for (List<Integer> existResult : results) {\n        List<Integer> tempResult = new ArrayList<>(existResult);\n        tempResult.add(num);\n\n        temp.add(tempResult);\n    }\n\n    results.addAll(temp);\n}\n\nreturn results;\n```\n\nOther solutions: [backtracking](https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)\nOther solutions: [bit manipulation](https://leetcode.com/problems/subsets/discuss/27278/C%2B%2B-RecursiveIterativeBit-Manipulation)","tags":["Leetcode - Array","Leetcode - Backtracking","Leetcode - Bit Manipulation"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 4: Load Balancer - Ribbon","url":"/Spring-Cloud-4-Load-Balancer-Ribbon/","content":"Before microservices, the load balancing solution was mainly a centralized load balancer. There was another independent load balancer between service consumers and service providers. Load balancer is usually specialized hardware, such as F5, or software-based, such as VS, HAproxy. There is an address mapping table for all services on the load balancer. When a service consumer invokes a target service, it initiates a request to the load balancer, and the load balancer forwards the request to the target server after performing load balancing using a certain strategy (such as Round-Robin).\n\nThe emergence of microservices provides another idea for the implementation of load balancer: encapsulate the functions of load balancing into a library and integrate it with the service consumer's process, rather than provide a centralized device or server. This solution is called `Soft Load Balancing` or `Client Load Balancing`. In conjunction with the service discovery function of `Eureka` in Spring Cloud, the `Ribbon` sub-project implements load balancing for REST clients.\n\n## Example Project\n### 1. We can extend the eureka demo project\nCode: [Eureka demo](https://github.com/nicklee1006/SpringCloudDemo/tree/eureka-demo)\n### 2. Add Dependency to service-hello-consumer\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\n</dependency>\n```\n\n### 3. Main Class\n``` Java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class HelloServiceConsumerApplication {\n    @Bean\n    @LoadBalanced\n    RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloServiceConsumerApplication.class, args);\n    }\n}\n```\n\nIn this main class:\n* `@EnableDiscoveryClient` annotation, indicating that this is an `Eureka` client, and can also get a list of services registered in the `Eureka server`;\n* We have added a `@LoadBalanced` annotation to the `RestTemplate`. This annotation enables the `RestTemplate` to enable client load balancing function.\n\n### 4. Load Balancing Test\n* 4.1 Start `Eureka server`\n* 4.2 Start multiple service provider: service-hello. Here I started 2 services.\n``` bash\njava -jar service-hello-0.0.1-SNAPSHOT.jar\njava -jar service-hello-0.0.1-SNAPSHOT.jar --server.port=2200\n```\n* 4.3 Start service consumer: service-hello-consumer\n* 4.4 Open the Eureka server admin page: http://localhost:8761, we can see that two `HELLO-SERVICE` services and one `HELLO-CONSUMER` service have been registered.\n{% asset_img admin.png %}\n<br/>\n<br/>\n\n* 4.5 Visit `Hello-Consumer`: http://localhost:8080/hello and refresh it multiple times. We can see the following two outputs appear alternately:\n{% asset_img page1.png %}\n<br/>\n<br/>\n{% asset_img page2.png %}\n<br/>\n<br/>\nIt shows that `hello-consumer` is accessing two service instances of `HELLO-SERVICE` alternately, which means that our load balancing test is successful.\n\n## Ribbon's load balancing strategy\nRibbon itself provides the following load balancing strategies:\n\n* **RoundRobinRule:** Round robin policy. `Ribbon` selects the server in round robin manner. This is the default value. So the two services started in the example will be cyclically accessed;\n* **RandomRule:** Random selection, which means that `Ribbon` will randomly select one from the server list to access randomly;\n* **BestAvailableRule:** The maximum availability policy. After filtering out the failed server, select the one with the lowest number of concurrent requests;\n* **WeightedResponseTimeRule:** With a weighted polling strategy. The response time of each server is weighted, and then the corresponding server is obtained by polling;\n* **AvailabilityFilteringRule:** Available filtering strategy. First filter out some service instances that have failed or concurrent requests are larger than the threshold, and then select one from the filtered instance list in a linear polling manner;\n* **ZoneAvoidanceRule:** Zone-aware strategy. First use the primary filter (zone loader, select the optimal zone) to filter all instances and return the filtered instance list. Use the filters in the secondary filter condition list to perform on the results of the primary filter. Determine the minimum number of filters (default 1) and the minimum percentage of filtering (default 0), and finally use `RoundRobinRule` (polling method) to select a server instance from the server that meets the conditions.\n\n> We can implement our own load balancing strategy by inheriting `ClientConfigEnabledRoundRobinRule`.\n\nCheck out the source code here: [Ribbon demo](https://github.com/nicklee1006/SpringCloudDemo/tree/ribbon-demo)","categories":["Spring Cloud"]},{"title":"Leetcode 75. Sort Colors","url":"/Leetcode-75-Sort-Colors/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGive an array containing only 0, 1, and 2, sort the numbers from small to large.\n\n### Similar Questions\n* Medium - [148. Sort List](https://leetcode.com/problems/sort-list/)\n* Medium - [324. Wiggle Sort II](https://leetcode.com/problems/wiggle-sort-ii/)\n\n## Solution 1\nA very straightforward method. Requires 2 iterations. During first iteration, count the number of occurrences of 0, the number of occurrences of 1, and the number of occurrences of 2. During second iteration, traverse the array and change the elements of the array to the corresponding values according to the number of occurrences. Of course we only need to record 0 and 1, and the rest is 2.\n\nTime complexity O(n), space complexity O(1).\n\n## Solution 2\nSolution 1 requires 2 iterations. Can we do better in only 1 iteration?\n\nSuppose the array only have number 0 and 1 (e.g, `1 0 1 1 0`). We can use a pointer, `zero_position`, meaning the positions before this pointer are `0`. Then use a pointer `i` to traverse the array, find 0 and put 0 to the position pointed by `zero_position`, and move `zero_position` forward. Let `Z` be `zero_position` and see the traversal process below.\n```\n1 0 1 1 0   Initialize Z,i point to position 0，move forward i\n^\nZ\ni\n\n1 0 1 1 0   Find 0，exchange value at Z and i, move forward Z\n^ ^\nZ i\n\n0 1 1 1 0   Move forward i\n  ^\n  i\n  Z\n\n0 1 1 1 0  Move forward i\n  ^ ^\n  Z i\n\n0 1 1 1 0  Move forward i\n  ^   ^\n  Z   i\n\n0 1 1 1 0  Found 0，exchange value at Z and i, move forward Z\n  ^     ^\n  Z     i\n\n0 0 1 1 1  Finish\n    ^   ^\n    Z   i\n```\n\nNow We have 3 numbers, so we can use two pointers, one is `zero_position`. As before, all the positions before it are all 0. Another pointer, `two_position`. All the positions after it are all 2.\n\n```\n0 1 0 2 1 2 2 2\n  ^ ^   ^\n  Z i   T\n```\n\n``` Java\n// elements before this are all '0'\nint zeroIndex = 0;\n// elements after this are all '2'\nint twoIndex = nums.length - 1;\n\nfor (int i = 0; i <= twoIndex; i++) {\n    if (nums[i] == 0) {\n        // exchange zeroIndex with i\n        int temp = nums[zeroIndex];\n        nums[zeroIndex] = nums[i];\n        nums[i] = temp;\n\n        // move forward zeroIndex\n        zeroIndex++;\n    } else if (nums[i] == 2) {\n        // exchange twoIndex with i\n        int temp = nums[twoIndex];\n        nums[twoIndex] = nums[i];\n        nums[i] = temp;\n\n        // move backward twoIndex\n        twoIndex--;\n        // Note here since we exchanged the number after index i\n        // We haven't check this number yet. It will be skipped\n        // So we need i--, to check this number\n        i--;\n    }\n}\n```\n\nTime complexity O(n), space complexity O(1).","tags":["Leetcode - Array","Leetcode - Two Pointers","Leetcode - Sort"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 74. Search a 2D Matrix","url":"/Leetcode-74-Search-a-2D-Matrix/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nSearch a value in an m x n matrix, determine if it exists.\n\n### Similar Questions\n* Medium - [240. Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/)\n\n## Solution\nAs the martix is ordered, there is no doubt that we need to use binary search. First find which row the target belongs to, then use binary search to determine. We just need to consider how to convert the index into the row and column of the matrix. To do so, we can use division and mod.\n\n``` Java\n// matrix is empty\nif (matrix.length == 0 || matrix[0].length == 0) {\n    return false;\n}\n\nint col = matrix[0].length;\n\n// loop each row, find which row the target belongs to\nfor (int[] ints : matrix) {\n    // target in this row\n    if (target >= ints[0] && target <= ints[col - 1]) {\n        // use binary search to this row\n        int low = 0;\n        int high = col - 1;\n\n        while (low <= high) {\n            int mid = (low + high) / 2;\n\n            if (target == ints[mid]) {\n                return true;\n            } else if (target < ints[mid]) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return false;\n    }\n}\n\nreturn false;\n```","tags":["Leetcode - Array","Leetcode - Binary Search"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 64. Minimum Path Sum","url":"/Leetcode-64-Minimum-Path-Sum/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nFrom top left to bottom right, find a path that minimize the sum along the path.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-62-Unique-Paths '62: Unique Paths' %}\n* Hard - [174. Dungeon Game](https://leetcode.com/problems/dungeon-game/)\n* Hard - [741. Cherry Pickup](https://leetcode.com/problems/cherry-pickup/)\n\n## Solution\nDefine a 2D array. Each element of the array represent the minimum sum starting from top left point to this point. For example, `dp[i][j] = 5` means that starting from `(0, 0)` to `(i, j)`, the minimum sum is 5.\n\nThe value on the first row, it is only reachable from its left point. And first column is only reachable from its up point.\n\nFor other points, the minimum sum is the sum of itself and minimum value of the point up it and left to it. Thus we have our dynamic programming formula: `dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1])`. And we start to fill the dp array from second row.\n\n``` java\n// result grid\nint[][] dp = new int[grid.length][grid[0].length];\n\ndp[0][0] = grid[0][0];\n\n// fill the first row, one reachable from its left point\nfor (int i = 1; i < grid[0].length; i++) {\n    dp[0][i] = dp[0][i - 1] + grid[0][i];\n}\n\n// fill the first column, one reachable from its up point\nfor (int i = 1; i < grid.length; i++) {\n    dp[i][0] = dp[i - 1][0] + grid[i][0];\n}\n\n// only one row or column\nif (grid.length == 1 || grid[0].length == 1) {\n    return dp[grid.length - 1][grid[0].length - 1];\n}\n\n// start from [1, 1], fill the result array\nfor (int i = 1; i < grid.length; i++) {\n    for (int j = 1; j < grid[0].length; j++) {\n        dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);\n    }\n}\n\nreturn dp[grid.length - 1][grid[0].length - 1];\n```","tags":["Leetcode - Dynamic Programming","Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 3: Eureka Clustering","url":"/Spring-Cloud-3-Eureka-Clustering/","content":"Last post we talked about `Eureka`. It is one of the key elements of Spring Cloud. Service center as a critical service, if it is a single point and having a failure then it is devastating. In a distributed system, the service center is the most important part and should be in a state that can provide services at any time. To maintain its availability, using clusters is a good solution. `Eureka` achieves high availability deployment by registering with each other, so we only need to configure `Eureke Server` with other available `serviceUrl` to achieve high availability deployment.\n\n## Two-node service center\nFirst let's try to setup a two-node service center.\n\n### 1. Create application-peer1.properties\n`Peer1` service center's configuration. Pointing `serviceUrl` to `peer2`.\n``` Java\nspring.application.name=spring-cloud-eureka-server\nserver.port=8000\neureka.instance.hostname=peer1\n\neureka.client.register-with-eureka=true\neureka.client.fetch-registry=true\n\neureka.client.serviceUrl.defaultZone=http://peer2:8001/eureka/\n```\n\n### 2. Create application-peer2.properties\n`Peer2` service center's configuration. Pointing `serviceUrl` to `peer1`.\n``` Java\nspring.application.name=spring-cloud-eureka-server\nserver.port=8001\neureka.instance.hostname=peer2\n\neureka.client.register-with-eureka=true\neureka.client.fetch-registry=true\n\neureka.client.serviceUrl.defaultZone=http://peer1:8000/eureka/\n```\n\n### 3. Host file\nAdd the following 2 lines to `hosts` file\n```\n127.0.0.1 peer1  \n127.0.0.1 peer2  \n```\n\n### Start server\nRun the following command\n``` bash\n# package jar file\nmvn clean package\n# start eureka server using 2 configurations\njava -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1\njava -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2\n```\n\nVisit `http://localhost:8000/`\n{% asset_img page1.png %}\n<br/>\n<br/>\n\nWe can see that `peer1`'s service center DS Replicas already has the configuration information of `peer2`, and `peer2` appears in available-replicas. If we manually stopped `peer2`, then `peer2` would move to the unavailable-replicas column, indicating that peer2 was unavailable.\n\n## Use eureka cluster\nIn production, we may need three or more service centers to ensure the stability of the service. The configuration are actually the same: pointing the service centers to other service centers. Here I will only introduce the configuration of only three clusters. In fact, it is similar to the two-node service center. Each service center can point to the other two nodes.\n\napplication-peer1.properties\n``` Java\nspring.application.name=spring-cloud-eureka-server\nserver.port=8000\neureka.instance.hostname=peer1\n\neureka.client.register-with-eureka=true\neureka.client.fetch-registry=true\n\neureka.client.serviceUrl.defaultZone=http://peer2:8001/eureka/, http://peer3:8002/eureka/\n```\n\napplication-peer2.properties\n``` Java\nspring.application.name=spring-cloud-eureka-server\nserver.port=8001\neureka.instance.hostname=peer2\n\neureka.client.register-with-eureka=true\neureka.client.fetch-registry=true\n\neureka.client.serviceUrl.defaultZone=http://peer1:8000/eureka/, http://peer3:8002/eureka/\n```\n\napplication-peer3.properties\n``` Java\nspring.application.name=spring-cloud-eureka-server\nserver.port=8002\neureka.instance.hostname=peer3\n\neureka.client.register-with-eureka=true\neureka.client.fetch-registry=true\n\neureka.client.serviceUrl.defaultZone=http://peer1:8000/eureka/, http://peer2:8001/eureka/\n```\n\nStart `peer1`, `peer2`, `peer3` eureka server\n``` bash\njava -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1\njava -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2\njava -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer3\n```\n\nVisit `http://localhost:8000/`\n{% asset_img page2.png %}\n<br/>\n<br/>\n\nWe can see `peer2` and `peer3`'s information in `peer1`\n\nCheck out the source code here: [Eureka cluster demo](https://github.com/nicklee1006/SpringCloudDemo/tree/eureka-cluster-demo)","categories":["Spring Cloud"]},{"title":"Spring Cloud 2: Service Discovery - Eureka","url":"/Spring-Cloud-2-Service-Discovery/","content":"`Eureka` is a Netflix open source product that provides service registration and discovery. It provides a complete implementation of `Service Registry` and `Service Discovery`. It is also one of the most important and core components of Spring Cloud.\n\n## Service Center\nThe service center is also called the registration center, which manages various service functions including service registration, discovery, fusing, load balancing, and downgrading. So how does it makes service call easier? Let's see an example.\n\nWithout service center, we have `service A` calls `service B`, and `service B` calls `service C`.\n{% asset_img service1.png %}\n<br/>\n<br/>\n\nWith service center, the service calls have two steps. In the first step, `service A` first requests the `service B` from the `service center`, and then `service B` requests the `service C` from the `service center`.\n{% asset_img service2.png %}\n<br/>\n<br/>\n\nThe above examples are just two or three simple calls to each other, but imagine if there are more than 20 and 30 services. With `service center` you do not need to know the IP address of the service you call, or how many servers it has. Each time simply go directly to the `service center` and get the services that needs to be call.\n\nSince various services are registered in the `service center`, many advanced functions can be implemented. For example, having several services providing the same service for load balancing; monitoring the service call success rate for fusing, removing fault points in the service list; monitoring service call time to set different weights for different services, and so on.\n\n## Eureka\nSpring Cloud encapsulates the `Eureka` module developed by Netflix to implement service registration and discovery. `Eureka` uses the C-S design architecture. `Eureka Server` is the server for the service registration function. It is the service registration center. The other microservices in the system use `Eureka Client` to connect to `Eureka Server` and maintain a heartbeat connection. In this way, the system maintenance staff can monitor whether the microservices in the system are running normally through `Eureka Server`. Some other modules of Spring Cloud (such as `Zuul`) can use `Eureka Server` to discover other microservices in the system and execute related logic.\n\n`Eureka` consists of two components: `Eureka Server` and `Eureka Client`. `Eureka Server` is used as a service registration server. The `Eureka Client` is a java client that is used to simplify interaction with the server, act as a polling load balancer, and provide failover support for services.\n{% asset_img service3.png %}\n<br/>\n<br/>\n\nThe above diagram briefly describes the basic architecture of `Eureka`, which consists of 3 roles:\n* **Eureka Server**: Service registration center, responsible for service registration, maintenance and query of service list\n* **Service Provider**: An `Eureka Client`, responsible for registering, renewing, and deregistering the services with `Eureka Server`. The main data provided during registration includes service name, machine IP, port number, domain name, etc., so that service consumers can find it\n* **Service Consumer**: An `Eureka Client`, will also register itself with the services provided by `Eureka Server`. Usually with consumer, it is more to obtain the corresponding service list from `Eureka Server`, so that it can initiate service calls.\n\n> Service Provider and Service Consumer are not a strict concept, often the service consumer is also a service provider, and at the same time, the service provider may also call the services provided by other service providers. Of course, when we build microservices, we still need to adhere to the division between business levels and try to avoid circular dependencies between services.\n\n## Example Project\nIn this example project, I will have 3 modules:\n* **Service-discovery**: As the service registration center and `Eureka server`\n* **Service-hello**: Service provider and `Eureka client`\n* **Service-hello-consumer**: Service consumer and `Eureka client`\n{% asset_img architecture.png %}\n<br/>\n<br/>\n\n### Service-discovery\n#### 1. Add dependency\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-dependencies</artifactId>\n    <version>Greenwich.SR4</version>\n    <type>pom</type>\n    <scope>import</scope>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n\n#### 2. Main class\n``` Java\n@EnableEurekaServer\n@SpringBootApplication\npublic class ServiceDiscoveryApplication {\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(ServiceDiscoveryApplication.class).web(WebApplicationType.SERVLET).run(args);\n    }\n}\n```\n\nThe key here is adding `@EnableEurekaServer`, to declare that it is an `Eureka server`.\n\n#### 3. Configuration file\nConfiguration is placed under `resource/application.properties`\n\n``` Java\nserver.port=8761\n\nspring.application.name=eureka-server\n\neureka.instance.hostname=localhost\neureka.client.register-with-eureka=false\neureka.client.fetch-registry=false\neureka.client.service-url.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka\n```\n\n* `eureka.client.register-with-eureka`: Whether to register itself with Eureka Server. The default is `true`.\n* `eureka.client.fetch-registry`: Whether to obtain registration information from Eureka Server. The default is `true`.\n* `eureka.client.service-url.defaultZone`: Set the address to interact with `Eureka Server`. Both the query service and the registration service need to rely on this address. The default is `http://localhost:8761/eureka`; multiple addresses can be separated by ','.\n\n#### 4. Start server\nStart the server and visit `http://localhost:8761`, should be able to see the following page:\n{% asset_img page.png %}\n<br/>\n<br/>\n\nUnder `Instance currently registered with Eureka` section, there is no service instance registered yet.\n\n### Service-hello\nIn this example, we define a simple service. It returns a string `Hello, Spring Cloud!` When calling the `/hello` service endpoint.\n\n#### 1. Add dependency\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-dependencies</artifactId>\n    <version>Greenwich.SR4</version>\n    <type>pom</type>\n    <scope>import</scope>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n#### 2. Main class\n``` Java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class HelloServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(HelloServiceApplication.class, args);\n    }\n}\n```\n\nThe difference here with the `service-discovery` is change the annotation to `@EnableDiscoveryClient`, to declare that it is an `Eureka client`.\n\n#### 3. API service\n``` Java\n@RestController\npublic class HelloEndpoint {\n    private static final Logger LOGGER = LoggerFactory.getLogger(HelloEndpoint.class);\n\n    @Autowired\n    private EurekaInstanceConfig eurekaInstanceConfig;\n    @Value(\"${server.port}\")\n    private int serverPort = 0;\n\n    @RequestMapping(value = \"/hello\", method = RequestMethod.GET)\n    public String hello() {\n        LOGGER.info(\"/hello, instanceId:{}, host:{}\", eurekaInstanceConfig.getInstanceId(), eurekaInstanceConfig.getHostName(false));\n\n        return \"Hello, Spring Cloud! My port is \" + serverPort;\n    }\n}\n```\n\nA very simple service provide only `/hello` endpoint\n\n#### 4. Configuration\n``` Java\nserver.port=2100\n\nspring.application.name=HELLO-SERVICE\n\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n```\n\nHere the `spring.application.name` must be set. Service consumer find this service by this name. `eureka.client.service-url` must also be set. It means that we want to register services with those `Eureka servers`. Here we can declare multiple `Eureka servers`\n\n#### 5. Start server\nAfter server start-up, should be able to see this console log:\n``` Java\ncom.netflix.discovery.DiscoveryClient    : DiscoveryClient_HELLO-SERVICE/192.168.1.106:HELLO-SERVICE:2100 - registration status: 204\n```\n\nRefresh http://localhost:8761:\n{% asset_img page2.png %}\n<br/>\n<br/>\n\nWe have successfully registered our service to the `Eureka server`.\n\n### Service-hello-consumer\nIn the previous sections, a simple `Eureka server` and client has been built. In order for us to better appreciate the role played by Eureka, let's build a service consumer that will call the services provided by `SERVICE-HELLO`.\n\n#### 1. Add dependency\n``` Xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-dependencies</artifactId>\n    <version>Greenwich.SR4</version>\n    <type>pom</type>\n    <scope>import</scope>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\nSame as `Service-hello`.\n\n#### 2. Main class\n``` Java\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class HelloServiceConsumerApplication {\n    @Bean\n    @LoadBalanced\n    RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloServiceConsumerApplication.class, args);\n    }\n}\n```\n\nSame as `Service-hello`, annotated with `@EnableDiscoveryClient` to declare a `Eureka client`.\n\n#### 3. Service call\n``` Java\n@RestController\npublic class HelloController {\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @RequestMapping(value = \"/hello\", method = RequestMethod.GET)\n    public String hello() {\n        return restTemplate.getForEntity(\"http://HELLO-SERVICE/hello\", String.class).getBody();\n    }\n}\n```\n\nThe service call is a standard controller. The `hello()` method will call the `SERVICE-HELLO/hello` service through the `restTemplate` and return.\n\n#### 4. Configuration\n``` Java\nserver.port=8080\n\nspring.application.name=hello-consumer\n\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n```\n\n#### 5. Start server\nAfter server start-up, should also be able to see this console log:\n``` Java\ncom.netflix.discovery.DiscoveryClient    : DiscoveryClient_HELLO-CONSUMER/192.168.1.106:hello-consumer:8080 - registration status: 204\n```\n\nRefresh http://localhost:8761:\n{% asset_img page3.png %}\n<br/>\n<br/>\n\nWe can see there are 2 services registered.\n\n#### 6. Verify the service call\nVisit http://localhost:8080/hello, should see the response:\n{% asset_img page4.png %}\n<br/>\n<br/>\n\nAlso the console log of `Service-hello` should have an output:\n``` Java\nINFO 6602 --- [nio-2100-exec-1] s.helloservice.endpoint.HelloEndpoint    : /hello, instanceId:192.168.1.106:HELLO-SERVICE:2100, host:192.168.1.106\n```\n\nNow we have successfully built our first Spring Cloud Eureka demo.\n\nCheck out the source code here: [Eureka demo](https://github.com/nicklee1006/SpringCloudDemo/tree/eureka-demo)","categories":["Spring Cloud"]},{"title":"Leetcode 63. Unique Paths II","url":"/Leetcode-63-Unique-Paths-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nSimilar to {% post_link Leetcode-62-Unique-Paths 'Question 62: Unique Paths' %}. This time given a input array to mark obstacles.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-62-Unique-Paths '62: Unique Paths' %}\n* Hard - [980. Unique Paths III](https://leetcode.com/problems/unique-paths-iii/)\n\n## Solution\nThe solution is similar to {% post_link Leetcode-62-Unique-Paths 'Question 62: Unique Paths' %}. Define a 2D array `result`. Each element of `result` represent the unique path starting from this point to bottom-right point.\n\nThe point on the last row and last column can only have 1 unique path (because we can only move right and down). However, if we traverse from the last to the first (e.g, from right to left or bottom to top), if there are any obstacle on the route, then the rest on the last row and last column is 0, as this route is blocked.\n\nFor other points, the number of unique paths is determined by unique path of the point below it and right to it. There are 3 situations:\n1. If both bottom and right point is obstacle or the position itself is obstacle, set to 0\n2. If only one of bottom and right point is obstacle, set to right or bottom \n3. Otherwise, `result[i][j] = result[i + 1][j] + result[i][j + 1]`.\n\nFinally we just need to get the value of `result[0][0]`\n\n``` Java\n// get number of columns and rows\nint columns = obstacleGrid[0].length;\nint rows = obstacleGrid.length;\n\n// result array\nint[][] result = new int[rows][columns];\n\n// check if the bottom-right point itself is obstable or not\nresult[rows - 1][columns - 1] = obstacleGrid[rows - 1][columns - 1] == 1 ? 0 : 1;\n\n// to mark if encounter any obstacle on last row\nint obstacle = 0;\n\n// fill right most column and last row with 1 or 0\nfor (int i = columns - 1; i >= 0; i--) {\n    if (obstacleGrid[rows - 1][i] == 1) {\n        obstacle = -1;\n    }\n    \n    result[rows - 1][i] = 1 + obstacle;\n}\n\n// to mark if encounter any obstacle on last column\nobstacle = 0;\nfor (int i = rows - 1; i >= 0; i--) {\n    if (obstacleGrid[i][columns - 1] == 1) {\n        obstacle = -1;\n    }\n\n    result[i][columns - 1] = 1 + obstacle;\n}\n\n// start from second last row and column\nfor (int i = rows - 2; i >= 0; i--) {\n    for (int j = columns - 2; j >= 0; j--) {\n        // both right or below point is obstacle or the point itself is obstacle\n        if ((obstacleGrid[i][j + 1] == 1 && obstacleGrid[i + 1][j] == 1) || obstacleGrid[i][j] == 1) {\n            result[i][j] = 0;\n        // the point below is obstacle\n        } else if (obstacleGrid[i][j + 1] == 1) {\n            result[i][j] = result[i + 1][j];\n        // the point at right is obstacle\n        } else if (obstacleGrid[i + 1][j] == 1) {\n            result[i][j] = result[i][j + 1];\n        } else {\n            result[i][j] = result[i][j + 1] + result[i + 1][j];\n        }\n    }\n}\n\nreturn result[0][0];\n```\n","tags":["Leetcode - Dynamic Programming","Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Spring Cloud 1: What is Spring Cloud","url":"/Spring-Cloud-1-What-is-Spring-Cloud/","content":"I have been learning Spring Cloud recently, and found it quite interesting. So I would write a series of blogs to introduce different components of Spring Cloud. Let's begin with a brief introduction of Spring Cloud.\n\nSo what is Spring Cloud? In short, Spring Cloud is a collection of a series of frameworks. It is based on Spring Boot and make use of it to simplify the development of distributed system infrastructure. Spring Cloud consists of several useful functionalities such as `service discovery`, `configuration center`, `message bus`, `load balance`, and `monitoring`. It provides a complete set of solution to build an enterprise level cloud application.\n\nSpring Cloud includes several sub-projects, such as `Spring Cloud Config`, `Spring Cloud Netflix`, `Spring Cloud Security`, etc. Spring collects those mature frameworks from different companies, uses Spring Boot style to re-encapsulate them and removes complicated configuration, and gives developers an easy-to-use, easy-to-deploy and easy-to-maintain distributed system development toolkit.\n\nWith Spring Cloud, every individual service could be a separated application. It can be deployed individually, scale horitontallly and accessed individually. Those services are service unit, which is always called `microservice` (because they are usually very 'small' service that provides a certain type of service). Spring Cloud is the manager of all those microservices. Using microservice architecture, the number of projects (modules) would be huge, but Spring Cloud facilitate the management of all that.\n\nNow let's look at some most important components of Spring Cloud. It is a brief introduction, I will discuss more details in the following blogs.\n\n## Key Components\n### Netflix Eureka\nService center. CLoud side service discovery. It's the basic of Spring Cloud. All service register themselves at the service center. If one service need to invoke another service, it can find it in the service center as well.\n\n### Netflix Hystrix\nCircuit breaker. Provides a powerful fault tolerant capability. For example, if a service is not responding, but other services are not aware of that, that failing service will affect the system performance. With Hystrix, it would notify other services that the failing service can't be used.\n\n### Ribbon\nLoad balancer.\n\n### Netflix Zuul\nDynamic routing. Zuul is the front door of all front end applications and the back end services. When users invoke services, it must go through Zuul, see if the request is valid.\n\n### Spring Cloud Config\nConfiguration center. Developer can put all configurations to a remote server and manages those together rather than manage for each individual service.\n\n### Spring Cloud Bus\nEvent and message bus.\n\n### Spring Cloud Security\nSecurity toolkit basic on Spring Security. Add security control to the cloud application.\n\n### Spring Cloud Sleuth\nLogging toolkits. Provide solution of distributed routing tracking.\n\nThe relationship between all those components:\n{% asset_img 1.png %}\n<br/>\n<br/>\n\n* All request go through API gateway `Zuul` to get access to services.\n* API gateway obtain available service from service registry `Eureka`.\n* `Ribbon` complete load balancing and dispath request to back end service instancve.\n* All microserve use `Feign` to communicate.\n* `Hystrix` handles circuit breaker if services are unavailable.\n\nThese are the main components, but there a lot more other sercices that are provided by Spring Cloud.\n\n## Relationship with Spring Boot\n`Spring Boot` can be used to develop individual microservice, while `Spring Cloud` is based on `Spring Boot` to facilitate cloud application development. One can use only `Spring Boot` to develop application without `Spring Cloud`, but to develop `Spring Cloud`, `Spring Boot` must be used. There is a dependency relationship.\n\nPlease note that there is a strict relationship with the version of `Spring Cloud` and `Spring Boot`. If the versions don't match, the system won't work. Below is the table shows the relationship.\n\n<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg .tg-axxb{font-weight:bold;background-color:#c0c0c0;color:#000000;border-color:inherit;text-align:center;vertical-align:top}\n.tg .tg-n9g5{background-color:#ffffff;color:#000000;border-color:inherit;text-align:left;vertical-align:middle}\n</style>\n<table class=\"tg\">\n  <tr>\n    <th class=\"tg-axxb\">Spring Cloud</th>\n    <th class=\"tg-axxb\">Spring Boot</th>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">Angel</td>\n    <td class=\"tg-n9g5\">Spring Boot 1.2.x</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">Brixton</td>\n    <td class=\"tg-n9g5\">Spring Boot 1.3.x, and Spring Boot 1.4.x</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">Camden</td>\n    <td class=\"tg-n9g5\">Spring Boot 1.4.x, and Spring Boot 1.5.x</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">Dalston, Edgware</td>\n    <td class=\"tg-n9g5\">Spring Boot 1.5.x, not compatiable with Spring Boot 2.0.x</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">Finchley</td>\n    <td class=\"tg-n9g5\">Spring Boot 2.0.x, not compatiable with Spring Boot 1.5.x</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">Greenwich</td>\n    <td class=\"tg-n9g5\">Spring Boot 2.1.x</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">Hoxton</td>\n    <td class=\"tg-n9g5\">Spring Boot 2.2.x</td>\n  </tr>\n</table>\n\nIn the following blogs, I will using Spring Cloud `Greenwich` version.\n\n## Advantage of Spring Cloud\nThere are other microservice frameworks, such as `Dubbo`, `Kubernetes`. What are `Spring Cloud`'s advantages compared with those?\n* It is from Spring family. Make use of `Spring Boot` makes developing individual service a lot easier.\n* The community is very active. Lots of tutorials out there, and easy to find solutions.\n* Get circuit breaker, load balance, service discovery with only a few lines of code.\n\n","categories":["Spring Cloud"]},{"title":"Leetcode 62. Unique Paths","url":"/Leetcode-62-Unique-Paths/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nCount the number of paths from top-left corner to bottom-right corner. Can only move down or right.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-63-Unique-Paths-II '63: Unique Paths II' %}\n* Medium - {% post_link Leetcode-64-Minimum-Path-Sum '64. Minimum Path Sum' %}\n* Medium - [174. Dungeon Game](https://leetcode.com/problems/dungeon-game/)\n\n## Solution\nUse the idea of dynamic programming, we can define a 2D array. Each element of the array represent the unique path starting from this point to bottom-right point. For example, `dp[i][j] = 5` means that starting from `(i, j)`, there are 5 unique paths.\n\nLet's observe the problem. The first insight we can have is that the point on the last row and last column can only have 1 unique path (because we can only move right and down).\n\nFor other points, the number of unique paths is the sum of unique path of the point below it and right to it. Thus we have our dynamic programming formula: `dp[i][j] = dp[i + 1][j] + dp[i][j + 1]`. And we start to fill the dp array from second last row.\n\n``` Java\n// dp array\nint[][] result = new int[n][m];\n\nresult[n - 1][m - 1] = 1;\n// fill last row with 1\nfor (int i = 0; i < m - 1; i++) {\n    result[n - 1][i] = 1;\n}\n\n// fill right most column with 1\nfor (int i = 0; i < n - 1; i++) {\n    result[i][m - 1] = 1;\n}\n\n// fill the table from second last row\nfor (int i = n - 2; i >= 0; i--) {\n    for (int j = m - 2; j >= 0; j--) {\n        result[i][j] = result[i][j + 1] + result[i + 1][j];\n    }\n}\n\nreturn result[0][0];\n```\n\nTime complexity O(n * m), space complexity O(n * m).","tags":["Leetcode - Dynamic Programming","Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Cron Expressions","url":"/Cron-Expressions/","content":"Cron expression is a string comprising five or six fields separated by white space that represents a set of times. It is widely used to execute some scheduled tasks. It can be used with [Spring Scheduling Tasks](https://spring.io/guides/gs/scheduling-tasks/), or linux scheduled tasks.\n\n## Expression\n&#60;second&#62; &#60;minute&#62; &#60;hour&#62; &#60;day-of-month&#62; &#60;month&#62; &#60;day-of-week&#62; &#60;year&#62;\n\nwhere &#60;year&#62; field is optional.\n\n* **second**: may have `, - * /`, valid value is integer `0-59`\n* **minute**: may have `, - * /`, valid value is integer `0-59`\n* **hour**: may have `, - * /`, valid value is integer `0-23`\n* **day-of-month**: may have `, - * / ? L W C`, valid value is integer `0-31`\n* **month**: may have `, - * /`, valid value is integer `1-12` or `JAN-DEC`\n* **day-of-week**: may have `, - * / ? L C #`, valid value is integer `1-7` or `SUN-SAT`. `1` represent sunday, `2` represent monday...\n* **year**: may have `, - * /`, valid value is integer `1970-2099`\n\n## Specials Characters In Expression\n* **\\* (all)**: Means matching any value in the field. If using `*` in the `minute` field, it means that the event will be triggered every minute.\n* **? (any)**: Can only be applied to `day-of-month` and `day-of-week` field. It also matches any value of the field. For example, if you want to trigger the scheduling on the 20th of each month, no matter what day of week the 20th is, you can only use the following expression: `13 13 15 20 * ?`. The last bit can only use `?`.\n* **– (range)**: Means range. For example, Using `5-20` in the `minute` field means that it is triggered every minute from 5 minutes to 20 minutes.\n* **, (values)**: Means that the trigger starts at the start time, and then triggers at regular intervals. Write as `start/intervals`. For example, using 5/20 in the `minute` field means triggering at 5 minutes, and 25 minutes, 45 minutes.\n* **/ (increments)**: Means enumerated values. For example: using `5,20` in the `minute` field means triggering at 5 and 20 minutes.\n* **L (last)**: Means at the end. It can only appear in the `day-of-week` and `day-of-month` fields. If `5L` is used in the `day-of-week` field, it means that it is triggered on the last Thursday of the month.\n* **W (weekday)**: Means a valid working day (Monday to Friday). It can only appear in the `day-of-month` field. The system will trigger an event on the closest valid working day from the specified date. For example: `5W` is used in `day-of-month`. If the 5th is Saturday, it will be triggered on the nearest working day: Friday, that is, the 4th. If the 5th is Sunday, it will be triggered on the 6th (Monday); if the 5th is one of Monday to Friday, it will be triggered on the 5th. In addition, W's nearest search will not cross the month\n* **LW**: These two characters can be used together to indicate the last working day of a month, that is, the last Friday.\n* **\\#**: It is used to determine the day of the week of each month and can only appear in the `day-of-month` field. For example, `4#2` means the second Wednesday of a month.\n\n## Examples\n`30 * * * * ?`: Trigger task every 30 seconds\n`30 10 * * * ?`: Trigger task at 10 minutes and 30 seconds per hour\n`30 10 1 * * ?`: Trigger task every day at 1:10:30\n`30 10 1 20 * ?`: Trigger task at 1:10:30 on the 20th of each month\n`30 10 1 20 10 ? *`: Trigger task at 1:10:30 on the October 20th of each year\n`30 10 1 20 10 ? 2011`: Trigger task at 1:10:30 on the October 20th of 2011\n`30 10 1 ? 10 * 2011`: Trigger task every day at 1:10:30 in October 2011\n`30 10 1 ? 10 SUN 2011`: Trigger task every Sunday at 1:10:30 in October 2011\n`15,30,45 * * * * ?`: Trigger task every 15 seconds, 30 seconds, and 45 seconds\n`15-45 * * * * ?`: Trigger task every second from 15 to 45 seconds\n`15/5 * * * * ?`: Trigger task every 5 seconds starting at 15 seconds\n`15-30/5 * * * * ?`: Trigger task every 5 seconds between 15 and 30 seconds every minute\n`0 0/3 * * * ?`: Trigger task every 3 minutes starting 0 minutes and 0 seconds\n`0 15 10 ? * MON-FRI`: Trigger task from 10:15:00 from Monday to Friday\n`0 15 10 L * ?`: Trigger task at 10:15:00 on the last day of each month\n`0 15 10 LW * ?`: Trigger task at 10:15:00 on the last working day of each month\n`0 15 10 ? * 5L`: Trigger task at 10:15:00 on the last Thursday of every month\n`0 15 10 ? * 5#3`: Trigger task at 10:15:00 on the third week of each month","tags":["Cron Expression"]},{"title":"Leetcode 56. Merge Intervals","url":"/Leetcode-56-Merge-Intervals/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nMerge the intervals that have overlaps.\n\n### Similar Questions\n* Hard - [57. Insert Interval](https://leetcode.com/problems/insert-interval/)\n* Medium - [495. Teemo Attacking](https://leetcode.com/problems/teemo-attacking/)\n* Hard - [715. Range Module](https://leetcode.com/problems/range-module/)\n* Medium - [763. Partition Labels](https://leetcode.com/problems/partition-labels/)\n* Medium - [986. Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/)\n\n## Solution\nSuppose given an array of size `n`, then we assume that the first `n-1` elements has been merged. What we have to solve now is the remaining one, how to add it to the `n-1` elements that have been merged.\n\nWhat we can do here is first sort the whole array by the left endpoint of the interval. Then loop the whole array, and adding in the new one with the last element of already merged intervals.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nAfter sorting, we can simply compare the new interval with the last interval in the result set, see if they have overlap.\n\n* Case 1: If the left endpoint of the new interval is greater than the right endpoint of the last interval of the result list, then just add the new interval directly.\n\nFor example:\nResult list:  (1, 6), (8, 12)\nNew interval: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(15, 19)\nNew result list: (1, 6), (8, 12), (15, 19)\n\n* Case 2: If the left endpoint of the new interval is not larger than the right endpoint of the last interval of the result list then only the right endpoint of the new interval and the right endpoint of last interval of the result list need to be determined.\n\nResult list: (1, 6), (8, 12), (15, 19)\nNew interval: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(17, 21)\nNew result list: (1, 6), (8, 12), (15, 21)\n\n``` Java\npublic int[][] merge(int[][] intervals) {\n    if (intervals.length == 0) {\n        return new int[0][0];\n    }\n\n    // result list\n    List<List<Integer>> listResults = new ArrayList<>();\n\n    // sort the input, use the left endpoint as key to sort\n    Arrays.sort(intervals, Comparator.comparingInt(o -> o[0]));\n\n    // add the first element\n    listResults.add(Arrays.stream(intervals[0]).boxed().collect(Collectors.toList()));\n    \n\n    for (int i = 1; i < intervals.length; i++) {\n        // get last element in the result list\n        Integer[] previous = listResults.get(listResults.size() - 1).toArray(new Integer[0]);\n\n        // check if overlap\n        if (isOverlap(previous, intervals[i])) {\n            // if overlap, update the last element of result list\n            listResults.get(listResults.size() - 1).set(0, Math.min(previous[0], intervals[i][0]));\n            listResults.get(listResults.size() - 1).set(1, Math.max(previous[1], intervals[i][1]));\n        } else {\n            // add new interval to the result set\n            listResults.add(Arrays.stream(intervals[i]).boxed().collect(Collectors.toList()));\n        }\n    }\n\n    // convert to 2d array\n    int[][] results = new int[listResults.size()][2];\n    for (int i = 0; i < listResults.size(); i++) {\n        results[i][0] = listResults.get(i).get(0);\n        results[i][1] = listResults.get(i).get(1);\n    }\n\n    return results;\n}\n\n// determine if 2 intervals overlap\nprivate boolean isOverlap(Integer[] a, int[] b) {\n    return !(a[1] < b[0]);\n}\n```","tags":["Leetcode - Array","Leetcode - Sort"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 55. Jump Game","url":"/Leetcode-55-Jump-Game/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nJump from the 0th index of the array, the distance of the jump is less than or equal to the corresponding number in the array. Determine if can reach the last index.\n\n### Similar Questions\n* Hard - [45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\n\n## Solution\nWe need to know from `i-th` position, what is the furthest position it can reach. If any of the element has a furthest position that can reach end, then return `true`. If reach is position that can't be reached from previous elements, then return `false`.\n\n``` Java\nif (nums.length == 1) {\n    return true;\n}\n\n// the furthest postion that can reach\nint furthest = 0;\n// index of current position\nint index = 0;\n\nwhile (index < nums.length) {\n    // the furthest postion can be reached from this index\n    furthest = Math.max(furthest, nums[index] + index);\n\n    index++;\n\n    // if this postion can't be reached\n    if (index > furthest) {\n        return false;\n    }\n\n    // can reach last index\n    if (furthest >= nums.length - 1) {\n        return true;\n    }\n}\n\nreturn true;\n```","tags":["Leetcode - Array","Leetcode - Greedy"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 54. Spiral Matrix","url":"/Leetcode-54-Spiral-Matrix/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGive a m * n matrix, return the spiral order of all elements.\n\n### Similar Questions\n* Medium - [59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/)\n* Medium - [885. Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/)\n\n## Solution\nStart at the first position and walk along the boundary. When reach the boundary, change direction and continue until complete all positions.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nThere is no magic here, just simulate the process.\n\n``` Java\npublic List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> results = new ArrayList<>();\n\n    if (matrix.length == 0) {\n        return results;\n    }\n\n    // current index of the position\n    int indexX = 0;\n    int indexY = 0;\n\n    // up, right, down, left\n    int[][] direction = new int[][]{\n            {0, -1},\n            {1, 0},\n            {0, 1},\n            {-1, 0}\n    };\n\n    // moving direction, start towards right\n    Towards towards = Towards.RIGHT;\n\n    // mark the position of boundary\n    int topBorder = -1;\n    int bottomBorder = matrix.length;\n    int leftBorder = -1;\n    int rightBorder = matrix[0].length;\n\n    while (true) {\n        // finished\n        if (results.size() == matrix.length * matrix[0].length) {\n            return results;\n        }\n\n        results.add(matrix[indexY][indexX]);\n\n        switch (towards) {\n            // move right\n            case RIGHT:\n                // reach the boundary\n                if (indexX + 1 == rightBorder) {\n                    // change direction\n                    towards = Towards.DOWN;\n                    // move the boundary\n                    topBorder++;\n\n                    // moving toward down\n                    indexY += direction[towards.ordinal()][1];\n                } else {\n                    indexX += direction[towards.ordinal()][0];\n                }\n\n                break;\n            // move down\n            case DOWN:\n                if (indexY + 1 == bottomBorder) {\n                    towards = Towards.LEFT;\n                    rightBorder--;\n\n                    indexX += direction[towards.ordinal()][0];\n                } else {\n                    indexY += direction[towards.ordinal()][1];\n                }\n\n                break;\n            // move left\n            case LEFT:\n                if (indexX - 1 == leftBorder) {\n                    towards = Towards.UP;\n                    bottomBorder--;\n\n                    indexY += direction[towards.ordinal()][1];\n                } else {\n                    indexX += direction[towards.ordinal()][0];\n                }\n                break;\n            // move up\n            case UP:\n                if (indexY - 1 == topBorder) {\n                    towards = Towards.RIGHT;\n                    leftBorder++;\n\n                    indexX += direction[towards.ordinal()][0];\n                } else {\n                    indexY += direction[towards.ordinal()][1];\n                }\n                break;\n        }\n    }\n}\n\nprivate enum Towards {\n    UP, RIGHT, DOWN, LEFT\n}\n```","tags":["Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 53. Maximum Subarray","url":"/Leetcode-53-Maximum-Subarray/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nFind a contiguous subarray in an array that has the largest sum.\n\n### Similar Questions\n* Easy - [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\n* Medium - [152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)\n* Easy - [697. Degree of an Array](https://leetcode.com/problems/degree-of-an-array/)\n* Medium - [978. Longest Turbulent Subarray](https://leetcode.com/problems/longest-turbulent-subarray/)\n\n## Solution\nDynamic programming can be used here to tackle this problem.\n\nWe can use a one-dimensional array `dp[i]` to represent the largest sum of subarray ending at index `i`. In other words, the last element of this sub-array is the index `i` element, and this subarray has the largest sum.\n\nWe have 2 situations here:\n* If `dp[i-1] < 0`, then `dp[i] = nums[i]` \n* If `dp[i-1] >= 0`, then `dp[i] = dp[i-1] + nums[i]`\n\nCode:\n``` Java\n// dp array\nint[] dp = new int[nums.length];\nint result = nums[0];\n\n// base condition\ndp[0] = nums[0];\n\nfor (int i = 1; i < nums.length; i++) {\n    //2 situations to update dp[i]\n    if (dp[i - 1] < 0) {\n        dp[i] = nums[i];\n    } else {\n        dp[i] = dp[i - 1] + nums[i];\n    }\n\n    // update result\n    result = Math.max(result, dp[i]);\n}\n\nreturn result;\n```\n\nTime complexity O(n), and space complexity O(n).\n\nNotice that we only used `dp[i-1]`, so the whole dp array isn't necessary here. Just need a variable to store the previous value.\n\n``` Java\nint previous = nums[0];\nint result = nums[0];\n\nfor (int i = 1; i < nums.length; i++) {\n    //2 situations to update dp[i]\n    if (previous < 0) {\n        previous = nums[i];\n    } else {\n        previous = previous + nums[i];\n    }\n\n    // update result\n    result = Math.max(result, previous);\n}\n\nreturn result;\n```\n\nThis way, time complexity is still O(n), but space complexity is optimized O(1).","tags":["Leetcode - Dynamic Programming","Leetcode - Array","Leetcode - Divde and Conquer"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 48. Rotate Image","url":"/Leetcode-48-Rotate-Image/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nRotate a 2D matrix by 90 degrees (clockwise). The rotation should be in-place (no extra space allocated).\n\n## Solution\nTo rotate 90 degrees clockwise, all we have to do is:\n1. Exchange by diagonal\n2. Exchange by center axis\n\nSee the graph for an illustration (image reference: [https://zhuanlan.zhihu.com/p/58965148](https://zhuanlan.zhihu.com/p/58965148))\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\n``` Java\npublic void rotate(int[][] matrix) {\n    int size = matrix.length;\n\n    // first rotate by diagonal\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            exchange(matrix, i, j);\n        }\n    }\n\n    // then exchange by mid\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size / 2; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[i][size - j - 1];\n            matrix[i][size - j - 1] = temp;\n        }\n    }\n}\n\n// exchange matrix[i][j] and matrix[j][i] in the matrix\nprivate void exchange(int[][] matrix, int i, int j) {\n    int temp = matrix[i][j];\n    matrix[i][j] = matrix[j][i];\n    matrix[j][i] = temp;\n}\n```","tags":["Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 40. Combination Sum II","url":"/Leetcode-40-Combination-Sum-II/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nSimilar to {% post_link Leetcode-39-Combination-Sum 'Question Leetcode 39. Combination Sum' %}. Only this time the same number in the array can be used <strong>once</strong>.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-39-Combination-Sum '39. Combination Sum' %}\n\n## Solution\nSolution referenced from here: [https://leetcode.com/problems/combination-sum-ii/discuss/16878/Combination-Sum-I-II-and-III-Java-solution-(see-the-similarities-yourself)](https://leetcode.com/problems/combination-sum-ii/discuss/16878/Combination-Sum-I-II-and-III-Java-solution-(see-the-similarities-yourself))\n\nThe whole algorithm works 99% same as {% post_link Leetcode-39-Combination-Sum '39. Combination Sum' %}. We only need to make sure that each number is only used once in the result. So how do we achieve that. We can sort the input array and skip the numner if it's same with previous number.\n\nCode:\n``` Java\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> results = new ArrayList<>();\n\n    // sort to remove duplicates\n    Arrays.sort(candidates);\n\n    backtrack(results, new ArrayList<>(), candidates, target, 0);\n\n    return results;\n}\n\nprivate static void backtrack(List<List<Integer>> results,\n                                List<Integer> tempList,\n                                int[] candidates,\n                                int remaining, \n                                int start) {\n    if (remaining < 0) {\n        return;\n    } else if (remaining == 0) {\n        results.add(new ArrayList<>(tempList));\n    } else {\n        for (int i = start; i < candidates.length; i++) {\n            // skip same number\n            if (i > start && candidates[i] == candidates[i - 1]) {\n                continue;\n            }\n\n            tempList.add(candidates[i]);\n\n            // start backtrack from i + 1, so we don't visit the same number\n            backtrack(results, tempList, candidates, remaining - candidates[i], i + 1);\n\n            // find solution or remaining < 0, backtrack one number in the list\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n```","tags":["Leetcode - Array","Leetcode - Backtracking"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 39. Combination Sum","url":"/Leetcode-39-Combination-Sum/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven an array and a target value, find all unique combination of numbers that add up to target. The same number in the array can be used multiple times.\n\n### Similar Questions\n* Medium - [17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)\n* Medium - [40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)\n* Medium - [77. Combinations](https://leetcode.com/problems/combinations/)\n* Medium - [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/)\n* Medium - [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/)\n\n## Solution\nThe solution to this question is a classical backtracking algorithm. I will have another post to talk about backtracking in a lot more details. For this particular question, what we need to do is:\n* Keep adding numbers to result set. Until:\n  * The sum equals the target \n  * Or the sum is greater than the target\n* Either way, we remove the last added number and continue adding next number\n\nFor example, if the input array is `[2, 3, 6, 7]` and target is `7`, the alroghtim runs as follows:\n* Add `2`. Result = `[2]`, Sum = `2`\n* Add `2`. Result = `[2, 2]`, Sum = `4`\n* Add `2`. Result = `[2, 2, 2]`, Sum = `6`\n* Add `2`. Result = `[2, 2, 2, 2]`, Sum = `8`. As Sum is greater than target, remove the last added number `2`, new result = `[2, 2, 2]`\n* Add `3`. Result = `[2, 2, 2, 3]`, Sum = `9`. As Sum is greater than target, remove the last added number `3`, new result = `[2, 2, 2]`\n* Add `6`. Result = `[2, 2, 2, 6]`, Sum = `12`. As Sum is greater than target, remove the last added number `6`, new result = `[2, 2, 2]`\n* Add `7`. Result = `[2, 2, 2, 7]`, Sum = `13`. As Sum is greater than target, remove the last added number `7`, new result = `[2, 2, 2]`\n* No more numbers left in the array, so further remove the last number in the result, get new result = `[2, 2]`\n* Add `3`. Result = `[2, 2, 3]`, Sum = `7`. As Sum equals to target, we add this result to the final list. And remove the last added number `3`, new result = `[2, 2]`\n* Add `6`. Result = `[2, 2, 6]`, Sum = `10`. As Sum is greater than target, remove the last added number `6`, new result = `[2, 2]`\n* Add `7`. Result = `[2, 2, 7]`, Sum = `11`. As Sum is greater than target, remove the last added number `7`, new result = `[2, 2]`\n* No more numbers left in the array, so further remove the last number in the result, get new result = `[2]`\n* Add `6`. Result = `[2, 6]`, Sum = `8`. As Sum is greater than target, remove the last added number `6`, new result = `[2]`\n* Add `7`. Result = `[2, 7]`, Sum = `9`. As Sum is greater than target, remove the last added number `7`, new result = `[2]`\n* No more numbers left in the array, so further remove the last number in the result, get new result = `[]`\n* Add `3`. Result = `[3]`, Sum = `3`\n* .....so on and so forth\n\n``` Java\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> results = new ArrayList<>();\n\n    backtrack(results, new ArrayList<>(), candidates, target, 0);\n\n    return results;\n}\n\nprivate static void backtrack(List<List<Integer>> results,\n                                List<Integer> tempList,\n                                int[] candidates,\n                                int remaining, \n                                int start) {\n    if (remaining < 0) {\n        return;\n    } else if (remaining == 0) {\n        results.add(new ArrayList<>(tempList));\n    } else {\n        for (int i = start; i < candidates.length; i++) {\n            tempList.add(candidates[i]);\n\n            backtrack(results, tempList, candidates, remaining - candidates[i], i);\n\n            // find solution or remaining < 0, backtrack one number in the list\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n```","tags":["Leetcode - Array","Leetcode - Backtracking"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 34. Find First and Last Position of Element in Sorted Array","url":"/Leetcode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nFind the first and last location of target value in a sorted array. Algorithm need to run in O(logn).\n\n### Similar Questions\n* Easy - [278. First Bad Version](https://leetcode.com/problems/first-bad-version/)\n\n## Solution 1 Linear Scan\nNote that the array is sort. So we can make use of that. First scan from left to right. Once target value is found, stop scanning and record the index. Then scan from right to left, and record the index of first occurance of target value.\n\nIf target value is not found when scanning from left to right, then we can directly return `[-1. -1]` as there is no target value in the array.\n\nThis algorithm is easy enough. However, time complexity is O(n), so it is not what we really want.\n\n## Solution 2 Binary Search\nSolution referenced from here: [https://leetcode.wang/leetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.html](https://leetcode.wang/leetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.html)\n\nAs we are targeting O(logn), binary search is a good candidate. \n\nIn a normal binary search, our algorith ends as soon as we find the target value. It may not be the leftmost target value. Like in the following case (pic taken from: ):\n\n{% asset_img sample1.png %}\n<br/>\n<br/>\n\nIn this case we need to keep looking for the leftmost target value. So once we found the target value, insted of return, we make `end = mid - 1` to keep searching. Eventually, the `start` will stop at the leftmost target value. \n\nWe can do the same to find the rightmost target value. The `end` will stop at the rightmost target value\n\nCode:\n``` Java\nint start = 0;\nint end = nums.length - 1;\n\n// array to record the result\nint[] result = new int[]{-1, -1};\n\nif (nums.length == 0) {\n    return result;\n}\n\n// first, try to find target, and keep search left part\n// when this loop exit, start must point to the leftmost target, or target not exist\nwhile (start <= end) {\n    int mid = (start + end) / 2;\n\n    // find target, keep search left\n    if (nums[mid] == target) {\n        end = mid - 1;\n    } else if (nums[mid] > target) {\n        end = mid - 1;\n    } else {\n        start = mid + 1;\n    }\n}\n\nif (start == nums.length || nums[start] != target) {\n    // didn't find target\n    return result;\n} else {\n    result[0] = start;\n}\n\n// search rightmost target\nstart = 0;\nend = nums.length - 1;\n\nwhile (start <= end) {\n    int mid = (start + end) / 2;\n\n    // find target, keep search right part\n    if (nums[mid] == target) {\n        start = mid + 1;\n    } else if (nums[mid] > target) {\n        end = mid - 1;\n    } else {\n        start = mid + 1;\n    }\n}\n\n// we already know that target exist\n// end will convergence to target\nresult[1] = end;\n\nreturn result;\n```\n\nTime complexity O(logn), and space complexity O(1).","tags":["Leetcode - Array","Leetcode - Binary Search"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 33. Search in Rotated Sorted Array","url":"/Leetcode-33-Search-in-Rotated-Sorted-Array/","content":"## Question\n{% asset_img question.png %}\n<br/>\n<br/>\nThe original array is sorted, but rotated at some pivot index. We need to find the target value in the rotated array in O(logn). As we are looking for an O(logn) solution, we need to make use of binary search.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-81-Search-in-Rotated-Sorted-Array-II '81. Search in Rotated Sorted Array II' %}\n* Medium - [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)\n\n## Solution\nObserve that for a given array, if we split it into half, at least one half is sorted. For example `[4 5 6 7 8 1 2 3]`, split from `7` and get `[4 5 6 7]` and `[8 1 2 3]`. The first half is sorted. \n\nBased on this observation, we can first find out which half is sorted (by comparing the end point values). Then check if target value is in this half. If it is, then discard the other half. If not, discard this half.\n\nCode:\n``` Java\nint start = 0;\nint end = nums.length - 1;\n\nwhile (start <= end) {\n    // get the mid point\n    int mid = (start + end) / 2;\n\n    // find the target!\n    if (target == nums[mid]) {\n        return mid;\n    }\n\n    // check which side is in order by comparing end points value\n    if (nums[start] <= nums[mid]) {\n        // left side is in order\n\n        // check if target in sorted half\n        // because this half is sorted, just check to see if target is in range\n        if (target >= nums[start] && target < nums[mid]) {\n            // in this case, target in left side\n            end = mid - 1;\n        } else {\n            // in this case, target in right side\n            start = mid + 1;\n        }\n    } else {\n        // right side is in order\n        if (target > nums[mid] && target <= nums[end]) {\n            start = mid + 1;\n        } else {\n            end = mid - 1;\n        }\n    }\n}\n\n// target no found\nreturn -1;\n```\n\nTime complexity O(logn), and space complexity O(1).","tags":["Leetcode - Array","Leetcode - Binary Search"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 31: Next Permutation","url":"/Leetcode-31-Next-Permutation/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nThis problem is a bit hard to understand. Suppose we have number 123, then the permutation has 132，213，231，312，321. Sort them in order gives us: **123** 132 213 231 312 321. So what we are looking for is `132`.\n\n### Similar Questions\n* Medium - [46. Permutations](https://leetcode.com/problems/permutations/)\n* Medium - [47. Permutations II](https://leetcode.com/problems/permutations-ii/)\n* Medium - {% post_link Leetcode-60-Permutation-Sequence '60. Permutation Sequence' %}\n\n## Solution\nSolution referenced from here: [31. Next Permutation](https://leetcode.com/articles/next-permutation/)\n\nIn normal cases, to make the number bigger, we need any digit to become larger. If we want to get a number that is just larger than the original one, we need to change the ones digit. For example, change 123 to 124.\n\nSince we are dealing with permutation, we can only exchange the digits.\n\nIf we start from the ones digit and proceed from right to left, find a larger one than the ones digit, and exchange them. The ones digit are exchanged to a higher position. After exchange the number become smaller because the ones digit is smaller. For example, number 132, we swap 2 and 3 and get 123, the ones digit become larger, but the overall number becomes smaller.\n\nSo ones digit is a no-go. Lets look at tens digti. If we exchange the first larger number that is left to the tens digit, the situation is the same. We will have a smaller number. For example, number 4123, we exchange 2 and 4, get 2143, smaller number!\n\nIf for a digit, we proceed from left to right, and exhange a number to the right that is larger. For 4123, we exchange 2 and 3, get 4132 which is larger. If for a certain digit (i.e tens digit), there is no digit to the right that is larger than it, then we move towards left until we get a number that has a digit to the right that is larger.\n\nAnother question is what if there are many digits to the right that are larger than it? In this case we want the one that is just larger to make sure the final number is as small as possible.\n\nAt this point we have a rough algorithm:\n1. Scan from right to left, find the digit that is smaller than it's right digit. We make the index of this digit `i`\n2. Scan from `i` to `end`, find the digit that is just larger than `i` digit. We make the index of this digit `j`\n3. Exhange `i` and `j`\n\nBut is it over? No. Although the number is larger, it may not be the next larger number. For example `158476531`, we start from tens digit `3`, no number to the right of `3` is larger than it. We move to `5`, `6`, `7`, the same. Until `4`. Then we look back from, and find `5` that is just larger than `4`. Exchange `5` and `4`, get `158576431`. We have a larger number, but it's not the one that is just larger. We need to reverse the digits that is right to `5` and get `158513467`, which is the just larger number.\n\nLook at the gif from [Leetcode](https://leetcode.com/problems/next-permutation/solution/) might help to understand to process:\n{% asset_img example.gif %}\n<br/>\n<br/>\nNow we have our algorithm:\n\n1. Scan from right to left, find the first digit that is smaller than it's right digit\n* index `i`\n* `num[i] < num[i+1]`\n2. Scan from `i` to `end`, find the element that is immediately bigger than `nums[i]`\n* index `j`\n* From `i` to `end`, the order is guaranteed to be descending\n3. Exchange `nums[i]` and `nums[j]`\n4. Reverse elements from `i + 1` to `end`\n\nCode:\n``` Java\npublic void nextPermutation(int[] nums) {\n    // start from tens digit\n    int firstSmallerIndex = nums.length - 2;\n\n    // find the first element that is smaller than it's right element\n    while (firstSmallerIndex >= 0 && nums[firstSmallerIndex + 1] <= nums[firstSmallerIndex]) {\n        firstSmallerIndex--;\n    }\n\n    // in this case all digit are in descending order (87654321), we just need to reverse all\n    if (firstSmallerIndex == -1) {\n        reverse(nums, 0);\n        return;\n    }\n\n    // from firstSmallerIndex to nums.length - 1, it's guaranteed to be in descending order\n    // find the index that is just bigger than firstSmallerIndex\n    int j = nums.length - 1;\n    while (j >= 0 && nums[j] <= nums[firstSmallerIndex]) {\n        j--;\n    }\n\n    // swap firstSmallerIndex and j\n    swap(nums, firstSmallerIndex, j);\n\n    // reverse elements to the right of firstSmallerIndex\n    reverse(nums, firstSmallerIndex + 1);\n}\n\n// helper method to swap 2 digits in the array\nprivate void swap(int[] nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}\n\n// helper method to reverse all elements starting from start, in the array\nprivate void reverse(int[] nums, int start) {\n    int i = start;\n    int j = nums.length - 1;\n\n    while (i <= j) {\n        swap(nums, i, j);\n        i++;\n        j--;\n    }\n}\n```\n\nTime Complexity: the wrost case is to scan all digit, so that is O(n). Space complexity: O(1)\n\nTo be honest, I think this question should be a `hard` level rather than a `medium`.","tags":["Leetcode - Array"],"categories":["Data Structure and Algorithms"]},{"title":"Java 8 Optional","url":"/Java-8-Optional/","content":"Java 8 introduced `Optional` class to avoid `NullPointerException`. Basically `Optional` class is a container to represent if an object exist or not. Use `Optional` make `null` value handling more elegant. See the example:\n\n``` Java\npublic String getUsername(User user) {\n    if(user == null)\n    {\n        return \"Unkown\";\n    }\n    \n    return user.getUsername();\n}\n```\n\nWith `Optional`:\n``` Java\npublic String getUsername(User user) {\n    return Optional.ofNullable(user).map(u -> u.getUsername()).orElse(\"Unkown\");\n}\n```\n\n## Create Optional object\nThere are 3 ways to create an `Optional` object:\n1. Create an `Optional` that has no value\n``` Java\nOptional<String> optional = Optional.empty();\n```\n\n2. Create an `Optional` that the object must not be null\n``` Java\nOptional<String> optional1 = Optional.of(\"optional object\");\n```\n\n3. Create an `Optional`. The object could be null. In this case the `Optional` has no value\n``` Java\nOptional<String> optional2 = Optional.ofNullable(null);\n```\n\n## get() Method\nIt is used to return the value of the wrapper object. But if the wrapper object value is null, a `NoSuchElementException` will be thrown.\n\n## isPresent() Method\nUsed to determined the if the object is not null. Using it is not a good behavior as the logic would be excatly the same if we do a null check. And we are introducing an extra step to wrap the object with `Optional`\n\n## ifPresent() Method\nThe `ifPresent()` accept a `Consumer Interface` as parameter. If the object is not null then the `Consumer Interface` will be called to perform a specific action.\n``` Java\nOptional<User> optionalUser = Optional.ofNullable(user);\n\n// if user exist then print the username\noptionalUser.ifPresent(user -> System.out.println(user.getUsername()));\n```\n\n## filter() Method\nThe `filter() `method accepts a `Predicate` interface, which is used to filter the `Optional` object. If the condition of `Predicate` is met, the `Optional` object itself is returned. Otherwise, an empty `Optional` object is returned.\n``` Java\nOptional.ofNullable(item).filter( i -> i.getPrice() > 100).ifPresent(i ->  System.out.println(\"The item cost over $100\"));\n```\n\n## map() Method\nThe `map()` method takes a `Function` object. It uses the `Function` to the `Optional` and wrap it into a new `Optional` object (the type of the wrapper object may change).\n``` Java\nOptional.ofNullable(user).map(u -> u.getUsername()); \n```\n\n## orElse() Method\nIf the `Optional` object is not null, then return it's value. Otherwise return the default value specified as the function parameter.\n``` Java\nOptional.ofNullable(user).map(u -> u.getUsername()).orElse(\"Unkown\");\n```\n\n## orElseGet() Method\nSimilar to `orElse()`, except that the parameter of the `orElseGet()` is a `Supplier` object. The return value of the `get()` of the `Supplier` object is used as the default value.\n``` Java\nOptional.ofNullable(user).map(u -> u.getUsername()).orElseGet(() -> \"Unkown\");  \n```\n\n## orElseThrow() Method\nSimilar to `orElseGet()`. The parameters are all `Supplier` objects, except that the `Supplier` object of `orElseThrow()` must return a `Throwable` exception. The `orElseThrow()` method is useful for scenarios where a specific exception needs to be thrown when the wrapped object value is null.\n``` Java\nOptional.ofNullable(user).map(u -> u.getUsername()).orElseThrow(() -> new RuntimeException(\"Unkown\"))\n```","tags":["Java 8 New Features"],"categories":["Java"]},{"title":"Leetcode 18: 4Sum","url":"/Leetcode-18-4Sum/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\n\nSimilar to {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}. This time we want to find all 4 numbers that add up to the target  value.\n\n### Similar Questions\n* Easy - [1. Two Sum](https://leetcode.com/problems/two-sum/)\n* Medium - {% post_link Leetcode-15-3Sum '15: 3Sum' %}\n* Medium - [454. 4Sum II](https://leetcode.com/problems/4sum-ii/)\n\n## Soultion\nThe idea is excatly same with {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}. Just adding another layer of for loop.\n\n1. Sort the array\n2. First for loop to get the first number. (0 - num.length - 3)\n3. Use an If statement to avoid duplicate. (Skip the same number)\n4. Second for loop to get second number. (i + 1 to num.length - 2)\n5. Another If statement to avoid duplicate. (Skip the same number)\n6. Now we use 2 pointers `head` and `tail` to find remaining 2 numbers\n7. `sum = target - num[i] - num[j]`\n8. Depending on the comparison of sum and target:\n  8.1 sum = target: add to the result list, and move inward `head` and `tail` until all same number are skipped\n  8.2 sum < target: `head++`\n  8.3 sum > target: `tail--`\n\n``` Java\n        List<List<Integer>> results = new ArrayList<>();\n\n        Arrays.sort(nums);\n\n        // first for loop to get first number\n        for (int i = 0; i < nums.length; i++) {\n            // to avoid duplicate\n            if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n                // second for loop to get second number\n                for (int j = i + 1; j < nums.length; j++) {\n                    // to avoid duplicate\n                    if (j == i + 1 || (j > 0 && nums[j] != nums[j - 1])) {\n                        int low = j + 1;\n                        int high = nums.length - 1;\n\n                        int sum = target - nums[i] - nums[j];\n\n                        // find remaining 2 numbers\n                        while (low < high) {\n                            // find the results\n                            if (nums[low] + nums[high] == sum) {\n                                results.add(Arrays.asList(nums[i], nums[j], nums[low], nums[high]));\n\n                                low++;\n                                high--;\n\n                                // skip same number\n                                while (low < high && nums[low] == nums[low - 1]) {\n                                    low++;\n                                }\n\n                                // skip same number\n                                while (low < high && nums[high] == nums[high + 1]) {\n                                    high--;\n                                }\n                            } else if (nums[low] + nums[high] > sum) {\n                                high--;\n                            } else {\n                                low++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return results;\n```\n\nTime complexity O(n<sup>3</sup>), and space complexity O(1).","tags":["Leetcode - Array","Leetcode - Two Pointers","Leetcode - Hash Table"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 16: 3Sum Closest","url":"/Leetcode-16-3Sum-Closest/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nSimilar to {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}. This time we want to find the 3 sum that is closest to the target value.\n\n### Similar Questions\n* Medium - {% post_link Leetcode-15-3Sum '15: 3Sum' %}\n\n## Solution 1\nBrute force. We need 3 nested loop to get all possible sums, and then get the sum that is closest to the target. Time  complexity is O(n<sup>3</sup>). Space complexity O(1).\n\n## Solution 2\nWe can make use of the similar idea of {% post_link Leetcode-15-3Sum 'Question 15: 3Sum' %}.\n1. Sort the array\n2. Loop the array to get the first number `nums[i]`\n3. Use 2 pointers `head` and `tail` to loop the remaining array (`head = i + 1`)\n4. `sum = nums[i] + nums[head] + nums[tail]`\n5. Depending on the comparison of sum and target:\n  5.1 sum = target: then we can return the value as it as closest to the target\n  5.2 sum < target: `head++`\n  5.3 sum > target: `tail--`\n6. Use a variable to keep track of the smallest distance\n\nCode:\n``` Java\n    // keep trakc of minimun distance\n    int distance = Integer.MAX_VALUE;\n    int result = 0;\n\n    // sort the array\n    Arrays.sort(nums);\n\n    for (int i = 0; i < nums.length; i++) {\n        int low = i + 1;\n        int high = nums.length - 1;\n\n        // another loop with 2 pointers\n        while (low < high) {\n            int tempSum = nums[i] + nums[low] + nums[high];\n            if (tempSum == target) {\n                return tempSum;\n            } else if (tempSum > target) {\n                high--;\n            } else {\n                low++;\n            }\n\n            if (Math.abs(tempSum - target) < distance) {\n                distance = Math.abs(tempSum - target);\n                result = tempSum;\n            }\n        }\n    }\n\n    return result;\n```\n\nWe are running 2 loops (O(n<sup>2</sup>)), and space complexity O(1).","tags":["Leetcode - Array","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"Leetcode 15: 3Sum","url":"/Leetcode-15-3Sum/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nGiven an array, find all unique triplets that add up to 0\n\n### Similar Questions\n* Easy - [1. Two Sum](https://leetcode.com/problems/two-sum/)\n* Medium - {% post_link Leetcode-16-3Sum-Closest '16: 3Sum Closest' %}\n* Medium - {% post_link Leetcode-18-4Sum '18: 4Sum' %}\n\n## Solution 1\nBrute force solution. We need 3 nested for loops. If we found that `nums[i] + nums[j] + nums[k] == target`, then need to check if the solution already exist (which takes O(n)). So the overall complexity is O(n<sup>3</sup>). Space complexity O(1).\n\n## Solution 2\nReference [https://leetcode.com/problems/3sum/discuss/7380/Concise-O(N2)](https://leetcode.com/problems/3sum/discuss/7380/Concise-O(N2)) as a O(n<sup>2</sup>) solution.\n\nThe main idea is to iterate through the array, fix one number as sum, and find another 2 numbers that add up to -sum. The clever thing is how to find the other two numbers in O(n).\n\nThe achieve that, first we need to sort the array.\n\nThen we get `num[i]` as target , and try to find if there are 2 element add up to `-num[i]`. As the array is sorted, we can use 2 pointers (low and high) at head and tail, so find 2 elements takes O(n).\n* `num[low] + num[high] > target`, high = high -1. As we are greater than target, we need to decrease the high pointer to make sum smaller.\n* `num[low] + num[high] < target`, low++. As we are smaller than target, we need to increase the low pointer to make sum larger.\n\nTo avoid add duplicate result, we need to move the pointer to point to different number with `num[low]` and `num[high]`. For example, let's say the array is `[-2, -1, 0, 0, 1, 1, 2, 3]`. The `num[i] = -2`. We found that `num[1] + num[5] + num[i] = 0`. To continue the loop, we need to move `high = 5` to `high = 3`. If we don't have this step, then when the loop continues, we will have `num[1] + num[4] + num[i] = 0` and this result is duplicate with the result we already have.\n\nCode:\n``` Java\nList<List<Integer>> results = new ArrayList<>();\n\n// sort the array\nArrays.sort(nums);\n\nfor (int i = 0; i < nums.length; i++) {\n    // skip the same number in array when we choose the number as sum target\n    if (i > 0 && nums[i] == nums[i - 1]) {\n        continue;\n    }\n\n    // start the loop to find remaining 2 numbers\n    int low = i + 1;\n    int high = nums.length - 1;\n\n    int target = -nums[i];\n\n    while (low < high) {\n        // find the 2 numbers\n        if (nums[low] + nums[high] == target) {\n            results.add(Arrays.asList(nums[low], nums[high], nums[i]));\n\n            low++;\n            high--;\n\n            // skip same number to avoid duplicate\n            while (low < high && nums[low] == nums[low - 1]) {\n                low++;\n            }\n\n            // skip same number to avoid duplicate\n            while (low < high && nums[high] == nums[high + 1]) {\n                high--;\n            }\n        } else if (nums[low] + nums[high] > target) {\n            high--;\n        } else {\n            low++;\n        }\n    }\n}\n\nreturn results;\n```\n","tags":["Leetcode - Array","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"How to deserialize Json content with unknown property when using Jackson","url":"/How-to-deserialize-Json-content-with-unknown-property-when-using-Jackson/","content":"When using Jackson to deserialize a Json string, if the Java object does't include all the fields in the Json, Jackson will complain about unknown properties. In this post I will show how to ignore the properties if it is not defined in our Java object.\n\nSuppose we have the following Json string:\n```\n{\n    \"name\": \"name1\", \n    \"studentId\": \"12345\",\n    \"major\": \"computer science\"\n}\n```\n\nAnd the Java object:\n``` Java\nclass Student {\n    String name;\n    int studentId;\n\n    // getters and setters\n}\n```\n\nWhen we map the Json to the Java object, will see the following exception:\n```\ncom.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: \nUnrecognized field \"major\" (class com.experiment.jackson.JacksonDeserialize$Student), \nnot marked as ignorable (2 known properties: \"name\", \"studentId\"])\n```\n\nThere are 2 ways to deal with this problem:\n1. Configure the ObjectMapper to ignore unknown properties\n``` Java\nObjectMapper mapper = new ObjectMapper();\nmapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n```\n\n2. Mark the Java object to ignore unknown field. This way we only specify to ignore unknown properties when deserialize this particular class.\n``` Java\n@JsonIgnoreProperties (ignoreUnknown = true)\nclass Student {\n    String name;\n    int studentId;\n    \n    // getters and setters\n}\n```","tags":["Jackson"],"categories":["Java"]},{"title":"Leetcode 11: Container With Most Water","url":"/Leetcode-11-Container-With-Most-Water/","content":"## Question\n{% asset_img Question.png %}\n<br/>\n<br/>\nEach element of the array represents a height of a column. We want to pick 2 columns that can hold the most amount of water (shorter column height * distance between 2 columns).\n\n### Similar Questions\n* Hard - [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)\n\n## Solution 1\nThe most naive method is brute force. Check each pair of elements and calculate the result. Use a variable to store the largest one. We need 2 for loops, so the time complexity is O(n<sup>2</sup>). The good thing is that no extra space required. Thus space complexity is O(1).\n\n## Solution 2\nThe amount of water is determined by shorter column height and distance between 2 columns. If we start from maximun distance (in the following example, index 0 and 8). Then the height is column 0 as we are getting the shorter column height.\n\n{% asset_img 1.png %}\n<br/>\n<br/>\n\nIf we want to have a larger area, we can only reduce the distance and increase the height. So do we move the column 0 to column 1 ? Or column 8 to column 7? Of course, we will move the column that is shorter, so that the height might be increased.\n\nIn this example, if we change the column 8 to column 7, the distance is reduced, but the height is still unchanged (column 0 is still shorter), so the area will be reduced. But if we move column 0 to column 1, then column 8 becomes the shorter column and the area may increase.\n\nWhat if 2 columns have the same height? Well, in this case it doesn't matter which one we move. There will be 2 Circumstances.\n\n* There are 0 or 1 column between the 2 columns that is higher. Then the maximun area is when we choose these 2 same height column. As no matter how we move, the height is always less than these 2 columns, and distance is also smaller.\n* There are 2 or more columns between the 2 columns that is higher. These 2 columns will move to higher columns eventually, no matter which one moves first. \n\nSo the algorithm goes as follows:\n1. Have 2 pointers. one at start of array and one at the end of array.\n2. Each time move one pointer with smaller height inward\n3. Use a variable to record the area each time\n4. Loop until 2 pointers cross\n\nCode\n``` Java\nint result = 0;\nint left = 0;\nint right = height.length - 1;\n\nwhile (left < right) {\n    result = Math.max(result, (right - left) * Math.min(height[left], height[right]));\n\n    if (height[left] < height[right]) {\n        left++;\n    } else {\n        right--;\n    }\n}\n\nreturn result;\n```\n\nWe only loop the array once, so time complexity O(n). Space complexity O(1)","tags":["Leetcode - Array","Leetcode - Two Pointers"],"categories":["Data Structure and Algorithms"]},{"title":"How to force Github Pages rebuild","url":"/How-to-force-Github-Pages-rebuild/","content":"Github Pages has a nice feature that whenever you made a new commit, it will automatically build the page and publish the new changes. However, I ran into a strange situation that Github Pages didn't build my new commit. I could have just make another commit to trigger the build, but I'd rather have a nicer solution which can force Github Pages to build my site. After a bit of google search, turned out that Github provides an API to request a page build. Let's look at how to do this.\n\n## How to check the build status of Github Pages\nFirstly, let's look at how to check the build status of Github Pages. The easiest way is to check the commit history of your repository:\n{% asset_img commit.png %}\n<br/>\n<br/>\nIf the build fails due to some errors, then you will see something like this:\n{% asset_img commit-fail.png %}\n<br/>\n<br/>\nThen you should be able to check the error message by click on the red cross\n{% asset_img check.gif %}\n\n(GIF taken from [https://github.blog/2019-09-13-github-pages-builds-now-use-the-checks-api/](https://github.blog/2019-09-13-github-pages-builds-now-use-the-checks-api/))\n\n## Use Github API to force Github Pages rebuild site\nI found the solution here: [https://stackoverflow.com/questions/24098792/how-to-force-github-pages-build](https://stackoverflow.com/questions/24098792/how-to-force-github-pages-build)\n\n### Create a personal access token\nFollow the instructions here: [https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line](https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line)\n\nLog in Github account and navigate to: *Settings* -> *Developer settings* -> *Personal access tokens* -> *Generate new token*\n\nSelect *repo* scope\n{% asset_img repo.png %}\n\n### Call the Github API\nRun the script from command line or terminal:\n\n``` bash\ncurl -u username:token -X POST https://api.github.com/repos/username/reponame/pages/builds -H \"Accept: application/vnd.github.mister-fantastic-preview+json\"\n```\n\nReplace `username` with Github username\nReplace `token` with access token\nReplace `reponame` with repository name\n\nCheck detailed API documentation here: [https://developer.github.com/v3/repos/pages/#request-a-page-build](https://developer.github.com/v3/repos/pages/#request-a-page-build)\n\nYou should be able to see the result like this:\n{% asset_img result.png %}","categories":["how-to-guide"]},{"title":"Use Intellij to visualize debugging Stream operation","url":"/Use-Intellij-to-visualize-debugging-Stream-operation/","content":"Last time I talked about the stream API feature in Java 8. It is a very good new feature, but unlike previously looping code, single-step debugging does not work for stream API. Luckily, IntelliJ IDEA provides a tool for us to visualize the stream code.\n\nExample code:\n``` Java\nList<Integer> numbers2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\n\nnumbers2.stream()\n    .map(x -> x * x)\n    .filter(x -> x % 3 == 0)\n    .forEach(System.out::println);\n```\n\n<br/>\nAdd a break point at the last line of stream\n{% asset_img breakpoint.png %}\n<br/>\n<br/>\nStart debug, and find the button in debug interface\n{% asset_img button.png %}\n<br/>\n<br/>\nWait for a few seconds, you can see the results of each step of the stream operation\n{% asset_img result.png %}","tags":["Stream API","Intellij"],"categories":["Java"]},{"title":"Java 8 Streams Operations","url":"/Java-8-Streams-Operations/","content":"Stream operation is one of the main feature of Java 8. I have met these code a lot recently in the work. So I thought it would be good to write it up and summarize the key point of the knowledge.\n\n## Creation of stream\nThere are multiple different ways to create steams:\n\n### Stream.of()\n``` Java\nstatic <T> Stream<T> of(T... values)\n```\nExample:\n``` Java\nStream<String> stringStream = Stream.of(\"a\", \"b\", \"c\", \"d\");\n\nstringStream.forEach(System.out::println);\n\n// ============== Output：===============\n// a\n// b\n// c\n// d\n```\n\n### Stream.iterate()\n``` Java\nstatic <T> Stream<T> iterate(T seed, UnaryOperator<T> f)\n```\nCreate a stream start with a value, and iterate through by a certain operator.\n\nExample:\n``` Java\nStream.iterate(10, n -> n + 1)\n    .limit(5)\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// 10\n// 11\n// 12\n// 13\n// 14\n```\n\n### Stream.generate()\n``` Java\nstatic <T> Stream<T> generate(Supplier<T> s)\n```\nCreate a stream based on the value generate function. The generate function returns 1 value each time\n\nExample:\n``` Java\nStream.generate(Math::random)\n    .limit(5)\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// 0.09623470299238657\n// 0.8470095359492898\n// 0.20505426293183482\n// 0.8112754654328852\n// 0.009673283068063365\n```\n\n### Create a stream from an existing collection\n``` Java\nList<String> strings = Arrays.asList(\"hello\", \"world\", \"Java8\");\n\nstrings.stream().forEach(System.out::println);\n\n// ============== Output：===============\n// hello\n// world\n// Java8\n```\n\n## Stream operation\nNow we know how to create stream, let's look at what operations can be applied to stream\n\n### Filter and slice\n#### filter()\nThe filter method accepts a function that returns a boolean as a parameter, and returns a stream containing all the elements that match the condition. \n\nFor example, you can select all words starting with the letter w and print them like this:\n\n``` Java\nList<String> words = Arrays.asList(\"random\", \"hello\", \"wow\", \"world\", \"java\");\n\nwords.stream()\n    .filter(word -> word.startsWith(\"w\"))\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// wow\n// world\n```\n\nOr you can get the list that match those condition like this:\n``` Java\nList<String> words = Arrays.asList(\"random\", \"hello\", \"wow\", \"world\", \"java\");\n\nList<String> filtered = words.stream()\n    .filter(word -> word.startsWith(\"w\"))\n    .collect(Collectors.toList());\n```\n\n#### distince()\nThe distinct method will return a stream of elements that are unique. \n\nFor example, the following code returns the list that has no duplicates:\n``` Java\nList<Integer> numbers = Arrays.asList(1, 2, 1, 3, 2, 1, 3, 4);\n\nnumbers.stream()\n    .distinct()\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// 1\n// 2\n// 3\n// 4\n```\n\n#### skip()\nThe skip(n) method returns a stream that throws away the first n elements. If there are fewer than n elements in the stream, an empty stream is returned.\n\n### Mapping\nA very common data processing method is to select information from certain objects. For example, in SQL, you can select a column from the table, and the Stream API also provides similar tools through the `map` and `flatMap` methods.\n\n#### map()\nBefore Java8, we  need to take out one field of a collection object and then save it to another collection. With stream map, we can simply use map function to map out the field we want, then use collect them to new collection\n\n``` Java\npublic static void main(String[] args) {\n    List<Person> persons = Arrays.asList(new Person(20, \"Nick Li\"),\n        new Person(30, \"Mike\"), new Person(40, \"Peter\"));\n\n    persons.stream()\n        .map(Person::getAge)\n        .forEach(System.out::println);\n}\n\n// ============== Output：===============\n// 20\n// 30\n// 40\n\nprivate static class Person {\n    private int age;\n    private String name;\n\n    public int getAge() {\n        return age;\n    }\n\n    // skip constructor and other set, get methods\n}\n```\n\n#### flatMap()\nIf we want to know how many unique character in a list of words,  what should we do?\n\n``` Java\nList<String> words = Arrays.asList(\"Hello\", \"World\");\n\nwords.stream()\n    .map(s -> s.split(\"\"))\n    .distinct()\n    .collect(Collectors.toList())\n    .forEach(System.out::println);\n\n// ============== Output：===============\n// [Ljava.lang.String;@312b1dae\n// [Ljava.lang.String;@7530d0a\n```\n\nThis is wrong because the map function returns a `String[]`. So we get a `Stream<String[]>` instead of `Stream<String>`. To solve this problem, we can use flatMap:\n``` Java\nList<String> words = Arrays.asList(\"Hello\", \"World\");\n\nwords.stream()\n     .map(s -> s.split(\"\"))\n     .flatMap(Arrays::stream)\n     .distinct()\n     .forEach(System.out::println);\n\n// ============== Output：===============\n// H\n// e\n// l\n// o\n// W\n// r\n// d\n```\n\nThe effect of using flatMap method is that each array is not mapped to a stream, but to the contents of the stream. In a nutshell, flatMap lets you convert each value in a stream to another stream, then join all the streams into one stream.\n\n### Find and match\nAnother common data processing method is to see if certain elements in the dataset match a given condition. The Stream API provides such tools through `allMatch`, `anyMatch`, `noneMatch`, `findFirst`, and `findAny` methods.\n\nThe function name is very self-explanatory. Let see some examples\n\nTo check if a collection contains even numbers:\n``` Java\nList<Integer> numbers = Arrays.asList(1, 2, 3);\n\nif (numbers.stream().anyMatch(x -> x % 2 == 0)) {\n    System.out.println(\"Yes\");\n} else {\n    System.out.println(\"No\");\n}\n\n// ============== Output：===============\n// Yes\n```\n\nTo find the first number in the list that it's square can be divided by 3\n``` Java\nList<Integer> numbers2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7);\n\nOptional<Integer> goodNumber = numbers2.stream()\n    .map(x -> x * x)\n    .filter(x -> x % 3 == 0)\n    .findFirst();\n\nSystem.out.println(goodNumber.get()); \n\n// ============== Output：===============\n// 9\n```\n\n### Reduce\nWe might need to complete more complext task, such as “Choose the longest word in a word” or “Calculate the total length of all words”. Such queries need to repeatedly combine the elements in the stream to get the final value. Such a query can be classified as a reduction operation (reducing the stream to a value).\n\nTo calculate the sum of an array:\n``` Java\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\nint sum = numbers.stream().reduce(0, (a, b) -> a + b);\n        \n// ============== Output：===============\n// 15\n```\n\nReduce returns the result every time and operates the result with the next element, such as the first time when traversing to element 1, returning the initial value 0 + 1 = 1, then using the return value of 1 and the second element 2, and so on, until the summation of the list of numbers is completed.\n\n### Intermediate and terminal operation\nAll operations on the Stream API fall into two categories: intermediate operations and terminal operations. The intermediate operation is just a kind of markup, and only the terminal operation will trigger the actual calculation.\n\n**Intermediate operations** can be divided into *stateless* and *stateful*. *Stateless* intermediate operations mean that the processing of elements is not affected by the previous elements, and *stateful* intermediate operations must wait until all elements are processed. For example, sorting is a stateful operation, and the sorting result cannot be determined until all elements are read.\n\n**The terminal operation** can be divided into *short-circuit* operation and *non-short-circuit* operation. The short-circuit operation means that the result can be returned without processing all the elements, such as finding the first element that satisfies the condition.\n\nA stream pipeline consists of a stream source, followed by zero or more intermediate operations, and a terminal operation.\n\n## To summarize the Stream API:\nA stream pipeline consists of a stream source, followed by zero or more intermediate operations, and a terminal operation.\n\n<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}\n.tg .tg-axxb{font-weight:bold;background-color:#c0c0c0;color:#000000;border-color:inherit;text-align:center;vertical-align:top}\n.tg .tg-n9g5{background-color:#ffffff;color:#000000;border-color:inherit;text-align:left;vertical-align:middle}\n.tg .tg-x5q1{background-color:#ffffff;color:#000000;border-color:inherit;text-align:center;vertical-align:middle}\n.tg .tg-mq6t{background-color:#ffffff;color:#000000;border-color:inherit;text-align:left;vertical-align:middle}\n</style>\n<table class=\"tg\">\n  <tr>\n    <th class=\"tg-axxb\" colspan=\"4\">Stream API</th>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"11\">Intermediate<br>Operation</td>\n    <td class=\"tg-x5q1\" rowspan=\"7\">Stateless</td>\n    <td class=\"tg-n9g5\">unordered()<br></td>\n    <td class=\"tg-n9g5\">If order doesn't matter, then can use unordered() together with parallel() to speed up</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">filter()</td>\n    <td class=\"tg-n9g5\">Filter out elements in the stream based on a filter function</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">map()</td>\n    <td class=\"tg-n9g5\">Map stream to another stream based on a map function</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">mapToInt()<br>mapToLong()<br>mapToDouble()</td>\n    <td class=\"tg-mq6t\">Map to int, long or double</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">flatMap()</td>\n    <td class=\"tg-n9g5\">Make [[\"ABC\", \"DEF\"], [\"FGH\", \"IJK\"]] into [\"ABC\", \"DEF\", \"FGH\", \"IJK\"]：</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">flatMapToInt()<br>flatMapToLong()<br>flatMapToDouble()</td>\n    <td class=\"tg-mq6t\">Similar to mapToInt(), mapToLong(), mapToDouble()</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">peek()</td>\n    <td class=\"tg-n9g5\">Performs specified operation on each element of the stream and returns a new stream which can be used further.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"4\">Stateful</td>\n    <td class=\"tg-n9g5\">distinct()</td>\n    <td class=\"tg-n9g5\">Filter out duplicate element in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">sorted()</td>\n    <td class=\"tg-n9g5\">Sort the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">limit()</td>\n    <td class=\"tg-n9g5\">Limit the number of elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">skip()</td>\n    <td class=\"tg-n9g5\">Skip certain number of elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"13\">Terminal<br>Operation</td>\n    <td class=\"tg-x5q1\" rowspan=\"5\">short-circuit<br></td>\n    <td class=\"tg-n9g5\">anyMatch()</td>\n    <td class=\"tg-n9g5\">Return if any element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">allMatch()</td>\n    <td class=\"tg-n9g5\">Return if all element in the stream that satisfies the condition </td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">noneMatch()</td>\n    <td class=\"tg-n9g5\">Return if no element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">findFirst()</td>\n    <td class=\"tg-n9g5\">Find first element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">findAny()</td>\n    <td class=\"tg-n9g5\">Find any element in the stream that satisfies the condition</td>\n  </tr>\n  <tr>\n    <td class=\"tg-x5q1\" rowspan=\"8\">non-short-circuit</td>\n    <td class=\"tg-n9g5\">forEach()</td>\n    <td class=\"tg-n9g5\">Iterate all elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">forEachOrdered()</td>\n    <td class=\"tg-n9g5\">Iterate all elements in the stream by order. Can't make use of parallel()</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">toArray()</td>\n    <td class=\"tg-n9g5\">Return an array of all elements in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">reduce()</td>\n    <td class=\"tg-n9g5\">Reduce all elements to one results based on given function</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">collect()</td>\n    <td class=\"tg-n9g5\">Process the elements in the stream and get all values</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">max()</td>\n    <td class=\"tg-n9g5\">Find max element in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">min()</td>\n    <td class=\"tg-n9g5\">Find min element in the stream</td>\n  </tr>\n  <tr>\n    <td class=\"tg-n9g5\">count()</td>\n    <td class=\"tg-n9g5\">Get number of element in the stream</td>\n  </tr>\n</table>","tags":["Java 8 New Features","Stream API"],"categories":["Java"]},{"title":"How to deploy Hexo blog to Github pages","url":"/How-to-deploy-Hexo-blog-to-Github-pages/","content":"\nHexo provides fast and easy one-click deployment, supporting [Github Pages](https://pages.github.com), [Netlify](https://www.netlify.com), [OpenShift](https://www.openshift.com) etc. In this post, I will walk through the process of deploying Hexo blog site to [Github Pages](https://pages.github.com).\n\n## Folder structure of Hexo \nBefore discussing the process, I think it is important to understand the folder structure of Hexo. Basically, a Hexo blog site contains the following folders:\n\n* **scaffolds:** Template folder. When you create a new post, Hexo will create a \".md\" file under `source` based on scaffold.\n* **source:** The Resource folder. It is where the user resources are stored. It stores all \".md\" files which would be rendered to html pages.\n* **themes:** Stores all theme files.\n* **public** This is where all rendered files comes in. When deploying, we need this folder to get to the Github repository so that Github pages can host it.\n\nNow let's look at how to deploy the blog site to Github Pages.\n\n## Install hexo-deployer-git\n``` bash\nnpm install hexo-deployer-git --save\n```\n\n## Setup Github repository\nLogin GitHub account and create a new repository named username.github.io, where username is the username on GitHub.\n \n * Note that the first part of the repository must exactly match the username, otherwise it won’t work.\n\nRefer to [https://pages.github.com](https://pages.github.com) for more details.\n\n## Change config file\nAdd the following lines to `_config.yml`:\n\n```\ndeploy:\n  type:    git\n  repo:    <repository url> #e.g. https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io\n  branch:  [branch]         #branch name, default is 'master'\n  message: [message]        #commit message, default is 'Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}'\n```\n\n## Generate site files and push to remote repository\n``` bash\nhexo clean\nhexo deploy\n```\n\nWait for a couple of minutes, then visit username.github.io, the blog site should be visiable!\n\n## How does it works\nWhen hexo deploy is executed, Hexo pushes the files and directories in the `public` folder to the remote repositories and branches specified in `_config.yml` and completely overwrites the existing content under that branch.","tags":["hexo"],"categories":["how-to-guide"]},{"title":"How to build a blog with hexo","url":"/How-to-build-a-blog-with-hexo/","content":"\nHexo is a blog framework powered by Node.js. I recently built my blog with it and found it extremely easy and fast. The posts are written in Markdown and Hexo will generates static files in seconds. \n\nIn this post I will walk through the steps to setup a blog running locally. There will be another post discussing deploy the blog site to Github page. Here I will only discuss how to install Hexo blog on MacOS. For installation on other platforms such as Windows, please refer to other online posts like [https://www.how2shout.com/how-to/install-hexo-nodejs-blog-on-windows-10-with-github.html](https://www.how2shout.com/how-to/install-hexo-nodejs-blog-on-windows-10-with-github.html)\n\n## Requirems to install Hexo\n* [Node.js](https://nodejs.org/en/)\n* [Git](https://git-scm.com)\n\n## Install Node.js\nRun this script in the terminal:\n``` bash\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | sh\n```\n\nEdit zsh config to load nvm each time:\n\n``` bash\nvi ~/.zshrc\n```\n\nAdd: `[[ -s $HOME/.nvm/nvm.sh ]] && . $HOME/.nvm/nvm.sh` to the end of the file\n\nThen run the command to install node.js\n``` bash\nnvm install node\n```\n\nAfter the script finishes running, you should see the following output, which means node.js is all set. Great!\n\n{% asset_img node-success.png %}\n\n## Install Git\nNext is install Git so you can checkout code from source repositry. On Mac the easiest way is to use [HomeBrew](https://brew.sh). You can install Brew with one line of command:\n\n``` bash\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\nAfter Brew is installed, use it to install Git:\n\n``` bash\nBrew install git\n```\n\n## Install Hexo\nWith Node.js and Git all set, you can install Hexo run the following  command\n\n``` bash\nnpm install -g hexo-cli\n```\n\n## Create a blog site\nNow it comes to the moment when you are able to create the blog site. Simply run:\n\n``` bash\nhexo init my-blog\ncd my-blog\nhexo install\n```\n\nHexo will download and create all necessary files to 'my-blog' folder. \n\n## Run the Hexo server\nEverything is ready and you can run the Hexo server to view your blog site!\n\n``` bash\nhexo server\n```\n\nVisit [http://localhost:4000](http://localhost:4000) and you should be able to see the webpage show up\n\n{% asset_img blog-page.png %}\n\n\nCongraturations! You have a blog site up and running. You can create a post using `hexo new post \"Blog title\"`. You can also change the themes and add plugins to the site.","tags":["hexo"],"categories":["how-to-guide"]}]